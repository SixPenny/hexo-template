{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/magiclamp/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/default_avatar.jpg","path":"images/default_avatar.jpg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/helpers.js","path":"js/helpers.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/motion_fallback.js","path":"js/motion_fallback.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/motion_global.js","path":"js/motion_global.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/js/nav-toggle.js","path":"js/nav-toggle.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.eot","path":"fonts/icon-default/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.svg","path":"fonts/icon-default/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.woff","path":"fonts/icon-default/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.ttf","path":"fonts/icon-default/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-default/selection.json","path":"fonts/icon-default/selection.json","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.eot","path":"fonts/icon-feather/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.svg","path":"fonts/icon-feather/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.woff","path":"fonts/icon-feather/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.ttf","path":"fonts/icon-feather/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-feather/selection.json","path":"fonts/icon-feather/selection.json","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.eot","path":"fonts/icon-fifty-shades/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.svg","path":"fonts/icon-fifty-shades/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.ttf","path":"fonts/icon-fifty-shades/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.woff","path":"fonts/icon-fifty-shades/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/selection.json","path":"fonts/icon-fifty-shades/selection.json","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.eot","path":"fonts/icon-icomoon/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.ttf","path":"fonts/icon-icomoon/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.svg","path":"fonts/icon-icomoon/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.woff","path":"fonts/icon-icomoon/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.eot","path":"fonts/icon-linecons/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.svg","path":"fonts/icon-linecons/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.woff","path":"fonts/icon-linecons/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-linecons/selection.json","path":"fonts/icon-linecons/selection.json","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.ttf","path":"fonts/icon-linecons/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/magiclamp/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1513915027478},{"_id":"themes/magiclamp/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1513915027481},{"_id":"themes/magiclamp/.gitignore","hash":"09f1b95eeb9105f8a0c90535e0ad240f5a535e53","modified":1513915027482},{"_id":"themes/magiclamp/.jshintrc","hash":"49b54f7b862f20d15edb1b172ef341a048ec4a9f","modified":1513915027483},{"_id":"themes/magiclamp/README.md","hash":"88957059dad24846bf5f14f8d92c3f65af7ec3b5","modified":1513915027484},{"_id":"themes/magiclamp/_config.yml","hash":"cfd158e67fc9a9df912ffe1b79380dbe87f1363e","modified":1513915077361},{"_id":"themes/magiclamp/bower.json","hash":"0caf704e12c6ebdf307ea9648bd25cdd6579d34a","modified":1513915027486},{"_id":"source/_posts/25岁每天做什么对5年之后的你有益.md","hash":"e6649a868e30d0e581fe72e943eb3db963fa9383","modified":1513919606218},{"_id":"source/_posts/Ansible模块.md","hash":"e0740bc26c6230307302a0ac4727f7207cdfd487","modified":1513919628266},{"_id":"source/_posts/AbstractQueuedSynchronizer 源码分析（共享锁）.md","hash":"66608899d909440ead581b339bb3c5abeb388c7b","modified":1513919602603},{"_id":"source/_posts/Ansible简介及思想.md","hash":"7aa8f1b83b110864e31d7a96b64a19a16bc1bdf2","modified":1513919599466},{"_id":"source/_posts/CompletableFuture的使用.md","hash":"6bfa97c769f97a757beb5c9bb9636a04ac13ba0c","modified":1513919625866},{"_id":"source/_posts/Java动态代理与Cglib代理比较.md","hash":"dbb7ddc3dc8c3dd72adf03708c189c59d7f9be25","modified":1513919623270},{"_id":"source/_posts/Liquibase介绍与使用.md","hash":"f2779309e9ccc74069e2a567e94e35ca2e50d0af","modified":1513919620830},{"_id":"source/_posts/Spring Boot开启https.md","hash":"595016d3b3865f5772292ff71cea9d3fbe291b11","modified":1513919617936},{"_id":"source/_posts/使用Optional来减少null检查.md","hash":"5d644e9161c0552a7e2d1b269ffc4787adbe03b8","modified":1513919610709},{"_id":"source/_posts/关于防御式编程的思考.md","hash":"52d8496bee3d6a9ee372ebc31daed5119a0444b5","modified":1513919613322},{"_id":"source/_posts/卓有成效的管理者.md","hash":"63499f8a7811f20d0d2dd534f1c2fcead92d83f6","modified":1513919608474},{"_id":"source/_posts/单元测试思考.md","hash":"9fa9267d3b285671b12278ba7f66380bcb0d9210","modified":1513919615632},{"_id":"source/categories/index.md","hash":"4fb5401541971cea28688a50a79661f7701c0bd6","modified":1513919944365},{"_id":"source/tags/index.md","hash":"453930eb35f800d13957bce75cd8455ef36c2636","modified":1513919915705},{"_id":"themes/magiclamp/.git/HEAD","hash":"92e66e13f81d377b34778ad8739b9c4126e09bda","modified":1513915027457},{"_id":"themes/magiclamp/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1513915007959},{"_id":"themes/magiclamp/.git/index","hash":"ad9623bc0f3e75d374bc7f3c5d0f792388b4f708","modified":1513915027629},{"_id":"themes/magiclamp/.git/config","hash":"ea22a13652fe0e25135ad091b0bd2463b055be0f","modified":1513915027472},{"_id":"themes/magiclamp/.git/packed-refs","hash":"494bb87aee263fdce4f930d60d98283143fa40f2","modified":1513915027446},{"_id":"themes/magiclamp/languages/default.yml","hash":"513c22371c3085224c466c10c6b1dd2735877f04","modified":1513915027490},{"_id":"themes/magiclamp/languages/en.yml","hash":"513c22371c3085224c466c10c6b1dd2735877f04","modified":1513915027491},{"_id":"themes/magiclamp/languages/fr-FR.yml","hash":"694980cca651eca633fec7f63da6e69070a28669","modified":1513915027493},{"_id":"themes/magiclamp/languages/de.yml","hash":"3af67eda28640a99e17d06eec0c664e54e95fb2d","modified":1513915027488},{"_id":"themes/magiclamp/languages/ru.yml","hash":"be6821b00c20dfe15717415fca3b1a5d719f4014","modified":1513915027494},{"_id":"themes/magiclamp/languages/zh-Hans.yml","hash":"08ad091275789bbff17043c8c05a1f7355e6cc3d","modified":1513915027496},{"_id":"themes/magiclamp/languages/zh-hk.yml","hash":"a36d81d609bb0fbfb1ca5f264c6e1c0d95fb9fae","modified":1513915027497},{"_id":"themes/magiclamp/layout/_layout.swig","hash":"586085a6eeb7abf74d4d6595aa2c3033db104df9","modified":1513915027500},{"_id":"themes/magiclamp/languages/zh-tw.yml","hash":"9fd6f672e503c50d6cc004df178387fc10be62db","modified":1513915027498},{"_id":"themes/magiclamp/layout/archive.swig","hash":"40e899e690172d8dd19317b17ec7be94406f114f","modified":1513915027538},{"_id":"themes/magiclamp/layout/category.swig","hash":"c777432e1587826ccad5a4aa50309763a82df52b","modified":1513915027540},{"_id":"themes/magiclamp/layout/index.swig","hash":"836631665db2b37639028fbc3aaa0b96f059e45c","modified":1513915027541},{"_id":"themes/magiclamp/layout/page.swig","hash":"5ab0887049f9c8c72d01f3c4bbf3e3d80f23a1c0","modified":1513915027542},{"_id":"themes/magiclamp/layout/post.swig","hash":"d8e4ee5b81d39c1653e29753ffda60f4c1a503a2","modified":1513915027544},{"_id":"themes/magiclamp/layout/tag.swig","hash":"06417b0b050c66d816323b6178c9376ba2e58dd9","modified":1513915027545},{"_id":"themes/magiclamp/scripts/merge-configs.js","hash":"2a47a2eb10c4491beffa8c5dd2a04cdb493ee80c","modified":1513915027546},{"_id":"themes/magiclamp/test/.jshintrc","hash":"1dae9d1cf7df1ae6d5c5efd6cffb949e9b8dcebb","modified":1513915027627},{"_id":"themes/magiclamp/test/helpers.js","hash":"7e9e76cae6ef37cbfd43cb7c76a3170b4fa1c20f","modified":1513915027627},{"_id":"themes/magiclamp/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1513915027628},{"_id":"themes/magiclamp/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1513915007962},{"_id":"themes/magiclamp/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1513915007963},{"_id":"themes/magiclamp/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1513915007961},{"_id":"themes/magiclamp/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1513915007965},{"_id":"themes/magiclamp/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1513915007966},{"_id":"themes/magiclamp/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1513915007968},{"_id":"themes/magiclamp/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1513915007972},{"_id":"themes/magiclamp/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1513915007975},{"_id":"themes/magiclamp/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1513915007973},{"_id":"themes/magiclamp/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1513915007977},{"_id":"themes/magiclamp/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1513915007969},{"_id":"themes/magiclamp/.git/logs/HEAD","hash":"ca0160e4bf98240ca7c2954aefa75c55c57c9cae","modified":1513915027464},{"_id":"themes/magiclamp/layout/_macro/post-collapse.swig","hash":"1c50d5706f3621933b9f910c072d763323a5f7c1","modified":1513915027501},{"_id":"themes/magiclamp/layout/_macro/post.swig","hash":"28aaf5d750cc21cec2924bea27dcffc1489f6af5","modified":1513915027502},{"_id":"themes/magiclamp/layout/_macro/sidebar.swig","hash":"6e51bc5064479c29333f24c1a9282a27d45b3ede","modified":1513915027503},{"_id":"themes/magiclamp/layout/_partials/footer.swig","hash":"8f497d717921fe59f129b18c74051319e882e95b","modified":1513915027505},{"_id":"themes/magiclamp/layout/_partials/head.swig","hash":"2d6f5072a45076628f23e76af5da4eaeff0a72cc","modified":1513915027506},{"_id":"themes/magiclamp/layout/_partials/header.swig","hash":"a71cbac2b292400b177a0b8a54f2ac647989e22a","modified":1513915027507},{"_id":"themes/magiclamp/layout/_partials/old-browsers.swig","hash":"3c4d930d34c234725065173780a23673e1c574f5","modified":1513915027508},{"_id":"themes/magiclamp/layout/_partials/pagination.swig","hash":"591ed052c83d0091e299134c496818a9cdc85726","modified":1513915027509},{"_id":"themes/magiclamp/layout/_partials/search.swig","hash":"1b86eb85017599392071d1230171e900045f8e69","modified":1513915027510},{"_id":"themes/magiclamp/layout/_scripts/analytics.swig","hash":"dfe81af3057cfe934e6f81ee386e5867853ac0aa","modified":1513915027525},{"_id":"themes/magiclamp/layout/_scripts/bootstrap.scrollspy.swig","hash":"0aad8d447567b683108b274c841c536b2daa176d","modified":1513915027530},{"_id":"themes/magiclamp/layout/_scripts/fancy-box.swig","hash":"701dfc53d750635de2f08f08d072d6ceb83b636c","modified":1513915027533},{"_id":"themes/magiclamp/layout/_scripts/mathjax.swig","hash":"e113e497075ac8681c665a7831657901cfa4fb68","modified":1513915027535},{"_id":"themes/magiclamp/layout/_scripts/helpers.swig","hash":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1513915027534},{"_id":"themes/magiclamp/layout/_scripts/motion.swig","hash":"40439a4d4c8e8c2218da84ee1e586e11db9837be","modified":1513915027536},{"_id":"themes/magiclamp/scripts/tags/center-quote.js","hash":"f27aa2a0e6c1ea07b6f673f0f3fa8c33828fd665","modified":1513915027548},{"_id":"themes/magiclamp/scripts/tags/full-image.js","hash":"ce6e099110b247c1d704a989af143f560d5694ed","modified":1513915027549},{"_id":"themes/magiclamp/source/css/main.styl","hash":"24735fa47d75d5a08752b7235501b2234b0d43a6","modified":1513915027588},{"_id":"themes/magiclamp/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1513915027600},{"_id":"themes/magiclamp/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1513915027601},{"_id":"themes/magiclamp/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1513915027602},{"_id":"themes/magiclamp/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1513915027602},{"_id":"themes/magiclamp/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1513915027603},{"_id":"themes/magiclamp/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1513915027603},{"_id":"themes/magiclamp/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1513915027604},{"_id":"themes/magiclamp/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513915027604},{"_id":"themes/magiclamp/source/images/default_avatar.jpg","hash":"293c232c6a2dfb9f8b363227963473596b6ed9a3","modified":1513919008217},{"_id":"themes/magiclamp/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513915027605},{"_id":"themes/magiclamp/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1513915027605},{"_id":"themes/magiclamp/source/js/bootstrap.scrollspy.js","hash":"97640be11a524b203781c1a03f623ef0b9195a02","modified":1513915027606},{"_id":"themes/magiclamp/source/js/helpers.js","hash":"82ef268e5f7135682685a016734dae4861b06c8f","modified":1513915027607},{"_id":"themes/magiclamp/source/js/fancy-box.js","hash":"16349d338a2976769e612fbcfb7594f1c696c7ab","modified":1513915027606},{"_id":"themes/magiclamp/source/js/motion_fallback.js","hash":"bff3d62933345bb9bba962332b8c3d31f7b01579","modified":1513915027607},{"_id":"themes/magiclamp/source/js/lazyload.js","hash":"dd94f7e88df11a1d760ca9994e21a58c07974fb2","modified":1513915027607},{"_id":"themes/magiclamp/source/js/motion_global.js","hash":"05da2c70cde83df8d592f004cf3066eda94c2e2f","modified":1513915027608},{"_id":"themes/magiclamp/source/js/ua-parser.min.js","hash":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1513915027608},{"_id":"themes/magiclamp/source/js/nav-toggle.js","hash":"43c86778408a2c0c97c2f34838687d3dcb018ad4","modified":1513915027608},{"_id":"themes/magiclamp/source/css/_mixins/Mala.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513915027583},{"_id":"themes/magiclamp/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513915027583},{"_id":"themes/magiclamp/source/css/_mixins/default.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513915027584},{"_id":"themes/magiclamp/source/css/_variables/default.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513915027588},{"_id":"themes/magiclamp/.git/objects/pack/pack-880f377bd1429f798edb2b3a6633f4c39a1366d6.idx","hash":"25e3602036c192b510e5223989ecf188d4c70bd5","modified":1513915027087},{"_id":"themes/magiclamp/.git/refs/heads/magiclamp","hash":"ae7851b0836d0241149430d3a5090512b68f969c","modified":1513915027462},{"_id":"themes/magiclamp/layout/_partials/search/swiftype.swig","hash":"73e8294939bbbb46755798215c605ebe5af5918f","modified":1513915027513},{"_id":"themes/magiclamp/layout/_partials/search/tinysou.swig","hash":"bc96432f4230056e616741d4916916be6b8e1053","modified":1513915027514},{"_id":"themes/magiclamp/layout/_partials/share/baidu_share.swig","hash":"a03eff9fc007468b112441493a583b398ea48080","modified":1513915027515},{"_id":"themes/magiclamp/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1513915027516},{"_id":"themes/magiclamp/layout/_partials/suprise/assist.swig","hash":"be065ffaf6dbc4a30c7ef59e5575477c7932bd5f","modified":1513915027518},{"_id":"themes/magiclamp/layout/_partials/suprise/donate.swig","hash":"12d3bba81b8bee524747214a4b3361e51b0f6c6d","modified":1513915027523},{"_id":"themes/magiclamp/layout/_scripts/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1513915027526},{"_id":"themes/magiclamp/layout/_scripts/analytics/busuanzi.swig","hash":"ad8bba6d4142bfa8181765751245ada5aaf0e385","modified":1513915027528},{"_id":"themes/magiclamp/layout/_scripts/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1513915027529},{"_id":"themes/magiclamp/layout/_scripts/comments/disqus.swig","hash":"addaf37a20f550ddb896e8e1b05ca62be60a0d48","modified":1513915027532},{"_id":"themes/magiclamp/layout/_scripts/pages/post-details.swig","hash":"3ac70198258ab3c2bceca452864b68cc14a9debf","modified":1513915027537},{"_id":"themes/magiclamp/source/css/_custom/Mala.styl","hash":"9e46e488ea03a134e06400d543feb69c7a8459a9","modified":1513915027583},{"_id":"themes/magiclamp/source/css/_mixins/base.styl","hash":"c76b9e3ff7dec124ac1370ad185dce0e75dc1e03","modified":1513915027583},{"_id":"themes/magiclamp/source/css/_variables/Mala.styl","hash":"be4b6b3e5d3ad31a81032a133db25ed3e573808d","modified":1513915027587},{"_id":"themes/magiclamp/source/css/_variables/base.styl","hash":"d545586d72d34bf1006a3b711b6644b049169f4e","modified":1513915027588},{"_id":"themes/magiclamp/source/css/_variables/custom.styl","hash":"a37d5f293a2425ab7dc691ccaee062b82e4443cf","modified":1513915027588},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.eot","hash":"90763e97be18be78e65749075225cceeddc6fa8a","modified":1513915027589},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.svg","hash":"a2682f9b0a2647ec5cc35201ba37b0aceba86bcf","modified":1513915027590},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.woff","hash":"dbe0368f2a65d87b13234cfea29d9783892fc7a8","modified":1513915027591},{"_id":"themes/magiclamp/source/fonts/icon-default/icomoon.ttf","hash":"c093408e6030221cafc1f79d897f1fb5283c1178","modified":1513915027590},{"_id":"themes/magiclamp/source/fonts/icon-default/selection.json","hash":"f05d514de60469cb8b77ab6dd68335d3de980377","modified":1513915027591},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.eot","hash":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd","modified":1513915027592},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.svg","hash":"a701877262c33bd521204de4eaf842294a294ca7","modified":1513915027592},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.woff","hash":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5","modified":1513915027593},{"_id":"themes/magiclamp/source/fonts/icon-feather/icomoon.ttf","hash":"b2bbae4b613403cf61ad25037913378da1c07b8f","modified":1513915027592},{"_id":"themes/magiclamp/source/fonts/icon-feather/selection.json","hash":"9a69a90c394f690f96758e0b012d0f85fdbb5d31","modified":1513915027593},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.eot","hash":"da86ba5df72d1288de9e9633e5f528062dd427d5","modified":1513915027593},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.svg","hash":"021bab3a7cb80aaaead0aceeb23a324256470b22","modified":1513915027594},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.ttf","hash":"72fe82e1f3db52414eed706952d385af241cb196","modified":1513915027594},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/icomoon.woff","hash":"4de6a74f523dee33d95dde61caae5809f9a5d448","modified":1513915027595},{"_id":"themes/magiclamp/source/fonts/icon-fifty-shades/selection.json","hash":"bc7767511444b4bc79c7e986ccd8b0a38dcd1541","modified":1513915027595},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.eot","hash":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1513915027596},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.ttf","hash":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1513915027597},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.svg","hash":"51ca86690d0294529bb9a736984e7fa718d15933","modified":1513915027597},{"_id":"themes/magiclamp/source/fonts/icon-icomoon/icomoon.woff","hash":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1513915027597},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.eot","hash":"e2d7f040428a632f3c50bfa94083b759936effc2","modified":1513915027598},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.svg","hash":"85371b5563515a4f3eed0690653a0c35ee0b9d99","modified":1513915027598},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.woff","hash":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8","modified":1513915027599},{"_id":"themes/magiclamp/source/fonts/icon-linecons/selection.json","hash":"8fb52012770b4745b18b43850737585d24a689cf","modified":1513915027600},{"_id":"themes/magiclamp/source/fonts/icon-linecons/icomoon.ttf","hash":"078068206684e4f185b0187ad3cee16f54a287d7","modified":1513915027599},{"_id":"themes/magiclamp/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1513915027619},{"_id":"themes/magiclamp/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1513915027619},{"_id":"themes/magiclamp/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1513915027619},{"_id":"themes/magiclamp/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1513915027620},{"_id":"themes/magiclamp/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1513915027621},{"_id":"themes/magiclamp/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1513915027623},{"_id":"themes/magiclamp/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1513915027623},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1513915027626},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1513915027626},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1513915027626},{"_id":"themes/magiclamp/source/css/_common/_page/home.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513915027579},{"_id":"themes/magiclamp/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1513915027622},{"_id":"themes/magiclamp/.git/logs/refs/heads/magiclamp","hash":"ca0160e4bf98240ca7c2954aefa75c55c57c9cae","modified":1513915027467},{"_id":"themes/magiclamp/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1513915027454},{"_id":"themes/magiclamp/source/css/_common/_component/back-to-top.styl","hash":"dac21141c7893ab9de697a8183d3b3f4eb7f0a5a","modified":1513915027552},{"_id":"themes/magiclamp/source/css/_common/_component/buttons.styl","hash":"0a1730773478d843e123404ab4dae24d7cb0f2b7","modified":1513915027553},{"_id":"themes/magiclamp/source/css/_common/_component/comments.styl","hash":"7fea2fab5683d4af08e62ae4cb9e73c0c417e18f","modified":1513915027554},{"_id":"themes/magiclamp/source/css/_common/_component/duoshuo.styl","hash":"76e8e6f5200e5e6063be6643c1cf340a51af6619","modified":1513915027556},{"_id":"themes/magiclamp/source/css/_common/_component/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1513915027559},{"_id":"themes/magiclamp/source/css/_common/_component/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1513915027558},{"_id":"themes/magiclamp/source/css/_common/_component/gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1513915027557},{"_id":"themes/magiclamp/source/css/_common/_component/posts-collapse.styl","hash":"1d805b9ea9c7adc1ed3da9783d8af9b1c632134d","modified":1513915027560},{"_id":"themes/magiclamp/source/css/_common/_component/posts-type.styl","hash":"f28f00b2acb0df0343e77400bcc8246b40ac046c","modified":1513915027562},{"_id":"themes/magiclamp/source/css/_common/_component/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1513915027564},{"_id":"themes/magiclamp/source/css/_common/_fonts/icon-default.styl","hash":"c46d16429b85570347373fd11db8c222f6ff914e","modified":1513915027572},{"_id":"themes/magiclamp/source/css/_common/_component/posts-expand.styl","hash":"d19567ceec500afa027b07053c255c064b59a6a1","modified":1513915027561},{"_id":"themes/magiclamp/source/css/_common/_fonts/icon-feather.styl","hash":"7bdc92a55f2eee20b6b546e93e4566696b459b9d","modified":1513915027574},{"_id":"themes/magiclamp/source/css/_common/_fonts/icon-font.styl","hash":"692c01dcdc612c3e1e245cf93d0ace0a4e2aaf3f","modified":1513915027577},{"_id":"themes/magiclamp/source/css/_common/_fonts/icon-fifty-shades.styl","hash":"dbb0843ea5aa7c2ac2755a2d1ce60fa662f1b939","modified":1513915027576},{"_id":"themes/magiclamp/source/css/_common/_core/helpers.styl","hash":"05150387d08fdbd1b39be35f25afc23a72030a5a","modified":1513915027567},{"_id":"themes/magiclamp/source/css/_common/_fonts/icon-linecons.styl","hash":"a9f5260198225801eb5c16345a69a7e3cab904fe","modified":1513915027577},{"_id":"themes/magiclamp/source/css/_common/_core/base.styl","hash":"c575ac7f4d20e10d42cc5a106ad3fb060a5d58d4","modified":1513915027565},{"_id":"themes/magiclamp/source/css/_common/_core/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1513915027568},{"_id":"themes/magiclamp/source/css/_common/_core/tables.styl","hash":"d6c9ed8daa0f2caf754fe044b42e7700379a9f60","modified":1513915027571},{"_id":"themes/magiclamp/source/css/_common/_section/body.styl","hash":"6eaa5d9cb08ecfb2d377a475e541e41fbfe4c1b6","modified":1513915027580},{"_id":"themes/magiclamp/source/css/_common/_section/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1513915027580},{"_id":"themes/magiclamp/source/css/_common/_section/header.styl","hash":"3df7b27f7dab4d4c07852dfd59ed0d06b1ac845c","modified":1513915027580},{"_id":"themes/magiclamp/source/css/_common/_section/layout.styl","hash":"57ed294f100d94ebc05f48145e5060a78edb405f","modified":1513915027580},{"_id":"themes/magiclamp/source/css/_common/_section/media.styl","hash":"482784c04c0cd15a3f0d86444966fe306af7d13a","modified":1513915027581},{"_id":"themes/magiclamp/source/css/_common/_section/sidebar.styl","hash":"363237fa082249fdc4ded53f42aedc9cd609b6b8","modified":1513915027581},{"_id":"themes/magiclamp/source/css/_common/_core/scaffolding.styl","hash":"d9dfe81c431a9c6a0c5a8c61f4ce63a9ef318324","modified":1513915027569},{"_id":"themes/magiclamp/source/css/_common/_page/archive.styl","hash":"df9e5a418f6e54abe69c1ab84649be46fb0c51a6","modified":1513915027578},{"_id":"themes/magiclamp/source/css/_common/_page/post-detail.styl","hash":"70464ceb64c4239af590f99ef319747d3d1f100b","modified":1513915027579},{"_id":"themes/magiclamp/source/css/_common/_page/categories.styl","hash":"6c34f2cf9ad9b9b787007cfca522deeb6b1ae3b7","modified":1513915027578},{"_id":"themes/magiclamp/source/css/_schemes/Mala/index.styl","hash":"be70ef0eea8e72088d01233c49a464b3612a6ec5","modified":1513915027584},{"_id":"themes/magiclamp/source/css/_schemes/default/_menu.styl","hash":"dd667be3f5f24cebdc15d0262c7d397f23d751c5","modified":1513915027585},{"_id":"themes/magiclamp/source/css/_schemes/default/_search.styl","hash":"e315ee6f604c2bcc44a5ef9078f5ce420c153a4b","modified":1513915027585},{"_id":"themes/magiclamp/source/css/_schemes/default/index.styl","hash":"e1dcc89ecbd93f46aacd5d0da39f74c22eb52916","modified":1513915027586},{"_id":"themes/magiclamp/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513915027609},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513915027609},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513915027610},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513915027610},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513915027611},{"_id":"themes/magiclamp/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513915027612},{"_id":"themes/magiclamp/source/vendors/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1513915027616},{"_id":"themes/magiclamp/source/vendors/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1513915027617},{"_id":"themes/magiclamp/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1513915027618},{"_id":"themes/magiclamp/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1513915027620},{"_id":"themes/magiclamp/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1513915027621},{"_id":"themes/magiclamp/layout/_partials/suprise/ball.swig","hash":"d2619e2b2d53d96f04fd0493bc868c5d217d1bd4","modified":1513920580013},{"_id":"themes/magiclamp/.git/logs/refs/remotes/origin/HEAD","hash":"98483c5dc52c682d48a59bb4eb10a895b6bdaa57","modified":1513915027453},{"_id":"themes/magiclamp/source/vendors/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1513915027625},{"_id":"themes/magiclamp/source/css/_common/_vendor/highlight/theme.styl","hash":"9f0606d4d94ffa6bd77f91628507bba19133cf36","modified":1513915027582},{"_id":"themes/magiclamp/source/css/_common/_vendor/highlight/highlight.styl","hash":"041f397cadb400e70c3b4f638d105cb3b88f45b7","modified":1513915027582},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1513915027614},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513915027613},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1513915027614},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1513915027615},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1513915027615},{"_id":"themes/magiclamp/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1513915027616},{"_id":"themes/magiclamp/.git/objects/pack/pack-880f377bd1429f798edb2b3a6633f4c39a1366d6.pack","hash":"bcf8fec97ab12826140227b5da1ddf381d126286","modified":1513915027093},{"_id":"public/2017/12/21/Liquibase介绍与使用/index.html","hash":"dee4a5e8f04cab1ac92ac2b5f2271c86179801bf","modified":1513920701644},{"_id":"public/2017/12/21/Ansible模块/index.html","hash":"0d3838e91271c51aa628b592e1c41c8c3972e511","modified":1513919950625},{"_id":"public/2017/12/21/AbstractQueuedSynchronizer 源码分析（共享锁）/index.html","hash":"218befc852e227a6159ba52fb4d72022af6e42c8","modified":1513919950626},{"_id":"public/2017/12/21/CompletableFuture的使用/index.html","hash":"a0abd26ab79c3b40d5945ad6f600e4c2120175ef","modified":1513919950626},{"_id":"public/2017/12/21/Java动态代理与Cglib代理比较/index.html","hash":"00bb698c633090045092ed811b09cc17b5bcfbff","modified":1513919950626},{"_id":"public/2017/12/21/Ansible简介及思想/index.html","hash":"01599f0f10c61d07aeb6bd3dd208ee077bb839fb","modified":1513919950627},{"_id":"public/2017/12/21/25岁每天做什么对5年之后的你有益/index.html","hash":"09c812fd810599aae2e60f40a40f798eb8952177","modified":1513919950627},{"_id":"public/2017/12/21/Spring Boot开启https/index.html","hash":"701c5f8814b8185c342bfbc12e7d8d95ebb7ebb5","modified":1513919950627},{"_id":"public/2017/12/21/卓有成效的管理者/index.html","hash":"619bf2bcecdea4fedf679f48a42d55f2f0afdfe2","modified":1513919950627},{"_id":"public/2017/12/21/关于防御式编程的思考/index.html","hash":"112ec24624f20e0a0b48730a01d3267b1d4b0b46","modified":1513919950627},{"_id":"public/2017/12/21/单元测试思考/index.html","hash":"f9f04687e4a8b04918307db5ae1a958683d49e3f","modified":1513919950627},{"_id":"public/2017/12/21/使用Optional来减少null检查/index.html","hash":"037d6ac28d487ad924cd907d05155a5beb818c5d","modified":1513919950627},{"_id":"public/archives/index.html","hash":"34c8850368772e25198875a900863294f6f00885","modified":1513919950627},{"_id":"public/archives/2017/index.html","hash":"abe7caf96f37678e0548ba2f82c1d7aab2572d1f","modified":1513919950627},{"_id":"public/archives/2017/12/index.html","hash":"44abcbd9c4647f81e438b81fe9fb019a8ce66eb4","modified":1513919950627},{"_id":"public/index.html","hash":"3b1f1aac1f9a98d18ed77f01781cd93069bb44d2","modified":1513920701645},{"_id":"public/page/2/index.html","hash":"f1eb7d2bb92ddb81653770426d26bf4b4310eac5","modified":1513920701644},{"_id":"public/tags/Ansible/index.html","hash":"eb3d2ac0288a79e73fa1982b4532fd97a54fa933","modified":1513919950628},{"_id":"public/tags/模块/index.html","hash":"d251740be17121245a1fac89b49b122330761d3c","modified":1513919950628},{"_id":"public/tags/思考/index.html","hash":"00ebff58e21a4acc51205bd70ac6459fd470bb29","modified":1513919950628},{"_id":"public/tags/Java/index.html","hash":"d1eb80dacaf85b61c85c5fa41d248e116a2dd162","modified":1513919950628},{"_id":"public/tags/CompeletableFuture/index.html","hash":"a2dd2c80f94e99e252571c2657188fde961dcc30","modified":1513919950628},{"_id":"public/tags/Cglib/index.html","hash":"12a3f27822a11ce370ba4eeb3abd421140403fca","modified":1513919950628},{"_id":"public/tags/代理/index.html","hash":"7abe5852dc0acf601f0a31e6b0cd09c5369be4f4","modified":1513919950628},{"_id":"public/tags/设计哲学/index.html","hash":"be402fd17c71ff3b309c1ccc13a905d442bc3e9b","modified":1513919950628},{"_id":"public/tags/Liquibase/index.html","hash":"97ef0c8b87a39170c3a07b9fcaf5ac1c6a36a565","modified":1513919950628},{"_id":"public/tags/spring-boot/index.html","hash":"6f862580ea3587612a70f59b5d65623b9c7dcda9","modified":1513919950628},{"_id":"public/tags/Optional/index.html","hash":"dc4d5fa0c522491b904052e58549b55d05dc947d","modified":1513919950628},{"_id":"public/tags/卓有成效/index.html","hash":"c82e95b8ff7cf0cebb62337bdea7dff51683bd81","modified":1513919950628},{"_id":"public/tags/读书笔记/index.html","hash":"08007bbf979fb6ef1afece759809abdad51762ad","modified":1513919950628},{"_id":"public/tags/单元测试/index.html","hash":"435ef95175eda1cc525c973b47bc18525581c5eb","modified":1513919950628},{"_id":"public/tags/测试/index.html","hash":"288e6546713e6c956b607764655d0c1314517267","modified":1513919950629},{"_id":"public/categories/index.html","hash":"1d58be90de10b7774fda8f0b7e49533a415a7705","modified":1513920701644},{"_id":"public/tags/index.html","hash":"1b75a597629fa3ab3123a76005dd90d2b36a3044","modified":1513919950646},{"_id":"public/tags/防御式编程/index.html","hash":"342ab0f27b506f16ba74eb3045428d993d95775a","modified":1513919950646},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1513919950662},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1513919950662},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1513919950662},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1513919950663},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1513919950663},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1513919950663},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1513919950663},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513919950663},{"_id":"public/images/default_avatar.jpg","hash":"293c232c6a2dfb9f8b363227963473596b6ed9a3","modified":1513919950663},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513919950663},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1513919950663},{"_id":"public/fonts/icon-default/icomoon.eot","hash":"90763e97be18be78e65749075225cceeddc6fa8a","modified":1513919950664},{"_id":"public/fonts/icon-default/icomoon.svg","hash":"a2682f9b0a2647ec5cc35201ba37b0aceba86bcf","modified":1513919950664},{"_id":"public/fonts/icon-default/icomoon.woff","hash":"dbe0368f2a65d87b13234cfea29d9783892fc7a8","modified":1513919950664},{"_id":"public/fonts/icon-default/icomoon.ttf","hash":"c093408e6030221cafc1f79d897f1fb5283c1178","modified":1513919950664},{"_id":"public/fonts/icon-feather/icomoon.eot","hash":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd","modified":1513919950664},{"_id":"public/fonts/icon-feather/icomoon.svg","hash":"a701877262c33bd521204de4eaf842294a294ca7","modified":1513919950664},{"_id":"public/fonts/icon-feather/icomoon.woff","hash":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5","modified":1513919950664},{"_id":"public/fonts/icon-feather/icomoon.ttf","hash":"b2bbae4b613403cf61ad25037913378da1c07b8f","modified":1513919950664},{"_id":"public/fonts/icon-fifty-shades/icomoon.eot","hash":"da86ba5df72d1288de9e9633e5f528062dd427d5","modified":1513919950664},{"_id":"public/fonts/icon-fifty-shades/icomoon.ttf","hash":"72fe82e1f3db52414eed706952d385af241cb196","modified":1513919950664},{"_id":"public/fonts/icon-fifty-shades/icomoon.svg","hash":"021bab3a7cb80aaaead0aceeb23a324256470b22","modified":1513919950664},{"_id":"public/fonts/icon-fifty-shades/icomoon.woff","hash":"4de6a74f523dee33d95dde61caae5809f9a5d448","modified":1513919950664},{"_id":"public/fonts/icon-icomoon/icomoon.eot","hash":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1513919950664},{"_id":"public/fonts/icon-icomoon/icomoon.ttf","hash":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1513919950665},{"_id":"public/fonts/icon-icomoon/icomoon.woff","hash":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1513919950665},{"_id":"public/fonts/icon-icomoon/icomoon.svg","hash":"51ca86690d0294529bb9a736984e7fa718d15933","modified":1513919950665},{"_id":"public/fonts/icon-linecons/icomoon.eot","hash":"e2d7f040428a632f3c50bfa94083b759936effc2","modified":1513919950665},{"_id":"public/fonts/icon-linecons/icomoon.svg","hash":"85371b5563515a4f3eed0690653a0c35ee0b9d99","modified":1513919950665},{"_id":"public/fonts/icon-linecons/icomoon.woff","hash":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8","modified":1513919950665},{"_id":"public/fonts/icon-linecons/icomoon.ttf","hash":"078068206684e4f185b0187ad3cee16f54a287d7","modified":1513919950665},{"_id":"public/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1513919950665},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513919950666},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513919950666},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513919950666},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513919950666},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513919950666},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513919950666},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513919950666},{"_id":"public/js/bootstrap.scrollspy.js","hash":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1513919951354},{"_id":"public/js/helpers.js","hash":"7499b413242a2e75a9308444aade5b72a12cce7d","modified":1513919951354},{"_id":"public/js/fancy-box.js","hash":"b382ba746f4566682948ce92f2588ee940cd1755","modified":1513919951355},{"_id":"public/js/motion_fallback.js","hash":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1513919951355},{"_id":"public/js/motion_global.js","hash":"fea8cbb854601b7aee14e51079b3e3f80a1de261","modified":1513919951355},{"_id":"public/js/lazyload.js","hash":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1513919951355},{"_id":"public/js/ua-parser.min.js","hash":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1513919951355},{"_id":"public/js/nav-toggle.js","hash":"78b59f1beb12adea0d7f9bcf4377cb699963f220","modified":1513919951355},{"_id":"public/fonts/icon-default/selection.json","hash":"ff1b9b78eced4d0368d14cc192ac67a0dd498593","modified":1513919951355},{"_id":"public/fonts/icon-feather/selection.json","hash":"d95a90b0d541e48b049902090c0d008ad92b4115","modified":1513919951355},{"_id":"public/fonts/icon-fifty-shades/selection.json","hash":"e5a5042e8e516b1d30fa3b1206d2c74921cec72b","modified":1513919951355},{"_id":"public/fonts/icon-linecons/selection.json","hash":"68da6ea1b3ab9355d42694bf5745071cdefa4a65","modified":1513919951355},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1513919951355},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1513919951355},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1513919951355},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1513919951355},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1513919951355},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513919951355},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1513919951355},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1513919951355},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513919951355},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1513919951355},{"_id":"public/css/main.css","hash":"49dd3ff9c4dab611ed3e44f0874e43a827f76a7a","modified":1513919951355},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1513919951355},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1513919951356},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1513919951356},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1513919951356},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1513919951356},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1513919951356},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1513919951356},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1513919951357}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2017-12-22T05:18:13.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-12-22 13:18:13\ntype: \"categories\"\n---\n","updated":"2017-12-22T05:19:04.365Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjbhgukzd0001n8hxiflpmfhs","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-12-22T05:18:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-12-22 13:18:07\ntype: \"tags\"\n---\n","updated":"2017-12-22T05:18:35.705Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjbhgukzl0003n8hxq7l76jbu","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Ansible模块","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n尽量使用ansible的模块，我们平常的shell命令不具备幂等性，譬如说创建一个文件夹，如果文件夹存在的话，命令执行不成功ansible就直接报错终止了。\n\n使用ansible的模块可以指定系统的状态，在ansible执行完后只要系统达到指定的状态就可以了，文件夹如果存在就不做任何操作，不存在就创建，可以多次运行。\n\n<!--more-->\n\n## copy\n用途：文件拷贝\n选项：\nbackup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no\ncontent：用于替代\"src\",可以直接设定指定文件的值\ndest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录\ndirectory_mode：递归的设定目录的权限，默认为系统默认权限match\nforce：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes\nothers：所有的file模块里的选项都可以在这里使用\nsrc：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用\"/\"来结尾，则只复制目录里的内容，如果没有使用\"/\"来结尾，则包含目录在内的整个内容全部复制，类似于rsync。match\nfollow\tyes/no\t当拷贝的文件夹内有link存在的时候，那么拷贝过match去的也会有link\nforce\tyes/no\t默认为yes,会覆盖远程的内容不一样的文件（可能文件名一样）。如果是no，就不会拷贝文件，如果远程有这个文件\ngroup\t设定一个群组拥有拷贝到远程节点的文件权限\nmode  等同于chmod，参数可以为“u+rwx or u=rw,g=r,o=r”\nowner\t设定一个用户拥有拷贝到远程节点的文件权限\n\n\n示例：\n> \\- name: 拷贝不覆盖\n>  copy: src=/data/file dest=/data/file force=no\n\n> \\- name: 覆盖之前先备份一下\n>  copy: src=/data/file dest=/data/file backup=yes\n\n\n## file\n用途：设定文件属性\n可以用于创建文件夹，指定用户，指定权限等等\n\nmode 等同于chmod，数字的话前面必须加0\nowner 等同于chown，改变文件或文件夹所属用户\npath  文件路径（必须）\nrecurse  递归应用文件夹底下的文件\nsrc   链接的源文件，state只能为link\ndest 链接目的文件\nstate  可选项有file link directory hard touch absent \n\n示例：\n> \\- name:创建文件夹\n>  \\- file: path=/data/dir1 state=directory\n\n> \\- name 创建一个文件\n>  \\- file:\n> &nbsp;  &nbsp; path: /etc/foo.conf\n> &nbsp;  &nbsp; state: touch\n> &nbsp;  &nbsp;  mode: \"u+rw,g-wx,o-rwx\"\n\n> \\- name 创建多个\n> \\- file:\n> &nbsp;  &nbsp;     src: '/tmp/{{ item.src }}'\n> &nbsp;  &nbsp;     dest: '{{ item.dest }}'\n> &nbsp;  &nbsp;     state: link\n> &nbsp;  &nbsp;    with_items:\n> &nbsp;  &nbsp;  &nbsp;  &nbsp;    - { src: 'x', dest: 'y' }\n> &nbsp;  &nbsp;    &nbsp;  &nbsp;  - { src: 'z', dest: 'k' }\n\n\n## yum\n用途：安装软件包，包括rpm包\nps:不建议使用rpm -ivh来安装rpm包，这样脚本只能执行一次\n选项：\nname：安装的软件包名\nstate: 软件状态 安装present installed latest 移除 absent removed\n\n\n示例：\n> \\- name: Install package.\n> &nbsp;   yum:\n> &nbsp; &nbsp;      name: /tmp/package.rpm\n> &nbsp; &nbsp;      state: present\n \n >\\- name: remove the Apache package\n  > &nbsp;  yum:\n  >   &nbsp;  &nbsp;  name: httpd\n  >   &nbsp;  &nbsp;  state: absent\n\n\n## 最后\n\nansible提供了非常多的模块，可以参考官方文档来使用\n所有模块的地址：http://docs.ansible.com/ansible/latest/list_of_all_modules.html","source":"_posts/Ansible模块.md","raw":"---\ntitle: Ansible模块\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [Ansible, 模块]\n---\n\n\n尽量使用ansible的模块，我们平常的shell命令不具备幂等性，譬如说创建一个文件夹，如果文件夹存在的话，命令执行不成功ansible就直接报错终止了。\n\n使用ansible的模块可以指定系统的状态，在ansible执行完后只要系统达到指定的状态就可以了，文件夹如果存在就不做任何操作，不存在就创建，可以多次运行。\n\n<!--more-->\n\n## copy\n用途：文件拷贝\n选项：\nbackup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no\ncontent：用于替代\"src\",可以直接设定指定文件的值\ndest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录\ndirectory_mode：递归的设定目录的权限，默认为系统默认权限match\nforce：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes\nothers：所有的file模块里的选项都可以在这里使用\nsrc：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用\"/\"来结尾，则只复制目录里的内容，如果没有使用\"/\"来结尾，则包含目录在内的整个内容全部复制，类似于rsync。match\nfollow\tyes/no\t当拷贝的文件夹内有link存在的时候，那么拷贝过match去的也会有link\nforce\tyes/no\t默认为yes,会覆盖远程的内容不一样的文件（可能文件名一样）。如果是no，就不会拷贝文件，如果远程有这个文件\ngroup\t设定一个群组拥有拷贝到远程节点的文件权限\nmode  等同于chmod，参数可以为“u+rwx or u=rw,g=r,o=r”\nowner\t设定一个用户拥有拷贝到远程节点的文件权限\n\n\n示例：\n> \\- name: 拷贝不覆盖\n>  copy: src=/data/file dest=/data/file force=no\n\n> \\- name: 覆盖之前先备份一下\n>  copy: src=/data/file dest=/data/file backup=yes\n\n\n## file\n用途：设定文件属性\n可以用于创建文件夹，指定用户，指定权限等等\n\nmode 等同于chmod，数字的话前面必须加0\nowner 等同于chown，改变文件或文件夹所属用户\npath  文件路径（必须）\nrecurse  递归应用文件夹底下的文件\nsrc   链接的源文件，state只能为link\ndest 链接目的文件\nstate  可选项有file link directory hard touch absent \n\n示例：\n> \\- name:创建文件夹\n>  \\- file: path=/data/dir1 state=directory\n\n> \\- name 创建一个文件\n>  \\- file:\n> &nbsp;  &nbsp; path: /etc/foo.conf\n> &nbsp;  &nbsp; state: touch\n> &nbsp;  &nbsp;  mode: \"u+rw,g-wx,o-rwx\"\n\n> \\- name 创建多个\n> \\- file:\n> &nbsp;  &nbsp;     src: '/tmp/{{ item.src }}'\n> &nbsp;  &nbsp;     dest: '{{ item.dest }}'\n> &nbsp;  &nbsp;     state: link\n> &nbsp;  &nbsp;    with_items:\n> &nbsp;  &nbsp;  &nbsp;  &nbsp;    - { src: 'x', dest: 'y' }\n> &nbsp;  &nbsp;    &nbsp;  &nbsp;  - { src: 'z', dest: 'k' }\n\n\n## yum\n用途：安装软件包，包括rpm包\nps:不建议使用rpm -ivh来安装rpm包，这样脚本只能执行一次\n选项：\nname：安装的软件包名\nstate: 软件状态 安装present installed latest 移除 absent removed\n\n\n示例：\n> \\- name: Install package.\n> &nbsp;   yum:\n> &nbsp; &nbsp;      name: /tmp/package.rpm\n> &nbsp; &nbsp;      state: present\n \n >\\- name: remove the Apache package\n  > &nbsp;  yum:\n  >   &nbsp;  &nbsp;  name: httpd\n  >   &nbsp;  &nbsp;  state: absent\n\n\n## 最后\n\nansible提供了非常多的模块，可以参考官方文档来使用\n所有模块的地址：http://docs.ansible.com/ansible/latest/list_of_all_modules.html","slug":"Ansible模块","published":1,"updated":"2017-12-22T05:13:48.266Z","comments":1,"photos":[],"link":"","_id":"cjbhgukz40000n8hxoookptif","content":"<p>尽量使用ansible的模块，我们平常的shell命令不具备幂等性，譬如说创建一个文件夹，如果文件夹存在的话，命令执行不成功ansible就直接报错终止了。</p>\n<p>使用ansible的模块可以指定系统的状态，在ansible执行完后只要系统达到指定的状态就可以了，文件夹如果存在就不做任何操作，不存在就创建，可以多次运行。</p>\n<a id=\"more\"></a>\n<h2 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h2><p>用途：文件拷贝<br>选项：<br>backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no<br>content：用于替代”src”,可以直接设定指定文件的值<br>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录<br>directory_mode：递归的设定目录的权限，默认为系统默认权限match<br>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes<br>others：所有的file模块里的选项都可以在这里使用<br>src：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用”/“来结尾，则只复制目录里的内容，如果没有使用”/“来结尾，则包含目录在内的整个内容全部复制，类似于rsync。match<br>follow    yes/no    当拷贝的文件夹内有link存在的时候，那么拷贝过match去的也会有link<br>force    yes/no    默认为yes,会覆盖远程的内容不一样的文件（可能文件名一样）。如果是no，就不会拷贝文件，如果远程有这个文件<br>group    设定一个群组拥有拷贝到远程节点的文件权限<br>mode  等同于chmod，参数可以为“u+rwx or u=rw,g=r,o=r”<br>owner    设定一个用户拥有拷贝到远程节点的文件权限</p>\n<p>示例：</p>\n<blockquote>\n<p>- name: 拷贝不覆盖<br> copy: src=/data/file dest=/data/file force=no</p>\n<p>- name: 覆盖之前先备份一下<br> copy: src=/data/file dest=/data/file backup=yes</p>\n</blockquote>\n<h2 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file\"></a>file</h2><p>用途：设定文件属性<br>可以用于创建文件夹，指定用户，指定权限等等</p>\n<p>mode 等同于chmod，数字的话前面必须加0<br>owner 等同于chown，改变文件或文件夹所属用户<br>path  文件路径（必须）<br>recurse  递归应用文件夹底下的文件<br>src   链接的源文件，state只能为link<br>dest 链接目的文件<br>state  可选项有file link directory hard touch absent </p>\n<p>示例：</p>\n<blockquote>\n<p>- name:创建文件夹<br> - file: path=/data/dir1 state=directory</p>\n<p>- name 创建一个文件<br> - file:<br>&nbsp;  &nbsp; path: /etc/foo.conf<br>&nbsp;  &nbsp; state: touch<br>&nbsp;  &nbsp;  mode: “u+rw,g-wx,o-rwx”</p>\n<p>- name 创建多个<br>- file:<br>&nbsp;  &nbsp;     src: ‘/tmp/‘<br>&nbsp;  &nbsp;     dest: ‘‘<br>&nbsp;  &nbsp;     state: link<br>&nbsp;  &nbsp;    with_items:<br>&nbsp;  &nbsp;  &nbsp;  &nbsp;    - { src: ‘x’, dest: ‘y’ }<br>&nbsp;  &nbsp;    &nbsp;  &nbsp;  - { src: ‘z’, dest: ‘k’ }</p>\n</blockquote>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>用途：安装软件包，包括rpm包<br>ps:不建议使用rpm -ivh来安装rpm包，这样脚本只能执行一次<br>选项：<br>name：安装的软件包名<br>state: 软件状态 安装present installed latest 移除 absent removed</p>\n<p>示例：</p>\n<blockquote>\n<p>- name: Install package.<br>&nbsp;   yum:<br>&nbsp; &nbsp;      name: /tmp/package.rpm<br>&nbsp; &nbsp;      state: present</p>\n<p>- name: remove the Apache package<br>&nbsp;  yum:<br>  &nbsp;  &nbsp;  name: httpd<br>  &nbsp;  &nbsp;  state: absent</p>\n</blockquote>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>ansible提供了非常多的模块，可以参考官方文档来使用<br>所有模块的地址：<a href=\"http://docs.ansible.com/ansible/latest/list_of_all_modules.html\" target=\"_blank\" rel=\"noopener\">http://docs.ansible.com/ansible/latest/list_of_all_modules.html</a></p>\n","site":{"data":{}},"excerpt":"<p>尽量使用ansible的模块，我们平常的shell命令不具备幂等性，譬如说创建一个文件夹，如果文件夹存在的话，命令执行不成功ansible就直接报错终止了。</p>\n<p>使用ansible的模块可以指定系统的状态，在ansible执行完后只要系统达到指定的状态就可以了，文件夹如果存在就不做任何操作，不存在就创建，可以多次运行。</p>","more":"<h2 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h2><p>用途：文件拷贝<br>选项：<br>backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no<br>content：用于替代”src”,可以直接设定指定文件的值<br>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录<br>directory_mode：递归的设定目录的权限，默认为系统默认权限match<br>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes<br>others：所有的file模块里的选项都可以在这里使用<br>src：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用”/“来结尾，则只复制目录里的内容，如果没有使用”/“来结尾，则包含目录在内的整个内容全部复制，类似于rsync。match<br>follow    yes/no    当拷贝的文件夹内有link存在的时候，那么拷贝过match去的也会有link<br>force    yes/no    默认为yes,会覆盖远程的内容不一样的文件（可能文件名一样）。如果是no，就不会拷贝文件，如果远程有这个文件<br>group    设定一个群组拥有拷贝到远程节点的文件权限<br>mode  等同于chmod，参数可以为“u+rwx or u=rw,g=r,o=r”<br>owner    设定一个用户拥有拷贝到远程节点的文件权限</p>\n<p>示例：</p>\n<blockquote>\n<p>- name: 拷贝不覆盖<br> copy: src=/data/file dest=/data/file force=no</p>\n<p>- name: 覆盖之前先备份一下<br> copy: src=/data/file dest=/data/file backup=yes</p>\n</blockquote>\n<h2 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file\"></a>file</h2><p>用途：设定文件属性<br>可以用于创建文件夹，指定用户，指定权限等等</p>\n<p>mode 等同于chmod，数字的话前面必须加0<br>owner 等同于chown，改变文件或文件夹所属用户<br>path  文件路径（必须）<br>recurse  递归应用文件夹底下的文件<br>src   链接的源文件，state只能为link<br>dest 链接目的文件<br>state  可选项有file link directory hard touch absent </p>\n<p>示例：</p>\n<blockquote>\n<p>- name:创建文件夹<br> - file: path=/data/dir1 state=directory</p>\n<p>- name 创建一个文件<br> - file:<br>&nbsp;  &nbsp; path: /etc/foo.conf<br>&nbsp;  &nbsp; state: touch<br>&nbsp;  &nbsp;  mode: “u+rw,g-wx,o-rwx”</p>\n<p>- name 创建多个<br>- file:<br>&nbsp;  &nbsp;     src: ‘/tmp/‘<br>&nbsp;  &nbsp;     dest: ‘‘<br>&nbsp;  &nbsp;     state: link<br>&nbsp;  &nbsp;    with_items:<br>&nbsp;  &nbsp;  &nbsp;  &nbsp;    - { src: ‘x’, dest: ‘y’ }<br>&nbsp;  &nbsp;    &nbsp;  &nbsp;  - { src: ‘z’, dest: ‘k’ }</p>\n</blockquote>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>用途：安装软件包，包括rpm包<br>ps:不建议使用rpm -ivh来安装rpm包，这样脚本只能执行一次<br>选项：<br>name：安装的软件包名<br>state: 软件状态 安装present installed latest 移除 absent removed</p>\n<p>示例：</p>\n<blockquote>\n<p>- name: Install package.<br>&nbsp;   yum:<br>&nbsp; &nbsp;      name: /tmp/package.rpm<br>&nbsp; &nbsp;      state: present</p>\n<p>- name: remove the Apache package<br>&nbsp;  yum:<br>  &nbsp;  &nbsp;  name: httpd<br>  &nbsp;  &nbsp;  state: absent</p>\n</blockquote>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>ansible提供了非常多的模块，可以参考官方文档来使用<br>所有模块的地址：<a href=\"http://docs.ansible.com/ansible/latest/list_of_all_modules.html\" target=\"_blank\" rel=\"noopener\">http://docs.ansible.com/ansible/latest/list_of_all_modules.html</a></p>"},{"title":"25岁每天做什么对5年之后的你有益？","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n+ 每天花5分钟跟爸爸妈妈视频，随便聊聊每天的事情，工作，天气，吃的如何，同事同学的八卦。\n+ 每天花至少30分钟锻炼，哪怕只是下楼遛弯。每天专注自己的工作和学习，解决问题，以热情拥抱工作和学习。\n+ 每天收拾好自己的头发，换一身干净衣服再出门。每天认真洗脸，照顾好自己的皮肤。\n+ 学会做饭，不一定每天做，但是至少要有几个能拿得出手的菜。\n+ 控制所有娱乐的时间，当你感觉对某个娱乐项目要沉迷的时候，删了它。\n+ 学会控制语速，语气坚定有力，不来回来说车轱辘话。\n+ 早饭要认真吃，不惜成本，蛋白质、谷物、水果都要覆盖，每天都要（早饭是麦片拿冰牛奶一泡，七八颗颗草莓，一把樱桃，烤一颗土豆）。\n\n+ 找到一两件喜欢做的事情，从今日开始，每天持续地重复，重复，重复。\n+ 停下来想想自己想要干什么，往哪个方向走","source":"_posts/25岁每天做什么对5年之后的你有益.md","raw":"---\ntitle: 25岁每天做什么对5年之后的你有益？\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: 思考\n---\n\n+ 每天花5分钟跟爸爸妈妈视频，随便聊聊每天的事情，工作，天气，吃的如何，同事同学的八卦。\n+ 每天花至少30分钟锻炼，哪怕只是下楼遛弯。每天专注自己的工作和学习，解决问题，以热情拥抱工作和学习。\n+ 每天收拾好自己的头发，换一身干净衣服再出门。每天认真洗脸，照顾好自己的皮肤。\n+ 学会做饭，不一定每天做，但是至少要有几个能拿得出手的菜。\n+ 控制所有娱乐的时间，当你感觉对某个娱乐项目要沉迷的时候，删了它。\n+ 学会控制语速，语气坚定有力，不来回来说车轱辘话。\n+ 早饭要认真吃，不惜成本，蛋白质、谷物、水果都要覆盖，每天都要（早饭是麦片拿冰牛奶一泡，七八颗颗草莓，一把樱桃，烤一颗土豆）。\n\n+ 找到一两件喜欢做的事情，从今日开始，每天持续地重复，重复，重复。\n+ 停下来想想自己想要干什么，往哪个方向走","slug":"25岁每天做什么对5年之后的你有益","published":1,"updated":"2017-12-22T05:13:26.218Z","comments":1,"photos":[],"link":"","_id":"cjbhgukzi0002n8hxvva12syz","content":"<ul>\n<li>每天花5分钟跟爸爸妈妈视频，随便聊聊每天的事情，工作，天气，吃的如何，同事同学的八卦。</li>\n<li>每天花至少30分钟锻炼，哪怕只是下楼遛弯。每天专注自己的工作和学习，解决问题，以热情拥抱工作和学习。</li>\n<li>每天收拾好自己的头发，换一身干净衣服再出门。每天认真洗脸，照顾好自己的皮肤。</li>\n<li>学会做饭，不一定每天做，但是至少要有几个能拿得出手的菜。</li>\n<li>控制所有娱乐的时间，当你感觉对某个娱乐项目要沉迷的时候，删了它。</li>\n<li>学会控制语速，语气坚定有力，不来回来说车轱辘话。</li>\n<li><p>早饭要认真吃，不惜成本，蛋白质、谷物、水果都要覆盖，每天都要（早饭是麦片拿冰牛奶一泡，七八颗颗草莓，一把樱桃，烤一颗土豆）。</p>\n</li>\n<li><p>找到一两件喜欢做的事情，从今日开始，每天持续地重复，重复，重复。</p>\n</li>\n<li>停下来想想自己想要干什么，往哪个方向走</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>每天花5分钟跟爸爸妈妈视频，随便聊聊每天的事情，工作，天气，吃的如何，同事同学的八卦。</li>\n<li>每天花至少30分钟锻炼，哪怕只是下楼遛弯。每天专注自己的工作和学习，解决问题，以热情拥抱工作和学习。</li>\n<li>每天收拾好自己的头发，换一身干净衣服再出门。每天认真洗脸，照顾好自己的皮肤。</li>\n<li>学会做饭，不一定每天做，但是至少要有几个能拿得出手的菜。</li>\n<li>控制所有娱乐的时间，当你感觉对某个娱乐项目要沉迷的时候，删了它。</li>\n<li>学会控制语速，语气坚定有力，不来回来说车轱辘话。</li>\n<li><p>早饭要认真吃，不惜成本，蛋白质、谷物、水果都要覆盖，每天都要（早饭是麦片拿冰牛奶一泡，七八颗颗草莓，一把樱桃，烤一颗土豆）。</p>\n</li>\n<li><p>找到一两件喜欢做的事情，从今日开始，每天持续地重复，重复，重复。</p>\n</li>\n<li>停下来想想自己想要干什么，往哪个方向走</li>\n</ul>\n"},{"title":"AbstractQueuedSynchronizer 源码分析（共享锁）","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n# 源码看之前的问题\n- race condition如何避免？\n- 工作流程是怎么样的？\n- 使用什么方式实现的？\n\n<!--more-->\n\n# 使用到的其他类说明和资料\n## LockSupport 简要说明\n在AbstractQueuedSynchronizer中使用LockSupport类来实现线程的挂起和唤醒，对应方法分别我park和unpark，内部实现原理是代理给了unsafe包的park和unpark\n\n### 为何使用park和unpark\nThread中提供了suspend和resume两个方法，不过这两个方法有很重大的缺陷，就是在suspend之前调用了resume，resume操作时没有任何作用的，线程会一直挂起再也得不到运行，目前这两个方法已经不建议使用。\n\npark会阻塞线程直到unpark调用，但unpark操作不依赖于park，在调用park之前调用了unpark对线程一样有效(park之前检查unpark状态应该是)，而且多次调用unpark只对后面的一次park起作用。由于前面遗留的unpark操作影响，调用park后可能会立即返回。不过下一次park又会继续阻塞等待unpark。\n\n其次park还支持超时，获取锁时的超时策略就依赖于它。\n\n\n## Unsafe类相关说明\n在多线程环境下对一个值进行操作时需要保证原子性，lock类使用了Unsafe类中的compareAndSet等CAS方法来保证操作的原子性，在不成功的情况下会自旋重试\nUnsafe类是sun.misc包下的类，由于其安全策略，应用程序中写的类是无法使用这个类的，而且其中实现大部分都是native的，了解一下API功能，不影响阅读jdk源码就可以了\n\n## Doug Lea大神的paper\n地址：http://gee.cs.oswego.edu/dl/papers/aqs.pdf\n详细讲述了aqs的设计过程，上面的park与unpark就翻译自里面的一段。\n\n\n# AbstractQueuedSynchronizer 源码解析\nps：condition相关的先不涉及，单纯的看lock相关源码\nps2:单独看AQS很抽象，我们结合具体类来了解相关功能\nps3:要用多线程的思维去看，单线程思维看这个根本就看不明白\n\n## 重要的属性字段\n1. state\n  标识当前锁的状态，源码实现中一般标识锁数量，像在CountDownLatch中state标识latch的count，每当有线程countDown时，state就减一，ReentrantLock标识锁的重入次数，进入+1，释放-1\n2. head,tail\n  队列的头尾，下面会说明下队列\n\n## 内部类Node\nAbstractQueuedSynchronizer维护了一个FIFO的队列，每个队列节点就是一个Node，Node中维护了前后节点(pre,next)的信息，和每个节点的waitStatus以及节点的模式(共享还是独占)，在获取锁失败后就会加入到队列末尾，拥有锁的线程释放锁后会通知队列中的第一个节点。\n\nwaitStatus有几个状态和约定\n| 值 | 说明 |\n|:---:|:---:|\n| >0 | 无效状态，说明node不再竞争锁 |\n| <0 | 有效状态，node正在竞争锁 |\n| 1  | CANCELLED，被取消 |\n| 0  | 初始化状态，表示SYNC |\n| -1 | SIGNAL 表示后继节点需要被唤醒 |\n| -2 | CONDITION 表示线程在等待condition|\n| -3 | PROPAGATE 表示下一次acquireShared应该被无条件传播|\n\nmode：\n| 值 | 说明 |\n|:---:|:---:|\n|SHARED | 共享模式 |\n|EXCLUSIVE| 独占模式|\n\n## CountDownLatch 对AQS的使用\n我们从最简单的CountDownLatch来看一下AQS的共享模式的使用\n\n### demo以及CountDownLatch相关API\njdk中的demo\n```java\nclass Driver2 { // ...\n  void main() throws InterruptedException {\n    CountDownLatch doneSignal = new CountDownLatch(N);\n    Executor e = ...\n\n    for (int i = 0; i < N; ++i) // create and start threads\n      e.execute(new WorkerRunnable(doneSignal, i));\n\n    doneSignal.await();           // wait for all to finish\n  }\n}\n\nclass WorkerRunnable implements Runnable {\n  private final CountDownLatch doneSignal;\n  private final int i;\n  WorkerRunnable(CountDownLatch doneSignal, int i) {\n    this.doneSignal = doneSignal;\n    this.i = i;\n  }\n  public void run() {\n    try {\n      doWork(i);\n      doneSignal.countDown();\n    } catch (InterruptedException ex) {} // return;\n  }\n\n  void doWork() { ... }\n}\n```\nmain函数生成了N个任务放到线程池中异步执行，每个任务执行完毕后会countdown一下表明任务完成，主线程一直await到所有的任务执行完毕才会退出\n\n内部类Sync继承了AQS，重载了share相关的两个方法\n```java\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    Sync(int count) {\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n    /**\n      * 返回值>=0 表示获取锁成功，\n      * >0 表示需要向后传播 =0不向后传播\n      * <0 表示获取锁失败\n     */\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n```\n1.tryAcquireShared 当前状态等于0，获取成功，即所有线程准备完毕\n2.tryReleaseShared 释放锁时将state减一，里面用到了CAS来保证操作的原子性\n\nCountDownLatch相关方法：\n```java\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\npublic void countDown() {\n    sync.releaseShared(1);\n}\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n```\n全部都代理给了Sync类\n\n### countDown使用的releaseShared方法\ncountDown使用的releaseShared方法比较简单，先来看一下\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {    //1\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\nprivate void doReleaseShared() {\n    /*\n     * Ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  This proceeds in the usual\n     * way of trying to unparkSuccessor of head if it needs\n     * signal. But if it does not, status is set to PROPAGATE to\n     * ensure that upon release, propagation continues.\n     * Additionally, we must loop in case a new node is added\n     * while we are doing this. Also, unlike other uses of\n     * unparkSuccessor, we need to know if CAS to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))   //2\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))   //3\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed   //4\n            break;\n    }\n}\n```\n1.尝试释放共享锁，上面介绍了，就是state-1，成功后执行后续操作\n2.获取队列head，当waitStatus为SIGNAL，就将其设置为0，设置成功后唤醒后继节点，不成功继续自旋尝试\n3.head状态为0，将自身状态设置为propagate，这里ws为0，在后面可以看到其实是因为没有后续节点\n4.如果在此过程中head改变了，就再次循环检查。后面我们会看到在线程获取到了锁之后，也还会调用这个方法来通知后继节点，这样前驱通知后继，扩散到了整个队列中，使所有节点都接收到了唤醒通知\n\n\n### await使用的acquireSharedInterruptibly方法\n再来看一下await中的acquireSharedInterruptibly实现\n```java\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)               // 1\n        doAcquireSharedInterruptibly(arg);\n}\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.SHARED);     // 2\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();  // 3\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);   \n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&   // 4\n                parkAndCheckInterrupt())                   //5\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)                          // 6\n            cancelAcquire(node);\n    }\n}\n```\n1.尝试获取锁，获取成功直接返回，获取不成功进入doAcquireSharedInterruptibly\n2.将当前线程封装成node加入到队列中\n3.获得node的前驱节点，如果前驱节点为head节点，那么再次尝试获取锁，获取成功后将node设置为head节点，并向后传播\n4.在获取失败后检查状态是否需要挂起，如果是，就挂起并在唤醒后检查中断状态(唤醒后线程是从挂起的位置继续往下执行)\n5.失败将当前node置为取消，失败从代码看只有一种情况，就是被中断后抛出异常\n\n分步骤说明，不按上述顺序，见标号：\n2.加入到队列中addWaiter方法\n```java\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n先自己尝试一下加入队列，如果失败就进入enq方法入队，可以看到，队列初始化时放置了一个空节点作为头部，线程封装的node加入到了其后\n\n4.然后我们先看一下shouldParkAfterFailedAcquire，因为这个节点会改变waitStatus，对后面的propagate会有影响\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)      //1\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {              //2\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do {                    \n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);     \n        pred.next = node;\n    } else {                   //3\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n分三步\n1.前驱节点waitStatus为SIGNAL直接返回true，表示可以挂起\n2.waitStatus大于0表示前驱节点已经被取消或其他无效状态，将其清理出队列，然后返回false，doAcquireSharedInterruptibly会自旋一次\n3.这个else里waitStatus要么是初始化时的0，要么就是被其他线程设置成了propagate，将waitStatus设置为SIGNAL，然后返回false，doAcquireSharedInterruptibly会自旋一次\n\n可以看到每当有一个新线程进入等待队列时，都会把前一个节点的waitStatus变为SIGNAL,表示后继节点需要被通知唤醒，新入队的节点waitStatus为SYNC\n> head\n> head(-1)->node1(0)\n> head(-1)->node1(-1)->node2(0)\n\n\n\n3.将获取到锁的节点设置为head，并向后传播setHeadAndPropagate\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n    /*\n     * Try to signal next queued node if:\n     *   Propagation was indicated by caller,\n     *     or was recorded (as h.waitStatus either before\n     *     or after setHead) by a previous operation\n     *     (note: this uses sign-check of waitStatus because\n     *      PROPAGATE status may transition to SIGNAL.)\n     * and\n     *   The next node is waiting in shared mode,\n     *     or we don't know, because it appears null\n     *\n     * The conservatism in both of these checks may cause\n     * unnecessary wake-ups, but only when there are multiple\n     * racing acquires/releases, so most need signals now or soon\n     * anyway.\n     */\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n//头结点对应的线程已经获得了锁，\n//相当于于出队，这个节点已经不再竞争锁了\n//再竞争锁会再加入到队列中\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}\n```\npropagate(tryAcquireShared返回值) > 0 表示需要向后传播\nh == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0 或头结点为空或状态为有效\n\n通知后继节点doReleaseShared上面已经说过了。\n\n\n我们分几种情况讨论一下\n> 1. await直接获取到锁，也就是所有任务已经完成，那么直接返回，继续执行\n> 2. 任务没有完成，await获取锁失败，进入FIFO队列等待\n> > 2.1 任务完成后，调用doReleaseShared通知后继节点，将队列中的第一个node设置为head，并再次调用doReleaseShared\n> > 2.2 一直到队列末尾，所有节点获取到锁，通知完毕，所有线程获取到共享锁，继续执行","source":"_posts/AbstractQueuedSynchronizer 源码分析（共享锁）.md","raw":"---\ntitle: AbstractQueuedSynchronizer 源码分析（共享锁）\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [思考]\n---\n\n\n# 源码看之前的问题\n- race condition如何避免？\n- 工作流程是怎么样的？\n- 使用什么方式实现的？\n\n<!--more-->\n\n# 使用到的其他类说明和资料\n## LockSupport 简要说明\n在AbstractQueuedSynchronizer中使用LockSupport类来实现线程的挂起和唤醒，对应方法分别我park和unpark，内部实现原理是代理给了unsafe包的park和unpark\n\n### 为何使用park和unpark\nThread中提供了suspend和resume两个方法，不过这两个方法有很重大的缺陷，就是在suspend之前调用了resume，resume操作时没有任何作用的，线程会一直挂起再也得不到运行，目前这两个方法已经不建议使用。\n\npark会阻塞线程直到unpark调用，但unpark操作不依赖于park，在调用park之前调用了unpark对线程一样有效(park之前检查unpark状态应该是)，而且多次调用unpark只对后面的一次park起作用。由于前面遗留的unpark操作影响，调用park后可能会立即返回。不过下一次park又会继续阻塞等待unpark。\n\n其次park还支持超时，获取锁时的超时策略就依赖于它。\n\n\n## Unsafe类相关说明\n在多线程环境下对一个值进行操作时需要保证原子性，lock类使用了Unsafe类中的compareAndSet等CAS方法来保证操作的原子性，在不成功的情况下会自旋重试\nUnsafe类是sun.misc包下的类，由于其安全策略，应用程序中写的类是无法使用这个类的，而且其中实现大部分都是native的，了解一下API功能，不影响阅读jdk源码就可以了\n\n## Doug Lea大神的paper\n地址：http://gee.cs.oswego.edu/dl/papers/aqs.pdf\n详细讲述了aqs的设计过程，上面的park与unpark就翻译自里面的一段。\n\n\n# AbstractQueuedSynchronizer 源码解析\nps：condition相关的先不涉及，单纯的看lock相关源码\nps2:单独看AQS很抽象，我们结合具体类来了解相关功能\nps3:要用多线程的思维去看，单线程思维看这个根本就看不明白\n\n## 重要的属性字段\n1. state\n  标识当前锁的状态，源码实现中一般标识锁数量，像在CountDownLatch中state标识latch的count，每当有线程countDown时，state就减一，ReentrantLock标识锁的重入次数，进入+1，释放-1\n2. head,tail\n  队列的头尾，下面会说明下队列\n\n## 内部类Node\nAbstractQueuedSynchronizer维护了一个FIFO的队列，每个队列节点就是一个Node，Node中维护了前后节点(pre,next)的信息，和每个节点的waitStatus以及节点的模式(共享还是独占)，在获取锁失败后就会加入到队列末尾，拥有锁的线程释放锁后会通知队列中的第一个节点。\n\nwaitStatus有几个状态和约定\n| 值 | 说明 |\n|:---:|:---:|\n| >0 | 无效状态，说明node不再竞争锁 |\n| <0 | 有效状态，node正在竞争锁 |\n| 1  | CANCELLED，被取消 |\n| 0  | 初始化状态，表示SYNC |\n| -1 | SIGNAL 表示后继节点需要被唤醒 |\n| -2 | CONDITION 表示线程在等待condition|\n| -3 | PROPAGATE 表示下一次acquireShared应该被无条件传播|\n\nmode：\n| 值 | 说明 |\n|:---:|:---:|\n|SHARED | 共享模式 |\n|EXCLUSIVE| 独占模式|\n\n## CountDownLatch 对AQS的使用\n我们从最简单的CountDownLatch来看一下AQS的共享模式的使用\n\n### demo以及CountDownLatch相关API\njdk中的demo\n```java\nclass Driver2 { // ...\n  void main() throws InterruptedException {\n    CountDownLatch doneSignal = new CountDownLatch(N);\n    Executor e = ...\n\n    for (int i = 0; i < N; ++i) // create and start threads\n      e.execute(new WorkerRunnable(doneSignal, i));\n\n    doneSignal.await();           // wait for all to finish\n  }\n}\n\nclass WorkerRunnable implements Runnable {\n  private final CountDownLatch doneSignal;\n  private final int i;\n  WorkerRunnable(CountDownLatch doneSignal, int i) {\n    this.doneSignal = doneSignal;\n    this.i = i;\n  }\n  public void run() {\n    try {\n      doWork(i);\n      doneSignal.countDown();\n    } catch (InterruptedException ex) {} // return;\n  }\n\n  void doWork() { ... }\n}\n```\nmain函数生成了N个任务放到线程池中异步执行，每个任务执行完毕后会countdown一下表明任务完成，主线程一直await到所有的任务执行完毕才会退出\n\n内部类Sync继承了AQS，重载了share相关的两个方法\n```java\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    Sync(int count) {\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n    /**\n      * 返回值>=0 表示获取锁成功，\n      * >0 表示需要向后传播 =0不向后传播\n      * <0 表示获取锁失败\n     */\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n```\n1.tryAcquireShared 当前状态等于0，获取成功，即所有线程准备完毕\n2.tryReleaseShared 释放锁时将state减一，里面用到了CAS来保证操作的原子性\n\nCountDownLatch相关方法：\n```java\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\npublic void countDown() {\n    sync.releaseShared(1);\n}\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n```\n全部都代理给了Sync类\n\n### countDown使用的releaseShared方法\ncountDown使用的releaseShared方法比较简单，先来看一下\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {    //1\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\nprivate void doReleaseShared() {\n    /*\n     * Ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  This proceeds in the usual\n     * way of trying to unparkSuccessor of head if it needs\n     * signal. But if it does not, status is set to PROPAGATE to\n     * ensure that upon release, propagation continues.\n     * Additionally, we must loop in case a new node is added\n     * while we are doing this. Also, unlike other uses of\n     * unparkSuccessor, we need to know if CAS to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))   //2\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))   //3\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed   //4\n            break;\n    }\n}\n```\n1.尝试释放共享锁，上面介绍了，就是state-1，成功后执行后续操作\n2.获取队列head，当waitStatus为SIGNAL，就将其设置为0，设置成功后唤醒后继节点，不成功继续自旋尝试\n3.head状态为0，将自身状态设置为propagate，这里ws为0，在后面可以看到其实是因为没有后续节点\n4.如果在此过程中head改变了，就再次循环检查。后面我们会看到在线程获取到了锁之后，也还会调用这个方法来通知后继节点，这样前驱通知后继，扩散到了整个队列中，使所有节点都接收到了唤醒通知\n\n\n### await使用的acquireSharedInterruptibly方法\n再来看一下await中的acquireSharedInterruptibly实现\n```java\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)               // 1\n        doAcquireSharedInterruptibly(arg);\n}\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.SHARED);     // 2\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();  // 3\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);   \n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&   // 4\n                parkAndCheckInterrupt())                   //5\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)                          // 6\n            cancelAcquire(node);\n    }\n}\n```\n1.尝试获取锁，获取成功直接返回，获取不成功进入doAcquireSharedInterruptibly\n2.将当前线程封装成node加入到队列中\n3.获得node的前驱节点，如果前驱节点为head节点，那么再次尝试获取锁，获取成功后将node设置为head节点，并向后传播\n4.在获取失败后检查状态是否需要挂起，如果是，就挂起并在唤醒后检查中断状态(唤醒后线程是从挂起的位置继续往下执行)\n5.失败将当前node置为取消，失败从代码看只有一种情况，就是被中断后抛出异常\n\n分步骤说明，不按上述顺序，见标号：\n2.加入到队列中addWaiter方法\n```java\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n先自己尝试一下加入队列，如果失败就进入enq方法入队，可以看到，队列初始化时放置了一个空节点作为头部，线程封装的node加入到了其后\n\n4.然后我们先看一下shouldParkAfterFailedAcquire，因为这个节点会改变waitStatus，对后面的propagate会有影响\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)      //1\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {              //2\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do {                    \n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);     \n        pred.next = node;\n    } else {                   //3\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n分三步\n1.前驱节点waitStatus为SIGNAL直接返回true，表示可以挂起\n2.waitStatus大于0表示前驱节点已经被取消或其他无效状态，将其清理出队列，然后返回false，doAcquireSharedInterruptibly会自旋一次\n3.这个else里waitStatus要么是初始化时的0，要么就是被其他线程设置成了propagate，将waitStatus设置为SIGNAL，然后返回false，doAcquireSharedInterruptibly会自旋一次\n\n可以看到每当有一个新线程进入等待队列时，都会把前一个节点的waitStatus变为SIGNAL,表示后继节点需要被通知唤醒，新入队的节点waitStatus为SYNC\n> head\n> head(-1)->node1(0)\n> head(-1)->node1(-1)->node2(0)\n\n\n\n3.将获取到锁的节点设置为head，并向后传播setHeadAndPropagate\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n    /*\n     * Try to signal next queued node if:\n     *   Propagation was indicated by caller,\n     *     or was recorded (as h.waitStatus either before\n     *     or after setHead) by a previous operation\n     *     (note: this uses sign-check of waitStatus because\n     *      PROPAGATE status may transition to SIGNAL.)\n     * and\n     *   The next node is waiting in shared mode,\n     *     or we don't know, because it appears null\n     *\n     * The conservatism in both of these checks may cause\n     * unnecessary wake-ups, but only when there are multiple\n     * racing acquires/releases, so most need signals now or soon\n     * anyway.\n     */\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n//头结点对应的线程已经获得了锁，\n//相当于于出队，这个节点已经不再竞争锁了\n//再竞争锁会再加入到队列中\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}\n```\npropagate(tryAcquireShared返回值) > 0 表示需要向后传播\nh == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0 或头结点为空或状态为有效\n\n通知后继节点doReleaseShared上面已经说过了。\n\n\n我们分几种情况讨论一下\n> 1. await直接获取到锁，也就是所有任务已经完成，那么直接返回，继续执行\n> 2. 任务没有完成，await获取锁失败，进入FIFO队列等待\n> > 2.1 任务完成后，调用doReleaseShared通知后继节点，将队列中的第一个node设置为head，并再次调用doReleaseShared\n> > 2.2 一直到队列末尾，所有节点获取到锁，通知完毕，所有线程获取到共享锁，继续执行","slug":"AbstractQueuedSynchronizer 源码分析（共享锁）","published":1,"updated":"2017-12-22T05:13:22.603Z","comments":1,"photos":[],"link":"","_id":"cjbhgukzv0005n8hx29rx6yn8","content":"<h1 id=\"源码看之前的问题\"><a href=\"#源码看之前的问题\" class=\"headerlink\" title=\"源码看之前的问题\"></a>源码看之前的问题</h1><ul>\n<li>race condition如何避免？</li>\n<li>工作流程是怎么样的？</li>\n<li>使用什么方式实现的？</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"使用到的其他类说明和资料\"><a href=\"#使用到的其他类说明和资料\" class=\"headerlink\" title=\"使用到的其他类说明和资料\"></a>使用到的其他类说明和资料</h1><h2 id=\"LockSupport-简要说明\"><a href=\"#LockSupport-简要说明\" class=\"headerlink\" title=\"LockSupport 简要说明\"></a>LockSupport 简要说明</h2><p>在AbstractQueuedSynchronizer中使用LockSupport类来实现线程的挂起和唤醒，对应方法分别我park和unpark，内部实现原理是代理给了unsafe包的park和unpark</p>\n<h3 id=\"为何使用park和unpark\"><a href=\"#为何使用park和unpark\" class=\"headerlink\" title=\"为何使用park和unpark\"></a>为何使用park和unpark</h3><p>Thread中提供了suspend和resume两个方法，不过这两个方法有很重大的缺陷，就是在suspend之前调用了resume，resume操作时没有任何作用的，线程会一直挂起再也得不到运行，目前这两个方法已经不建议使用。</p>\n<p>park会阻塞线程直到unpark调用，但unpark操作不依赖于park，在调用park之前调用了unpark对线程一样有效(park之前检查unpark状态应该是)，而且多次调用unpark只对后面的一次park起作用。由于前面遗留的unpark操作影响，调用park后可能会立即返回。不过下一次park又会继续阻塞等待unpark。</p>\n<p>其次park还支持超时，获取锁时的超时策略就依赖于它。</p>\n<h2 id=\"Unsafe类相关说明\"><a href=\"#Unsafe类相关说明\" class=\"headerlink\" title=\"Unsafe类相关说明\"></a>Unsafe类相关说明</h2><p>在多线程环境下对一个值进行操作时需要保证原子性，lock类使用了Unsafe类中的compareAndSet等CAS方法来保证操作的原子性，在不成功的情况下会自旋重试<br>Unsafe类是sun.misc包下的类，由于其安全策略，应用程序中写的类是无法使用这个类的，而且其中实现大部分都是native的，了解一下API功能，不影响阅读jdk源码就可以了</p>\n<h2 id=\"Doug-Lea大神的paper\"><a href=\"#Doug-Lea大神的paper\" class=\"headerlink\" title=\"Doug Lea大神的paper\"></a>Doug Lea大神的paper</h2><p>地址：<a href=\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\" target=\"_blank\" rel=\"noopener\">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a><br>详细讲述了aqs的设计过程，上面的park与unpark就翻译自里面的一段。</p>\n<h1 id=\"AbstractQueuedSynchronizer-源码解析\"><a href=\"#AbstractQueuedSynchronizer-源码解析\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer 源码解析\"></a>AbstractQueuedSynchronizer 源码解析</h1><p>ps：condition相关的先不涉及，单纯的看lock相关源码<br>ps2:单独看AQS很抽象，我们结合具体类来了解相关功能<br>ps3:要用多线程的思维去看，单线程思维看这个根本就看不明白</p>\n<h2 id=\"重要的属性字段\"><a href=\"#重要的属性字段\" class=\"headerlink\" title=\"重要的属性字段\"></a>重要的属性字段</h2><ol>\n<li>state<br>标识当前锁的状态，源码实现中一般标识锁数量，像在CountDownLatch中state标识latch的count，每当有线程countDown时，state就减一，ReentrantLock标识锁的重入次数，进入+1，释放-1</li>\n<li>head,tail<br>队列的头尾，下面会说明下队列</li>\n</ol>\n<h2 id=\"内部类Node\"><a href=\"#内部类Node\" class=\"headerlink\" title=\"内部类Node\"></a>内部类Node</h2><p>AbstractQueuedSynchronizer维护了一个FIFO的队列，每个队列节点就是一个Node，Node中维护了前后节点(pre,next)的信息，和每个节点的waitStatus以及节点的模式(共享还是独占)，在获取锁失败后就会加入到队列末尾，拥有锁的线程释放锁后会通知队列中的第一个节点。</p>\n<p>waitStatus有几个状态和约定<br>| 值 | 说明 |<br>|:—:|:—:|<br>| &gt;0 | 无效状态，说明node不再竞争锁 |<br>| &lt;0 | 有效状态，node正在竞争锁 |<br>| 1  | CANCELLED，被取消 |<br>| 0  | 初始化状态，表示SYNC |<br>| -1 | SIGNAL 表示后继节点需要被唤醒 |<br>| -2 | CONDITION 表示线程在等待condition|<br>| -3 | PROPAGATE 表示下一次acquireShared应该被无条件传播|</p>\n<p>mode：<br>| 值 | 说明 |<br>|:—:|:—:|<br>|SHARED | 共享模式 |<br>|EXCLUSIVE| 独占模式|</p>\n<h2 id=\"CountDownLatch-对AQS的使用\"><a href=\"#CountDownLatch-对AQS的使用\" class=\"headerlink\" title=\"CountDownLatch 对AQS的使用\"></a>CountDownLatch 对AQS的使用</h2><p>我们从最简单的CountDownLatch来看一下AQS的共享模式的使用</p>\n<h3 id=\"demo以及CountDownLatch相关API\"><a href=\"#demo以及CountDownLatch相关API\" class=\"headerlink\" title=\"demo以及CountDownLatch相关API\"></a>demo以及CountDownLatch相关API</h3><p>jdk中的demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver2</span> </span>&#123; <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    CountDownLatch doneSignal = <span class=\"keyword\">new</span> CountDownLatch(N);</span><br><span class=\"line\">    Executor e = ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; ++i) <span class=\"comment\">// create and start threads</span></span><br><span class=\"line\">      e.execute(<span class=\"keyword\">new</span> WorkerRunnable(doneSignal, i));</span><br><span class=\"line\"></span><br><span class=\"line\">    doneSignal.await();           <span class=\"comment\">// wait for all to finish</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkerRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch doneSignal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  WorkerRunnable(CountDownLatch doneSignal, <span class=\"keyword\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.doneSignal = doneSignal;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.i = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      doWork(i);</span><br><span class=\"line\">      doneSignal.countDown();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;&#125; <span class=\"comment\">// return;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main函数生成了N个任务放到线程池中异步执行，每个任务执行完毕后会countdown一下表明任务完成，主线程一直await到所有的任务执行完毕才会退出</p>\n<p>内部类Sync继承了AQS，重载了share相关的两个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">4982264981922014374L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> count) &#123;</span><br><span class=\"line\">        setState(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 返回值&gt;=0 表示获取锁成功，</span></span><br><span class=\"line\"><span class=\"comment\">      * &gt;0 表示需要向后传播 =0不向后传播</span></span><br><span class=\"line\"><span class=\"comment\">      * &lt;0 表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.tryAcquireShared 当前状态等于0，获取成功，即所有线程准备完毕<br>2.tryReleaseShared 释放锁时将state减一，里面用到了CAS来保证操作的原子性</p>\n<p>CountDownLatch相关方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.tryAcquireSharedNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>全部都代理给了Sync类</p>\n<h3 id=\"countDown使用的releaseShared方法\"><a href=\"#countDown使用的releaseShared方法\" class=\"headerlink\" title=\"countDown使用的releaseShared方法\"></a>countDown使用的releaseShared方法</h3><p>countDown使用的releaseShared方法比较简单，先来看一下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;    <span class=\"comment\">//1</span></span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Ensure that a release propagates, even if there are other</span></span><br><span class=\"line\"><span class=\"comment\">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class=\"line\"><span class=\"comment\">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class=\"line\"><span class=\"comment\">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class=\"line\"><span class=\"comment\">     * ensure that upon release, propagation continues.</span></span><br><span class=\"line\"><span class=\"comment\">     * Additionally, we must loop in case a new node is added</span></span><br><span class=\"line\"><span class=\"comment\">     * while we are doing this. Also, unlike other uses of</span></span><br><span class=\"line\"><span class=\"comment\">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class=\"line\"><span class=\"comment\">     * fails, if so rechecking.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))   <span class=\"comment\">//2</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))   <span class=\"comment\">//3</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed   //4</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.尝试释放共享锁，上面介绍了，就是state-1，成功后执行后续操作<br>2.获取队列head，当waitStatus为SIGNAL，就将其设置为0，设置成功后唤醒后继节点，不成功继续自旋尝试<br>3.head状态为0，将自身状态设置为propagate，这里ws为0，在后面可以看到其实是因为没有后续节点<br>4.如果在此过程中head改变了，就再次循环检查。后面我们会看到在线程获取到了锁之后，也还会调用这个方法来通知后继节点，这样前驱通知后继，扩散到了整个队列中，使所有节点都接收到了唤醒通知</p>\n<h3 id=\"await使用的acquireSharedInterruptibly方法\"><a href=\"#await使用的acquireSharedInterruptibly方法\" class=\"headerlink\" title=\"await使用的acquireSharedInterruptibly方法\"></a>await使用的acquireSharedInterruptibly方法</h3><p>再来看一下await中的acquireSharedInterruptibly实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)               <span class=\"comment\">// 1</span></span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);     <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();  <span class=\"comment\">// 3</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);   </span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class=\"comment\">// 4</span></span><br><span class=\"line\">                parkAndCheckInterrupt())                   <span class=\"comment\">//5</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)                          <span class=\"comment\">// 6</span></span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.尝试获取锁，获取成功直接返回，获取不成功进入doAcquireSharedInterruptibly<br>2.将当前线程封装成node加入到队列中<br>3.获得node的前驱节点，如果前驱节点为head节点，那么再次尝试获取锁，获取成功后将node设置为head节点，并向后传播<br>4.在获取失败后检查状态是否需要挂起，如果是，就挂起并在唤醒后检查中断状态(唤醒后线程是从挂起的位置继续往下执行)<br>5.失败将当前node置为取消，失败从代码看只有一种情况，就是被中断后抛出异常</p>\n<p>分步骤说明，不按上述顺序，见标号：<br>2.加入到队列中addWaiter方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先自己尝试一下加入队列，如果失败就进入enq方法入队，可以看到，队列初始化时放置了一个空节点作为头部，线程封装的node加入到了其后</p>\n<p>4.然后我们先看一下shouldParkAfterFailedAcquire，因为这个节点会改变waitStatus，对后面的propagate会有影响<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)      <span class=\"comment\">//1</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;              <span class=\"comment\">//2</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;                    </span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);     </span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                   <span class=\"comment\">//3</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">         * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>分三步<br>1.前驱节点waitStatus为SIGNAL直接返回true，表示可以挂起<br>2.waitStatus大于0表示前驱节点已经被取消或其他无效状态，将其清理出队列，然后返回false，doAcquireSharedInterruptibly会自旋一次<br>3.这个else里waitStatus要么是初始化时的0，要么就是被其他线程设置成了propagate，将waitStatus设置为SIGNAL，然后返回false，doAcquireSharedInterruptibly会自旋一次</p>\n<p>可以看到每当有一个新线程进入等待队列时，都会把前一个节点的waitStatus变为SIGNAL,表示后继节点需要被通知唤醒，新入队的节点waitStatus为SYNC</p>\n<blockquote>\n<p>head<br>head(-1)-&gt;node1(0)<br>head(-1)-&gt;node1(-1)-&gt;node2(0)</p>\n</blockquote>\n<p>3.将获取到锁的节点设置为head，并向后传播setHeadAndPropagate<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHeadAndPropagate</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> propagate)</span> </span>&#123;</span><br><span class=\"line\">    Node h = head; <span class=\"comment\">// Record old head for check below</span></span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Try to signal next queued node if:</span></span><br><span class=\"line\"><span class=\"comment\">     *   Propagation was indicated by caller,</span></span><br><span class=\"line\"><span class=\"comment\">     *     or was recorded (as h.waitStatus either before</span></span><br><span class=\"line\"><span class=\"comment\">     *     or after setHead) by a previous operation</span></span><br><span class=\"line\"><span class=\"comment\">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class=\"line\"><span class=\"comment\">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class=\"line\"><span class=\"comment\">     * and</span></span><br><span class=\"line\"><span class=\"comment\">     *   The next node is waiting in shared mode,</span></span><br><span class=\"line\"><span class=\"comment\">     *     or we don't know, because it appears null</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * The conservatism in both of these checks may cause</span></span><br><span class=\"line\"><span class=\"comment\">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class=\"line\"><span class=\"comment\">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class=\"line\"><span class=\"comment\">     * anyway.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propagate &gt; <span class=\"number\">0</span> || h == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        (h = head) == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.isShared())</span><br><span class=\"line\">            doReleaseShared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//头结点对应的线程已经获得了锁，</span></span><br><span class=\"line\"><span class=\"comment\">//相当于于出队，这个节点已经不再竞争锁了</span></span><br><span class=\"line\"><span class=\"comment\">//再竞争锁会再加入到队列中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHead</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    node.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>propagate(tryAcquireShared返回值) &gt; 0 表示需要向后传播<br>h == null || h.waitStatus &lt; 0 ||<br>        (h = head) == null || h.waitStatus &lt; 0 或头结点为空或状态为有效</p>\n<p>通知后继节点doReleaseShared上面已经说过了。</p>\n<p>我们分几种情况讨论一下</p>\n<blockquote>\n<ol>\n<li>await直接获取到锁，也就是所有任务已经完成，那么直接返回，继续执行</li>\n<li>任务没有完成，await获取锁失败，进入FIFO队列等待<blockquote>\n<p>2.1 任务完成后，调用doReleaseShared通知后继节点，将队列中的第一个node设置为head，并再次调用doReleaseShared<br>2.2 一直到队列末尾，所有节点获取到锁，通知完毕，所有线程获取到共享锁，继续执行</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"源码看之前的问题\"><a href=\"#源码看之前的问题\" class=\"headerlink\" title=\"源码看之前的问题\"></a>源码看之前的问题</h1><ul>\n<li>race condition如何避免？</li>\n<li>工作流程是怎么样的？</li>\n<li>使用什么方式实现的？</li>\n</ul>","more":"<h1 id=\"使用到的其他类说明和资料\"><a href=\"#使用到的其他类说明和资料\" class=\"headerlink\" title=\"使用到的其他类说明和资料\"></a>使用到的其他类说明和资料</h1><h2 id=\"LockSupport-简要说明\"><a href=\"#LockSupport-简要说明\" class=\"headerlink\" title=\"LockSupport 简要说明\"></a>LockSupport 简要说明</h2><p>在AbstractQueuedSynchronizer中使用LockSupport类来实现线程的挂起和唤醒，对应方法分别我park和unpark，内部实现原理是代理给了unsafe包的park和unpark</p>\n<h3 id=\"为何使用park和unpark\"><a href=\"#为何使用park和unpark\" class=\"headerlink\" title=\"为何使用park和unpark\"></a>为何使用park和unpark</h3><p>Thread中提供了suspend和resume两个方法，不过这两个方法有很重大的缺陷，就是在suspend之前调用了resume，resume操作时没有任何作用的，线程会一直挂起再也得不到运行，目前这两个方法已经不建议使用。</p>\n<p>park会阻塞线程直到unpark调用，但unpark操作不依赖于park，在调用park之前调用了unpark对线程一样有效(park之前检查unpark状态应该是)，而且多次调用unpark只对后面的一次park起作用。由于前面遗留的unpark操作影响，调用park后可能会立即返回。不过下一次park又会继续阻塞等待unpark。</p>\n<p>其次park还支持超时，获取锁时的超时策略就依赖于它。</p>\n<h2 id=\"Unsafe类相关说明\"><a href=\"#Unsafe类相关说明\" class=\"headerlink\" title=\"Unsafe类相关说明\"></a>Unsafe类相关说明</h2><p>在多线程环境下对一个值进行操作时需要保证原子性，lock类使用了Unsafe类中的compareAndSet等CAS方法来保证操作的原子性，在不成功的情况下会自旋重试<br>Unsafe类是sun.misc包下的类，由于其安全策略，应用程序中写的类是无法使用这个类的，而且其中实现大部分都是native的，了解一下API功能，不影响阅读jdk源码就可以了</p>\n<h2 id=\"Doug-Lea大神的paper\"><a href=\"#Doug-Lea大神的paper\" class=\"headerlink\" title=\"Doug Lea大神的paper\"></a>Doug Lea大神的paper</h2><p>地址：<a href=\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\" target=\"_blank\" rel=\"noopener\">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a><br>详细讲述了aqs的设计过程，上面的park与unpark就翻译自里面的一段。</p>\n<h1 id=\"AbstractQueuedSynchronizer-源码解析\"><a href=\"#AbstractQueuedSynchronizer-源码解析\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer 源码解析\"></a>AbstractQueuedSynchronizer 源码解析</h1><p>ps：condition相关的先不涉及，单纯的看lock相关源码<br>ps2:单独看AQS很抽象，我们结合具体类来了解相关功能<br>ps3:要用多线程的思维去看，单线程思维看这个根本就看不明白</p>\n<h2 id=\"重要的属性字段\"><a href=\"#重要的属性字段\" class=\"headerlink\" title=\"重要的属性字段\"></a>重要的属性字段</h2><ol>\n<li>state<br>标识当前锁的状态，源码实现中一般标识锁数量，像在CountDownLatch中state标识latch的count，每当有线程countDown时，state就减一，ReentrantLock标识锁的重入次数，进入+1，释放-1</li>\n<li>head,tail<br>队列的头尾，下面会说明下队列</li>\n</ol>\n<h2 id=\"内部类Node\"><a href=\"#内部类Node\" class=\"headerlink\" title=\"内部类Node\"></a>内部类Node</h2><p>AbstractQueuedSynchronizer维护了一个FIFO的队列，每个队列节点就是一个Node，Node中维护了前后节点(pre,next)的信息，和每个节点的waitStatus以及节点的模式(共享还是独占)，在获取锁失败后就会加入到队列末尾，拥有锁的线程释放锁后会通知队列中的第一个节点。</p>\n<p>waitStatus有几个状态和约定<br>| 值 | 说明 |<br>|:—:|:—:|<br>| &gt;0 | 无效状态，说明node不再竞争锁 |<br>| &lt;0 | 有效状态，node正在竞争锁 |<br>| 1  | CANCELLED，被取消 |<br>| 0  | 初始化状态，表示SYNC |<br>| -1 | SIGNAL 表示后继节点需要被唤醒 |<br>| -2 | CONDITION 表示线程在等待condition|<br>| -3 | PROPAGATE 表示下一次acquireShared应该被无条件传播|</p>\n<p>mode：<br>| 值 | 说明 |<br>|:—:|:—:|<br>|SHARED | 共享模式 |<br>|EXCLUSIVE| 独占模式|</p>\n<h2 id=\"CountDownLatch-对AQS的使用\"><a href=\"#CountDownLatch-对AQS的使用\" class=\"headerlink\" title=\"CountDownLatch 对AQS的使用\"></a>CountDownLatch 对AQS的使用</h2><p>我们从最简单的CountDownLatch来看一下AQS的共享模式的使用</p>\n<h3 id=\"demo以及CountDownLatch相关API\"><a href=\"#demo以及CountDownLatch相关API\" class=\"headerlink\" title=\"demo以及CountDownLatch相关API\"></a>demo以及CountDownLatch相关API</h3><p>jdk中的demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver2</span> </span>&#123; <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    CountDownLatch doneSignal = <span class=\"keyword\">new</span> CountDownLatch(N);</span><br><span class=\"line\">    Executor e = ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; ++i) <span class=\"comment\">// create and start threads</span></span><br><span class=\"line\">      e.execute(<span class=\"keyword\">new</span> WorkerRunnable(doneSignal, i));</span><br><span class=\"line\"></span><br><span class=\"line\">    doneSignal.await();           <span class=\"comment\">// wait for all to finish</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkerRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch doneSignal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  WorkerRunnable(CountDownLatch doneSignal, <span class=\"keyword\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.doneSignal = doneSignal;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.i = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      doWork(i);</span><br><span class=\"line\">      doneSignal.countDown();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;&#125; <span class=\"comment\">// return;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main函数生成了N个任务放到线程池中异步执行，每个任务执行完毕后会countdown一下表明任务完成，主线程一直await到所有的任务执行完毕才会退出</p>\n<p>内部类Sync继承了AQS，重载了share相关的两个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">4982264981922014374L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> count) &#123;</span><br><span class=\"line\">        setState(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 返回值&gt;=0 表示获取锁成功，</span></span><br><span class=\"line\"><span class=\"comment\">      * &gt;0 表示需要向后传播 =0不向后传播</span></span><br><span class=\"line\"><span class=\"comment\">      * &lt;0 表示获取锁失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.tryAcquireShared 当前状态等于0，获取成功，即所有线程准备完毕<br>2.tryReleaseShared 释放锁时将state减一，里面用到了CAS来保证操作的原子性</p>\n<p>CountDownLatch相关方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.tryAcquireSharedNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>全部都代理给了Sync类</p>\n<h3 id=\"countDown使用的releaseShared方法\"><a href=\"#countDown使用的releaseShared方法\" class=\"headerlink\" title=\"countDown使用的releaseShared方法\"></a>countDown使用的releaseShared方法</h3><p>countDown使用的releaseShared方法比较简单，先来看一下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;    <span class=\"comment\">//1</span></span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Ensure that a release propagates, even if there are other</span></span><br><span class=\"line\"><span class=\"comment\">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class=\"line\"><span class=\"comment\">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class=\"line\"><span class=\"comment\">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class=\"line\"><span class=\"comment\">     * ensure that upon release, propagation continues.</span></span><br><span class=\"line\"><span class=\"comment\">     * Additionally, we must loop in case a new node is added</span></span><br><span class=\"line\"><span class=\"comment\">     * while we are doing this. Also, unlike other uses of</span></span><br><span class=\"line\"><span class=\"comment\">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class=\"line\"><span class=\"comment\">     * fails, if so rechecking.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))   <span class=\"comment\">//2</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))   <span class=\"comment\">//3</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed   //4</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.尝试释放共享锁，上面介绍了，就是state-1，成功后执行后续操作<br>2.获取队列head，当waitStatus为SIGNAL，就将其设置为0，设置成功后唤醒后继节点，不成功继续自旋尝试<br>3.head状态为0，将自身状态设置为propagate，这里ws为0，在后面可以看到其实是因为没有后续节点<br>4.如果在此过程中head改变了，就再次循环检查。后面我们会看到在线程获取到了锁之后，也还会调用这个方法来通知后继节点，这样前驱通知后继，扩散到了整个队列中，使所有节点都接收到了唤醒通知</p>\n<h3 id=\"await使用的acquireSharedInterruptibly方法\"><a href=\"#await使用的acquireSharedInterruptibly方法\" class=\"headerlink\" title=\"await使用的acquireSharedInterruptibly方法\"></a>await使用的acquireSharedInterruptibly方法</h3><p>再来看一下await中的acquireSharedInterruptibly实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)               <span class=\"comment\">// 1</span></span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);     <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();  <span class=\"comment\">// 3</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);   </span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class=\"comment\">// 4</span></span><br><span class=\"line\">                parkAndCheckInterrupt())                   <span class=\"comment\">//5</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)                          <span class=\"comment\">// 6</span></span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.尝试获取锁，获取成功直接返回，获取不成功进入doAcquireSharedInterruptibly<br>2.将当前线程封装成node加入到队列中<br>3.获得node的前驱节点，如果前驱节点为head节点，那么再次尝试获取锁，获取成功后将node设置为head节点，并向后传播<br>4.在获取失败后检查状态是否需要挂起，如果是，就挂起并在唤醒后检查中断状态(唤醒后线程是从挂起的位置继续往下执行)<br>5.失败将当前node置为取消，失败从代码看只有一种情况，就是被中断后抛出异常</p>\n<p>分步骤说明，不按上述顺序，见标号：<br>2.加入到队列中addWaiter方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先自己尝试一下加入队列，如果失败就进入enq方法入队，可以看到，队列初始化时放置了一个空节点作为头部，线程封装的node加入到了其后</p>\n<p>4.然后我们先看一下shouldParkAfterFailedAcquire，因为这个节点会改变waitStatus，对后面的propagate会有影响<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)      <span class=\"comment\">//1</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;              <span class=\"comment\">//2</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;                    </span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);     </span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                   <span class=\"comment\">//3</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">         * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>分三步<br>1.前驱节点waitStatus为SIGNAL直接返回true，表示可以挂起<br>2.waitStatus大于0表示前驱节点已经被取消或其他无效状态，将其清理出队列，然后返回false，doAcquireSharedInterruptibly会自旋一次<br>3.这个else里waitStatus要么是初始化时的0，要么就是被其他线程设置成了propagate，将waitStatus设置为SIGNAL，然后返回false，doAcquireSharedInterruptibly会自旋一次</p>\n<p>可以看到每当有一个新线程进入等待队列时，都会把前一个节点的waitStatus变为SIGNAL,表示后继节点需要被通知唤醒，新入队的节点waitStatus为SYNC</p>\n<blockquote>\n<p>head<br>head(-1)-&gt;node1(0)<br>head(-1)-&gt;node1(-1)-&gt;node2(0)</p>\n</blockquote>\n<p>3.将获取到锁的节点设置为head，并向后传播setHeadAndPropagate<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHeadAndPropagate</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> propagate)</span> </span>&#123;</span><br><span class=\"line\">    Node h = head; <span class=\"comment\">// Record old head for check below</span></span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Try to signal next queued node if:</span></span><br><span class=\"line\"><span class=\"comment\">     *   Propagation was indicated by caller,</span></span><br><span class=\"line\"><span class=\"comment\">     *     or was recorded (as h.waitStatus either before</span></span><br><span class=\"line\"><span class=\"comment\">     *     or after setHead) by a previous operation</span></span><br><span class=\"line\"><span class=\"comment\">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class=\"line\"><span class=\"comment\">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class=\"line\"><span class=\"comment\">     * and</span></span><br><span class=\"line\"><span class=\"comment\">     *   The next node is waiting in shared mode,</span></span><br><span class=\"line\"><span class=\"comment\">     *     or we don't know, because it appears null</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * The conservatism in both of these checks may cause</span></span><br><span class=\"line\"><span class=\"comment\">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class=\"line\"><span class=\"comment\">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class=\"line\"><span class=\"comment\">     * anyway.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propagate &gt; <span class=\"number\">0</span> || h == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        (h = head) == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.isShared())</span><br><span class=\"line\">            doReleaseShared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//头结点对应的线程已经获得了锁，</span></span><br><span class=\"line\"><span class=\"comment\">//相当于于出队，这个节点已经不再竞争锁了</span></span><br><span class=\"line\"><span class=\"comment\">//再竞争锁会再加入到队列中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHead</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    node.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>propagate(tryAcquireShared返回值) &gt; 0 表示需要向后传播<br>h == null || h.waitStatus &lt; 0 ||<br>        (h = head) == null || h.waitStatus &lt; 0 或头结点为空或状态为有效</p>\n<p>通知后继节点doReleaseShared上面已经说过了。</p>\n<p>我们分几种情况讨论一下</p>\n<blockquote>\n<ol>\n<li>await直接获取到锁，也就是所有任务已经完成，那么直接返回，继续执行</li>\n<li>任务没有完成，await获取锁失败，进入FIFO队列等待<blockquote>\n<p>2.1 任务完成后，调用doReleaseShared通知后继节点，将队列中的第一个node设置为head，并再次调用doReleaseShared<br>2.2 一直到队列末尾，所有节点获取到锁，通知完毕，所有线程获取到共享锁，继续执行</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>"},{"title":"CompeletableFuture的使用","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n## 例子\n\n我们就使用Java8 in action里面的商店的例子来说明。\n我们写了一个应用，这个应用需要通过互联网接口从其他的服务商那里取得价格，\n由于会有好多个服务商，因此我们先将操作封装到Shop类中。\n\n<!--more-->\n\n```java\npublic class Shop {\n    Random random = new Random();\n    String name;\n    public Shop(String name) {\n        this.name = name;\n    }\n    public double getPrice(String product) {\n        return caculatePrice(product);\n    }\n\n    // price既跟店铺name有关系，也跟product有关系\n    public double caculatePrice(String product) {\n        delay();\n        return random.nextDouble() * name.charAt(0) + product.charAt(1);\n    }\n    public static void delay() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n我们用 `delay` 来模拟耗时操作，每次从服务商那边获取价格有一个1s的延迟，可以看到如果串行获取多个服务商的价格的话，延迟会非常严重，对用户来说是不可接受的。\n\n### 以前的future方式\n\n我们可以将获取价格封装一个异步版本，返回`Future`，在需要的时候使用`get`方法来得到返回的价格\n\n```java\npublic Future<Double>  getPriceAsync(String product) {\n    CompletableFuture<Double> future = new CompletableFuture<>();\n    new Thread(()->{\n        double price = getPrice(product);\n        future.complete(price);\n    }).start();\n    return future;\n}\n```\n\n我们来测试一下异步版本的耗时：\n\n```java\npublic static void singleShop() throws ExecutionException, InterruptedException {\n    Shop shop = new Shop(\"\");\n    long current = System.currentTimeMillis();\n    Future<Double> future = shop.getPriceAsync(\"abc\");\n    long returned = System.currentTimeMillis();\n    System.out.println(\"返回使用了:\" + (returned - current) + \"msecs\");\n\n    double price = future.get();\n    long caculated = System.currentTimeMillis();\n    System.out.println(\"price is \" + price);\n    System.out.println(\"计算使用时间:\" + (caculated - current) + \"msecs\");\n}\n```\n\n测试结果：\n\n```java\n返回使用了:75msecs\nprice is 140.00108871644375\n计算使用时间:1077msecs\n```\n可以看到方法返回的速度是很快的，在返回后与得到值之间有很长的间隔，我们可以利用这段时间来做点别的。\n\n### CompletableFuture方式\n\nJava8提供了CompletableFuture，里面有`supplyAsync`方法可以让我们直接提交一个任务，返回`Future`\n可以看到代码精简到了一行。\n\n```java\npublic Future<Double> getPriceAsyncElegently(String product) {\n    return CompletableFuture.supplyAsync(() -> getPrice(product));\n}\n```\n\n看到这你可能会说了，不就是把操作封装了一下嘛，我自己也可以写一个方法，然后一行返回，别急，我们接着来看CompletableFuture提供给我们的其他功能，简直不要太顺手。\n\n### 与Stream结合使用\n\n上面说了会从很多的服务商那边获取价格，上面只是获取了一家，但假如是10家呢？我们就需要写10遍了，太繁琐，我们使用Stream来实现一下。\n\n先声明一下店铺,我直接复制了多个店铺：\n\n```java\nList<Shop> shopList = Arrays.asList(new Shop(\"a\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"c\"));\n```\n\n用CompletableFuture跟Stream结合来计算价格\n\n```java\npublic static List<Double> manyShopsFuture(String product) {\n    List<CompletableFuture<Double>> stream = shopList.stream()\n        .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product)))\n        .collect(Collectors.toList());\n\n    return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\n```\n\n在这里我们使用了2个stream来操作，因为如果把join操作写到第一个stream中的话，实际上操作已经变成了线性的了，所以这里我们先获取future，再统一join等待结果返回。\n\n\n不过还记得么，Stream类也提供了并行流，实现起来好像更加简单：\n\n```java\npublic static List<Double> manyShopsParallel(String product) {\n    return shopList.parallelStream().map(shop -> shop.getPrice(product)).collect(Collectors.toList());\n}\n```\n\n我们测试一下，比较下两者的运行效率:\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    String product = \"abc\";\n    long current = System.currentTimeMillis();\n    manyShopsParallel(product);\n    long future = System.currentTimeMillis();\n    System.out.println(\"manyShopsParallel cost:\" + (future - current));\n    manyShopsFuture(product);\n    long stream = System.currentTimeMillis();\n    System.out.println(\"manyShopsFuture cost:\" + (stream - future));\n}\n```\n执行结果\n\n> manyShopsParallel cost:3153\n> manyShopsFuture cost:4002\n \n可以看到使用ParallelStream更高效一些，写了这么多，效率却不如默认的好，那如何提高我们自己的程序的运行效率呢？\n\n### 提供自己的线程池\n\n其实CompletableFuture跟parallelStream一样，都是使用的`ForkJoinPool`中的默认线程池，线程数量默认为机器的内核数`Runtime.getRuntime().availableProcessors()`,对于我们这样的等待时间长，IO密集型的应用来说，CPU是大大的浪费了的，parallelStream是无法定制线程池的，但是CompletableFuture我们却可以自行提供，以便根据自己的应用情况作出调整。\n\n《Java并发编程实战》中给过一个计算线程池线程数的公式，为：\n> Nthreads = NCPU * UCPU * (1 + W/C)\n> 其中：\n> NCPU是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()得到\n> UCPU是期望的CPU利用率（该值应该介于0和1之间）\n> W/C是等待时间与计算时间的比率\n\n大家可以计算一下自己的，我这里Ncpu=2，Ucpu=100%，W/C = 1/0.01 = 100 ,因此取线程数=200来构造线程池\n如下：\n\n```java\nstatic Executor executor = Executors.newFixedThreadPool(200, new ThreadFactory() {\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread thread = new Thread(r);\n        thread.setDaemon(true);\n        return thread;\n    }\n});\n```\n\n```java\npublic static List<Double> manyShopsFuture(String product) {\n     List<CompletableFuture<Double>> stream = shopList.stream()\n         .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product),executor))\n         .collect(Collectors.toList());\n\n     return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\n```\n\n再次执行一下看计算时间：\n> manyShopsParallel cost:3250\n> manyShopsFuture cost:1006\n\nFuture方式可以说是完全并行了，而parallelStream由于使用默认线程池，并不能一次性全部将任务执行，需要更长的执行时间。\n\n## CompletableFuture组合异步任务\n\n假设我们在获取价格之后，还需要查询服务商的折扣服务才能计算最终展示的价格，这个延迟也会比较大，我们如何来组合这两个异步任务呢？CompletableFuture提供了一系列的then方法，我们这里使用两种来演示一下，一个是`thenApply`,一个是`thenCompose`, `thenApply`是对结果进行处理，`thenCompose`是组合一个新的任务\n\n先定义一下`Discount`\n```java\npublic class Discount {\n\n    public static Double applyDiscount(Double price) {\n        Double discount = getDiscount();\n        return price * discount;\n    }\n\n    public static Double getDiscount() {\n        Shop.delay();\n        return 0.5;\n    }\n}\n```\n\n然后看一下任务组合调用：\n\n```java\npublic static List<Double> manyShopsApplyWithDiscount(String product) {\n    List<CompletableFuture<Double>> stream = shopList.stream()\n        .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product),executor))\n        .map(future -> future.thenApply(Discount::applyDiscount))\n        .collect(Collectors.toList());\n\n    return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\npublic static List<Double> manyShopsComposeWithDiscount(String product) {\n    List<CompletableFuture<Double>> stream = shopList.stream()\n        .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product),executor))\n        .map(future -> future.thenCompose(price ->\n            CompletableFuture.supplyAsync(()-> Discount.applyDiscount(price),executor)))\n        .collect(Collectors.toList());\n\n    return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\n```\n\n在`thenCompose`中我们通过`supplyAsync` 再次提交了一次异步任务，而在`thenApply`中我们直接在原流水线上进行数据处理，不过不会阻塞流水线，也是提交了一个任务，不过是同步执行。这两个方法在我看来就是处理参数的不同而已，不用太过纠结。\n\n测试一下性能：\n\n> manyShopsComposeWithDiscount cost:2126\n> manyShopsApplyWithDiscount cost:2019\n\n`thenApply`方法由于减少了线程切换执行时间相对较短，也提醒我们在编程过程中注意这方面的开销。\n\n\n# 最后\n\nCompletableFuture还提供了很多其他的API可供我们使用，比如说`thenCombine`可以结合两个没有先后关系的异步任务，但是提供回调来处理两个任务的结果，等着大家去发现使用。","source":"_posts/CompletableFuture的使用.md","raw":"---\ntitle: CompeletableFuture的使用\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [Java, CompeletableFuture]\n---\n\n\n## 例子\n\n我们就使用Java8 in action里面的商店的例子来说明。\n我们写了一个应用，这个应用需要通过互联网接口从其他的服务商那里取得价格，\n由于会有好多个服务商，因此我们先将操作封装到Shop类中。\n\n<!--more-->\n\n```java\npublic class Shop {\n    Random random = new Random();\n    String name;\n    public Shop(String name) {\n        this.name = name;\n    }\n    public double getPrice(String product) {\n        return caculatePrice(product);\n    }\n\n    // price既跟店铺name有关系，也跟product有关系\n    public double caculatePrice(String product) {\n        delay();\n        return random.nextDouble() * name.charAt(0) + product.charAt(1);\n    }\n    public static void delay() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n我们用 `delay` 来模拟耗时操作，每次从服务商那边获取价格有一个1s的延迟，可以看到如果串行获取多个服务商的价格的话，延迟会非常严重，对用户来说是不可接受的。\n\n### 以前的future方式\n\n我们可以将获取价格封装一个异步版本，返回`Future`，在需要的时候使用`get`方法来得到返回的价格\n\n```java\npublic Future<Double>  getPriceAsync(String product) {\n    CompletableFuture<Double> future = new CompletableFuture<>();\n    new Thread(()->{\n        double price = getPrice(product);\n        future.complete(price);\n    }).start();\n    return future;\n}\n```\n\n我们来测试一下异步版本的耗时：\n\n```java\npublic static void singleShop() throws ExecutionException, InterruptedException {\n    Shop shop = new Shop(\"\");\n    long current = System.currentTimeMillis();\n    Future<Double> future = shop.getPriceAsync(\"abc\");\n    long returned = System.currentTimeMillis();\n    System.out.println(\"返回使用了:\" + (returned - current) + \"msecs\");\n\n    double price = future.get();\n    long caculated = System.currentTimeMillis();\n    System.out.println(\"price is \" + price);\n    System.out.println(\"计算使用时间:\" + (caculated - current) + \"msecs\");\n}\n```\n\n测试结果：\n\n```java\n返回使用了:75msecs\nprice is 140.00108871644375\n计算使用时间:1077msecs\n```\n可以看到方法返回的速度是很快的，在返回后与得到值之间有很长的间隔，我们可以利用这段时间来做点别的。\n\n### CompletableFuture方式\n\nJava8提供了CompletableFuture，里面有`supplyAsync`方法可以让我们直接提交一个任务，返回`Future`\n可以看到代码精简到了一行。\n\n```java\npublic Future<Double> getPriceAsyncElegently(String product) {\n    return CompletableFuture.supplyAsync(() -> getPrice(product));\n}\n```\n\n看到这你可能会说了，不就是把操作封装了一下嘛，我自己也可以写一个方法，然后一行返回，别急，我们接着来看CompletableFuture提供给我们的其他功能，简直不要太顺手。\n\n### 与Stream结合使用\n\n上面说了会从很多的服务商那边获取价格，上面只是获取了一家，但假如是10家呢？我们就需要写10遍了，太繁琐，我们使用Stream来实现一下。\n\n先声明一下店铺,我直接复制了多个店铺：\n\n```java\nList<Shop> shopList = Arrays.asList(new Shop(\"a\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"b\"),\n     new Shop(\"c\"));\n```\n\n用CompletableFuture跟Stream结合来计算价格\n\n```java\npublic static List<Double> manyShopsFuture(String product) {\n    List<CompletableFuture<Double>> stream = shopList.stream()\n        .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product)))\n        .collect(Collectors.toList());\n\n    return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\n```\n\n在这里我们使用了2个stream来操作，因为如果把join操作写到第一个stream中的话，实际上操作已经变成了线性的了，所以这里我们先获取future，再统一join等待结果返回。\n\n\n不过还记得么，Stream类也提供了并行流，实现起来好像更加简单：\n\n```java\npublic static List<Double> manyShopsParallel(String product) {\n    return shopList.parallelStream().map(shop -> shop.getPrice(product)).collect(Collectors.toList());\n}\n```\n\n我们测试一下，比较下两者的运行效率:\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    String product = \"abc\";\n    long current = System.currentTimeMillis();\n    manyShopsParallel(product);\n    long future = System.currentTimeMillis();\n    System.out.println(\"manyShopsParallel cost:\" + (future - current));\n    manyShopsFuture(product);\n    long stream = System.currentTimeMillis();\n    System.out.println(\"manyShopsFuture cost:\" + (stream - future));\n}\n```\n执行结果\n\n> manyShopsParallel cost:3153\n> manyShopsFuture cost:4002\n \n可以看到使用ParallelStream更高效一些，写了这么多，效率却不如默认的好，那如何提高我们自己的程序的运行效率呢？\n\n### 提供自己的线程池\n\n其实CompletableFuture跟parallelStream一样，都是使用的`ForkJoinPool`中的默认线程池，线程数量默认为机器的内核数`Runtime.getRuntime().availableProcessors()`,对于我们这样的等待时间长，IO密集型的应用来说，CPU是大大的浪费了的，parallelStream是无法定制线程池的，但是CompletableFuture我们却可以自行提供，以便根据自己的应用情况作出调整。\n\n《Java并发编程实战》中给过一个计算线程池线程数的公式，为：\n> Nthreads = NCPU * UCPU * (1 + W/C)\n> 其中：\n> NCPU是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()得到\n> UCPU是期望的CPU利用率（该值应该介于0和1之间）\n> W/C是等待时间与计算时间的比率\n\n大家可以计算一下自己的，我这里Ncpu=2，Ucpu=100%，W/C = 1/0.01 = 100 ,因此取线程数=200来构造线程池\n如下：\n\n```java\nstatic Executor executor = Executors.newFixedThreadPool(200, new ThreadFactory() {\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread thread = new Thread(r);\n        thread.setDaemon(true);\n        return thread;\n    }\n});\n```\n\n```java\npublic static List<Double> manyShopsFuture(String product) {\n     List<CompletableFuture<Double>> stream = shopList.stream()\n         .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product),executor))\n         .collect(Collectors.toList());\n\n     return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\n```\n\n再次执行一下看计算时间：\n> manyShopsParallel cost:3250\n> manyShopsFuture cost:1006\n\nFuture方式可以说是完全并行了，而parallelStream由于使用默认线程池，并不能一次性全部将任务执行，需要更长的执行时间。\n\n## CompletableFuture组合异步任务\n\n假设我们在获取价格之后，还需要查询服务商的折扣服务才能计算最终展示的价格，这个延迟也会比较大，我们如何来组合这两个异步任务呢？CompletableFuture提供了一系列的then方法，我们这里使用两种来演示一下，一个是`thenApply`,一个是`thenCompose`, `thenApply`是对结果进行处理，`thenCompose`是组合一个新的任务\n\n先定义一下`Discount`\n```java\npublic class Discount {\n\n    public static Double applyDiscount(Double price) {\n        Double discount = getDiscount();\n        return price * discount;\n    }\n\n    public static Double getDiscount() {\n        Shop.delay();\n        return 0.5;\n    }\n}\n```\n\n然后看一下任务组合调用：\n\n```java\npublic static List<Double> manyShopsApplyWithDiscount(String product) {\n    List<CompletableFuture<Double>> stream = shopList.stream()\n        .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product),executor))\n        .map(future -> future.thenApply(Discount::applyDiscount))\n        .collect(Collectors.toList());\n\n    return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\npublic static List<Double> manyShopsComposeWithDiscount(String product) {\n    List<CompletableFuture<Double>> stream = shopList.stream()\n        .map(s -> CompletableFuture.supplyAsync(() -> s.getPrice(product),executor))\n        .map(future -> future.thenCompose(price ->\n            CompletableFuture.supplyAsync(()-> Discount.applyDiscount(price),executor)))\n        .collect(Collectors.toList());\n\n    return stream.stream().map(CompletableFuture::join).collect(Collectors.toList());\n}\n```\n\n在`thenCompose`中我们通过`supplyAsync` 再次提交了一次异步任务，而在`thenApply`中我们直接在原流水线上进行数据处理，不过不会阻塞流水线，也是提交了一个任务，不过是同步执行。这两个方法在我看来就是处理参数的不同而已，不用太过纠结。\n\n测试一下性能：\n\n> manyShopsComposeWithDiscount cost:2126\n> manyShopsApplyWithDiscount cost:2019\n\n`thenApply`方法由于减少了线程切换执行时间相对较短，也提醒我们在编程过程中注意这方面的开销。\n\n\n# 最后\n\nCompletableFuture还提供了很多其他的API可供我们使用，比如说`thenCombine`可以结合两个没有先后关系的异步任务，但是提供回调来处理两个任务的结果，等着大家去发现使用。","slug":"CompletableFuture的使用","published":1,"updated":"2017-12-22T05:13:45.866Z","comments":1,"photos":[],"link":"","_id":"cjbhgukzz0006n8hxpf67s2mk","content":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>我们就使用Java8 in action里面的商店的例子来说明。<br>我们写了一个应用，这个应用需要通过互联网接口从其他的服务商那里取得价格，<br>由于会有好多个服务商，因此我们先将操作封装到Shop类中。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\">    Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Shop</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getPrice</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caculatePrice(product);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// price既跟店铺name有关系，也跟product有关系</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">caculatePrice</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">        delay();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.nextDouble() * name.charAt(<span class=\"number\">0</span>) + product.charAt(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">delay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用 <code>delay</code> 来模拟耗时操作，每次从服务商那边获取价格有一个1s的延迟，可以看到如果串行获取多个服务商的价格的话，延迟会非常严重，对用户来说是不可接受的。</p>\n<h3 id=\"以前的future方式\"><a href=\"#以前的future方式\" class=\"headerlink\" title=\"以前的future方式\"></a>以前的future方式</h3><p>我们可以将获取价格封装一个异步版本，返回<code>Future</code>，在需要的时候使用<code>get</code>方法来得到返回的价格</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;Double&gt;  <span class=\"title\">getPriceAsync</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    CompletableFuture&lt;Double&gt; future = <span class=\"keyword\">new</span> CompletableFuture&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> price = getPrice(product);</span><br><span class=\"line\">        future.complete(price);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来测试一下异步版本的耗时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">singleShop</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">    Shop shop = <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> current = System.currentTimeMillis();</span><br><span class=\"line\">    Future&lt;Double&gt; future = shop.getPriceAsync(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> returned = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"返回使用了:\"</span> + (returned - current) + <span class=\"string\">\"msecs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">double</span> price = future.get();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> caculated = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"price is \"</span> + price);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"计算使用时间:\"</span> + (caculated - current) + <span class=\"string\">\"msecs\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回使用了:<span class=\"number\">75</span>msecs</span><br><span class=\"line\">price is <span class=\"number\">140.00108871644375</span></span><br><span class=\"line\">计算使用时间:<span class=\"number\">1077</span>msecs</span><br></pre></td></tr></table></figure>\n<p>可以看到方法返回的速度是很快的，在返回后与得到值之间有很长的间隔，我们可以利用这段时间来做点别的。</p>\n<h3 id=\"CompletableFuture方式\"><a href=\"#CompletableFuture方式\" class=\"headerlink\" title=\"CompletableFuture方式\"></a>CompletableFuture方式</h3><p>Java8提供了CompletableFuture，里面有<code>supplyAsync</code>方法可以让我们直接提交一个任务，返回<code>Future</code><br>可以看到代码精简到了一行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;Double&gt; <span class=\"title\">getPriceAsyncElegently</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; getPrice(product));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这你可能会说了，不就是把操作封装了一下嘛，我自己也可以写一个方法，然后一行返回，别急，我们接着来看CompletableFuture提供给我们的其他功能，简直不要太顺手。</p>\n<h3 id=\"与Stream结合使用\"><a href=\"#与Stream结合使用\" class=\"headerlink\" title=\"与Stream结合使用\"></a>与Stream结合使用</h3><p>上面说了会从很多的服务商那边获取价格，上面只是获取了一家，但假如是10家呢？我们就需要写10遍了，太繁琐，我们使用Stream来实现一下。</p>\n<p>先声明一下店铺,我直接复制了多个店铺：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Shop&gt; shopList = Arrays.asList(<span class=\"keyword\">new</span> Shop(<span class=\"string\">\"a\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"c\"</span>));</span><br></pre></td></tr></table></figure>\n<p>用CompletableFuture跟Stream结合来计算价格</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsFuture</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">        .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product)))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里我们使用了2个stream来操作，因为如果把join操作写到第一个stream中的话，实际上操作已经变成了线性的了，所以这里我们先获取future，再统一join等待结果返回。</p>\n<p>不过还记得么，Stream类也提供了并行流，实现起来好像更加简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsParallel</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shopList.parallelStream().map(shop -&gt; shop.getPrice(product)).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们测试一下，比较下两者的运行效率:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">    String product = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> current = System.currentTimeMillis();</span><br><span class=\"line\">    manyShopsParallel(product);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> future = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"manyShopsParallel cost:\"</span> + (future - current));</span><br><span class=\"line\">    manyShopsFuture(product);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> stream = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"manyShopsFuture cost:\"</span> + (stream - future));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<blockquote>\n<p>manyShopsParallel cost:3153<br>manyShopsFuture cost:4002</p>\n</blockquote>\n<p>可以看到使用ParallelStream更高效一些，写了这么多，效率却不如默认的好，那如何提高我们自己的程序的运行效率呢？</p>\n<h3 id=\"提供自己的线程池\"><a href=\"#提供自己的线程池\" class=\"headerlink\" title=\"提供自己的线程池\"></a>提供自己的线程池</h3><p>其实CompletableFuture跟parallelStream一样，都是使用的<code>ForkJoinPool</code>中的默认线程池，线程数量默认为机器的内核数<code>Runtime.getRuntime().availableProcessors()</code>,对于我们这样的等待时间长，IO密集型的应用来说，CPU是大大的浪费了的，parallelStream是无法定制线程池的，但是CompletableFuture我们却可以自行提供，以便根据自己的应用情况作出调整。</p>\n<p>《Java并发编程实战》中给过一个计算线程池线程数的公式，为：</p>\n<blockquote>\n<p>Nthreads = NCPU <em> UCPU </em> (1 + W/C)<br>其中：<br>NCPU是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()得到<br>UCPU是期望的CPU利用率（该值应该介于0和1之间）<br>W/C是等待时间与计算时间的比率</p>\n</blockquote>\n<p>大家可以计算一下自己的，我这里Ncpu=2，Ucpu=100%，W/C = 1/0.01 = 100 ,因此取线程数=200来构造线程池<br>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Executor executor = Executors.newFixedThreadPool(<span class=\"number\">200</span>, <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsFuture</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">     List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">         .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product),executor))</span><br><span class=\"line\">         .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次执行一下看计算时间：</p>\n<blockquote>\n<p>manyShopsParallel cost:3250<br>manyShopsFuture cost:1006</p>\n</blockquote>\n<p>Future方式可以说是完全并行了，而parallelStream由于使用默认线程池，并不能一次性全部将任务执行，需要更长的执行时间。</p>\n<h2 id=\"CompletableFuture组合异步任务\"><a href=\"#CompletableFuture组合异步任务\" class=\"headerlink\" title=\"CompletableFuture组合异步任务\"></a>CompletableFuture组合异步任务</h2><p>假设我们在获取价格之后，还需要查询服务商的折扣服务才能计算最终展示的价格，这个延迟也会比较大，我们如何来组合这两个异步任务呢？CompletableFuture提供了一系列的then方法，我们这里使用两种来演示一下，一个是<code>thenApply</code>,一个是<code>thenCompose</code>, <code>thenApply</code>是对结果进行处理，<code>thenCompose</code>是组合一个新的任务</p>\n<p>先定义一下<code>Discount</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Discount</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Double <span class=\"title\">applyDiscount</span><span class=\"params\">(Double price)</span> </span>&#123;</span><br><span class=\"line\">        Double discount = getDiscount();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price * discount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Double <span class=\"title\">getDiscount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Shop.delay();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后看一下任务组合调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsApplyWithDiscount</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">        .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product),executor))</span><br><span class=\"line\">        .map(future -&gt; future.thenApply(Discount::applyDiscount))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsComposeWithDiscount</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">        .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product),executor))</span><br><span class=\"line\">        .map(future -&gt; future.thenCompose(price -&gt;</span><br><span class=\"line\">            CompletableFuture.supplyAsync(()-&gt; Discount.applyDiscount(price),executor)))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>thenCompose</code>中我们通过<code>supplyAsync</code> 再次提交了一次异步任务，而在<code>thenApply</code>中我们直接在原流水线上进行数据处理，不过不会阻塞流水线，也是提交了一个任务，不过是同步执行。这两个方法在我看来就是处理参数的不同而已，不用太过纠结。</p>\n<p>测试一下性能：</p>\n<blockquote>\n<p>manyShopsComposeWithDiscount cost:2126<br>manyShopsApplyWithDiscount cost:2019</p>\n</blockquote>\n<p><code>thenApply</code>方法由于减少了线程切换执行时间相对较短，也提醒我们在编程过程中注意这方面的开销。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>CompletableFuture还提供了很多其他的API可供我们使用，比如说<code>thenCombine</code>可以结合两个没有先后关系的异步任务，但是提供回调来处理两个任务的结果，等着大家去发现使用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>我们就使用Java8 in action里面的商店的例子来说明。<br>我们写了一个应用，这个应用需要通过互联网接口从其他的服务商那里取得价格，<br>由于会有好多个服务商，因此我们先将操作封装到Shop类中。</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\">    Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Shop</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getPrice</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caculatePrice(product);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// price既跟店铺name有关系，也跟product有关系</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">caculatePrice</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">        delay();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.nextDouble() * name.charAt(<span class=\"number\">0</span>) + product.charAt(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">delay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用 <code>delay</code> 来模拟耗时操作，每次从服务商那边获取价格有一个1s的延迟，可以看到如果串行获取多个服务商的价格的话，延迟会非常严重，对用户来说是不可接受的。</p>\n<h3 id=\"以前的future方式\"><a href=\"#以前的future方式\" class=\"headerlink\" title=\"以前的future方式\"></a>以前的future方式</h3><p>我们可以将获取价格封装一个异步版本，返回<code>Future</code>，在需要的时候使用<code>get</code>方法来得到返回的价格</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;Double&gt;  <span class=\"title\">getPriceAsync</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    CompletableFuture&lt;Double&gt; future = <span class=\"keyword\">new</span> CompletableFuture&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> price = getPrice(product);</span><br><span class=\"line\">        future.complete(price);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来测试一下异步版本的耗时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">singleShop</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">    Shop shop = <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> current = System.currentTimeMillis();</span><br><span class=\"line\">    Future&lt;Double&gt; future = shop.getPriceAsync(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> returned = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"返回使用了:\"</span> + (returned - current) + <span class=\"string\">\"msecs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">double</span> price = future.get();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> caculated = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"price is \"</span> + price);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"计算使用时间:\"</span> + (caculated - current) + <span class=\"string\">\"msecs\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回使用了:<span class=\"number\">75</span>msecs</span><br><span class=\"line\">price is <span class=\"number\">140.00108871644375</span></span><br><span class=\"line\">计算使用时间:<span class=\"number\">1077</span>msecs</span><br></pre></td></tr></table></figure>\n<p>可以看到方法返回的速度是很快的，在返回后与得到值之间有很长的间隔，我们可以利用这段时间来做点别的。</p>\n<h3 id=\"CompletableFuture方式\"><a href=\"#CompletableFuture方式\" class=\"headerlink\" title=\"CompletableFuture方式\"></a>CompletableFuture方式</h3><p>Java8提供了CompletableFuture，里面有<code>supplyAsync</code>方法可以让我们直接提交一个任务，返回<code>Future</code><br>可以看到代码精简到了一行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;Double&gt; <span class=\"title\">getPriceAsyncElegently</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; getPrice(product));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这你可能会说了，不就是把操作封装了一下嘛，我自己也可以写一个方法，然后一行返回，别急，我们接着来看CompletableFuture提供给我们的其他功能，简直不要太顺手。</p>\n<h3 id=\"与Stream结合使用\"><a href=\"#与Stream结合使用\" class=\"headerlink\" title=\"与Stream结合使用\"></a>与Stream结合使用</h3><p>上面说了会从很多的服务商那边获取价格，上面只是获取了一家，但假如是10家呢？我们就需要写10遍了，太繁琐，我们使用Stream来实现一下。</p>\n<p>先声明一下店铺,我直接复制了多个店铺：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Shop&gt; shopList = Arrays.asList(<span class=\"keyword\">new</span> Shop(<span class=\"string\">\"a\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"b\"</span>),</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Shop(<span class=\"string\">\"c\"</span>));</span><br></pre></td></tr></table></figure>\n<p>用CompletableFuture跟Stream结合来计算价格</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsFuture</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">        .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product)))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里我们使用了2个stream来操作，因为如果把join操作写到第一个stream中的话，实际上操作已经变成了线性的了，所以这里我们先获取future，再统一join等待结果返回。</p>\n<p>不过还记得么，Stream类也提供了并行流，实现起来好像更加简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsParallel</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shopList.parallelStream().map(shop -&gt; shop.getPrice(product)).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们测试一下，比较下两者的运行效率:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">    String product = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> current = System.currentTimeMillis();</span><br><span class=\"line\">    manyShopsParallel(product);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> future = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"manyShopsParallel cost:\"</span> + (future - current));</span><br><span class=\"line\">    manyShopsFuture(product);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> stream = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"manyShopsFuture cost:\"</span> + (stream - future));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<blockquote>\n<p>manyShopsParallel cost:3153<br>manyShopsFuture cost:4002</p>\n</blockquote>\n<p>可以看到使用ParallelStream更高效一些，写了这么多，效率却不如默认的好，那如何提高我们自己的程序的运行效率呢？</p>\n<h3 id=\"提供自己的线程池\"><a href=\"#提供自己的线程池\" class=\"headerlink\" title=\"提供自己的线程池\"></a>提供自己的线程池</h3><p>其实CompletableFuture跟parallelStream一样，都是使用的<code>ForkJoinPool</code>中的默认线程池，线程数量默认为机器的内核数<code>Runtime.getRuntime().availableProcessors()</code>,对于我们这样的等待时间长，IO密集型的应用来说，CPU是大大的浪费了的，parallelStream是无法定制线程池的，但是CompletableFuture我们却可以自行提供，以便根据自己的应用情况作出调整。</p>\n<p>《Java并发编程实战》中给过一个计算线程池线程数的公式，为：</p>\n<blockquote>\n<p>Nthreads = NCPU <em> UCPU </em> (1 + W/C)<br>其中：<br>NCPU是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()得到<br>UCPU是期望的CPU利用率（该值应该介于0和1之间）<br>W/C是等待时间与计算时间的比率</p>\n</blockquote>\n<p>大家可以计算一下自己的，我这里Ncpu=2，Ucpu=100%，W/C = 1/0.01 = 100 ,因此取线程数=200来构造线程池<br>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Executor executor = Executors.newFixedThreadPool(<span class=\"number\">200</span>, <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsFuture</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">     List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">         .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product),executor))</span><br><span class=\"line\">         .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次执行一下看计算时间：</p>\n<blockquote>\n<p>manyShopsParallel cost:3250<br>manyShopsFuture cost:1006</p>\n</blockquote>\n<p>Future方式可以说是完全并行了，而parallelStream由于使用默认线程池，并不能一次性全部将任务执行，需要更长的执行时间。</p>\n<h2 id=\"CompletableFuture组合异步任务\"><a href=\"#CompletableFuture组合异步任务\" class=\"headerlink\" title=\"CompletableFuture组合异步任务\"></a>CompletableFuture组合异步任务</h2><p>假设我们在获取价格之后，还需要查询服务商的折扣服务才能计算最终展示的价格，这个延迟也会比较大，我们如何来组合这两个异步任务呢？CompletableFuture提供了一系列的then方法，我们这里使用两种来演示一下，一个是<code>thenApply</code>,一个是<code>thenCompose</code>, <code>thenApply</code>是对结果进行处理，<code>thenCompose</code>是组合一个新的任务</p>\n<p>先定义一下<code>Discount</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Discount</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Double <span class=\"title\">applyDiscount</span><span class=\"params\">(Double price)</span> </span>&#123;</span><br><span class=\"line\">        Double discount = getDiscount();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price * discount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Double <span class=\"title\">getDiscount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Shop.delay();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后看一下任务组合调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsApplyWithDiscount</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">        .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product),executor))</span><br><span class=\"line\">        .map(future -&gt; future.thenApply(Discount::applyDiscount))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Double&gt; <span class=\"title\">manyShopsComposeWithDiscount</span><span class=\"params\">(String product)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;Double&gt;&gt; stream = shopList.stream()</span><br><span class=\"line\">        .map(s -&gt; CompletableFuture.supplyAsync(() -&gt; s.getPrice(product),executor))</span><br><span class=\"line\">        .map(future -&gt; future.thenCompose(price -&gt;</span><br><span class=\"line\">            CompletableFuture.supplyAsync(()-&gt; Discount.applyDiscount(price),executor)))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>thenCompose</code>中我们通过<code>supplyAsync</code> 再次提交了一次异步任务，而在<code>thenApply</code>中我们直接在原流水线上进行数据处理，不过不会阻塞流水线，也是提交了一个任务，不过是同步执行。这两个方法在我看来就是处理参数的不同而已，不用太过纠结。</p>\n<p>测试一下性能：</p>\n<blockquote>\n<p>manyShopsComposeWithDiscount cost:2126<br>manyShopsApplyWithDiscount cost:2019</p>\n</blockquote>\n<p><code>thenApply</code>方法由于减少了线程切换执行时间相对较短，也提醒我们在编程过程中注意这方面的开销。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>CompletableFuture还提供了很多其他的API可供我们使用，比如说<code>thenCombine</code>可以结合两个没有先后关系的异步任务，但是提供回调来处理两个任务的结果，等着大家去发现使用。</p>"},{"title":"Java动态代理与Cglib代理","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n最近又继续回来死磕Spring源码，以前看的也忘得差不多了，这次先把Spring使用的动态代理cglib看了一下，打好基础知识。\ncglib使用上特别简单，而且也不像Java要实现动态代理一样必须有接口，看一下cglib的wiki可以很容易上手。\n\n<!--more-->\n\n## 实现前的准备\n我们先准备测试用到的类和接口，简单的写一个test,假设是我们平常写的简单的dao\n```java\npublic interface TestDao {\n    public String test();\n}\n```\n\n然后写一个实现\n```java\npublic class TestDaoImpl implements TestDao {\n\n    public String test() {\n        System.out.println(\"test dao impl\");\n        return \"test\";\n    }\n}\n\n```\n\n里面就是简单的crud操作，现在如果我们需要对dao开启事务控制，我们当然可以直接在dao实现类中来做这个操作，不过对代码的侵入性很强，需要硬编码到Dao类中，而且重复代码会分布到每个类中。如果用代理来实现，那就会很优雅完美\n\n## Java动态代理的实现\n\n首先来定义代理要实现的功能\n```java\npublic class Aop implements InvocationHandler {\n    Object target;\n    public Aop(Object o){\n        this.target = o;\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"java dynamic before\");\n        Object re = method.invoke(target, args);\n        System.out.println(\"java dynamic after\");\n        return re;\n    }\n}\n```\n\n然后写一个生成代理类的工厂：\n```java\npublic class JavaDynamicObjectFactory {\n\n    public static <T> T getProxiedObject(Class clazz){\n\n        Aop aop = null;\n        try {\n            aop = new Aop(clazz.newInstance());\n            T proxied = (T) Proxy.newProxyInstance(JavaDynamicObjectFactory.class.getClassLoader(), clazz.getInterfaces(), aop);\n            return proxied;\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        TestDao testDao = JavaDynamicObjectFactory.getProxiedObject(TestDaoImpl.class);\n        testDao.test();\n    }\n}\n\n```\n测试后输出：\n> java dynamic before\n> test dao impl\n> java dynamic after\n\n## Cglib代理实现\n\ncglib也需要实现一个接口\n```java\npublic class Aop implements MethodInterceptor {\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"cglib before\");\n        Object re = methodProxy.invokeSuper(o, objects);\n        System.out.println(\"cglib after\");\n        return re;\n    }\n}\n```\n\n实现cglib工厂\n\n```java\npublic class CglibObjectFactory {\n\n    public static TestDao getTestService(){\n        return new TestDaoImpl();\n    }\n\n    public static <T> T getProxiedObject(Class clazz){\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(clazz);\n        enhancer.setCallback(new Aop());\n        T proxied = (T) enhancer.create();\n\n        return proxied;\n    }\n\n    public static void main(String[] args) {\n        TestDao testDao = CglibObjectFactory.getProxiedObject(TestDaoImpl.class);\n        testDao.test();\n    }\n}\n\n```\n\n执行后输出：\n> cglib before\n> test dao impl\n> cglib after\n\n当然cglib不仅仅这点功能，还提供了Bean generator ,Bean copier,Bean map等工具类功能，不过核心还是代码生成的\n\n## 总结对比\n\ncglib是直接操作字节码生成的代理类，底层依赖了ASM，Java的dynamic是在运行期增强，而且速度也一直受人诟病，平常如果有需要的话使用cglib还是很不错的，简单易上手。\n\n## 废话几句\n\n昨天在stackoverflow上看到一个关于代理框架的讨论，发现cglib有很多问题，很长时间没有更新，现在放到了GitHub上，然而更新解决问题依然很慢，不建议使用了。大家可以去尝试一下Javaassist，ASM等框架。ASM以前自己折腾过，不过看到后面全是byte code头晕，就放弃了，后面找机会再入坑\n\n\n## 参考资料\n\n[github上的cglib tutorial](https://github.com/cglib/cglib/wiki/Tutorial)\n[stackoverflow上的讨论Are there alternatives to cglib?](https://stackoverflow.com/questions/2261947/are-there-alternatives-to-cglib)","source":"_posts/Java动态代理与Cglib代理比较.md","raw":"---\ntitle: Java动态代理与Cglib代理\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [Ansible, Cglib, 代理]\n---\n\n最近又继续回来死磕Spring源码，以前看的也忘得差不多了，这次先把Spring使用的动态代理cglib看了一下，打好基础知识。\ncglib使用上特别简单，而且也不像Java要实现动态代理一样必须有接口，看一下cglib的wiki可以很容易上手。\n\n<!--more-->\n\n## 实现前的准备\n我们先准备测试用到的类和接口，简单的写一个test,假设是我们平常写的简单的dao\n```java\npublic interface TestDao {\n    public String test();\n}\n```\n\n然后写一个实现\n```java\npublic class TestDaoImpl implements TestDao {\n\n    public String test() {\n        System.out.println(\"test dao impl\");\n        return \"test\";\n    }\n}\n\n```\n\n里面就是简单的crud操作，现在如果我们需要对dao开启事务控制，我们当然可以直接在dao实现类中来做这个操作，不过对代码的侵入性很强，需要硬编码到Dao类中，而且重复代码会分布到每个类中。如果用代理来实现，那就会很优雅完美\n\n## Java动态代理的实现\n\n首先来定义代理要实现的功能\n```java\npublic class Aop implements InvocationHandler {\n    Object target;\n    public Aop(Object o){\n        this.target = o;\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"java dynamic before\");\n        Object re = method.invoke(target, args);\n        System.out.println(\"java dynamic after\");\n        return re;\n    }\n}\n```\n\n然后写一个生成代理类的工厂：\n```java\npublic class JavaDynamicObjectFactory {\n\n    public static <T> T getProxiedObject(Class clazz){\n\n        Aop aop = null;\n        try {\n            aop = new Aop(clazz.newInstance());\n            T proxied = (T) Proxy.newProxyInstance(JavaDynamicObjectFactory.class.getClassLoader(), clazz.getInterfaces(), aop);\n            return proxied;\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        TestDao testDao = JavaDynamicObjectFactory.getProxiedObject(TestDaoImpl.class);\n        testDao.test();\n    }\n}\n\n```\n测试后输出：\n> java dynamic before\n> test dao impl\n> java dynamic after\n\n## Cglib代理实现\n\ncglib也需要实现一个接口\n```java\npublic class Aop implements MethodInterceptor {\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"cglib before\");\n        Object re = methodProxy.invokeSuper(o, objects);\n        System.out.println(\"cglib after\");\n        return re;\n    }\n}\n```\n\n实现cglib工厂\n\n```java\npublic class CglibObjectFactory {\n\n    public static TestDao getTestService(){\n        return new TestDaoImpl();\n    }\n\n    public static <T> T getProxiedObject(Class clazz){\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(clazz);\n        enhancer.setCallback(new Aop());\n        T proxied = (T) enhancer.create();\n\n        return proxied;\n    }\n\n    public static void main(String[] args) {\n        TestDao testDao = CglibObjectFactory.getProxiedObject(TestDaoImpl.class);\n        testDao.test();\n    }\n}\n\n```\n\n执行后输出：\n> cglib before\n> test dao impl\n> cglib after\n\n当然cglib不仅仅这点功能，还提供了Bean generator ,Bean copier,Bean map等工具类功能，不过核心还是代码生成的\n\n## 总结对比\n\ncglib是直接操作字节码生成的代理类，底层依赖了ASM，Java的dynamic是在运行期增强，而且速度也一直受人诟病，平常如果有需要的话使用cglib还是很不错的，简单易上手。\n\n## 废话几句\n\n昨天在stackoverflow上看到一个关于代理框架的讨论，发现cglib有很多问题，很长时间没有更新，现在放到了GitHub上，然而更新解决问题依然很慢，不建议使用了。大家可以去尝试一下Javaassist，ASM等框架。ASM以前自己折腾过，不过看到后面全是byte code头晕，就放弃了，后面找机会再入坑\n\n\n## 参考资料\n\n[github上的cglib tutorial](https://github.com/cglib/cglib/wiki/Tutorial)\n[stackoverflow上的讨论Are there alternatives to cglib?](https://stackoverflow.com/questions/2261947/are-there-alternatives-to-cglib)","slug":"Java动态代理与Cglib代理比较","published":1,"updated":"2017-12-22T05:13:43.270Z","comments":1,"photos":[],"link":"","_id":"cjbhgul020007n8hxt84h4dnw","content":"<p>最近又继续回来死磕Spring源码，以前看的也忘得差不多了，这次先把Spring使用的动态代理cglib看了一下，打好基础知识。<br>cglib使用上特别简单，而且也不像Java要实现动态代理一样必须有接口，看一下cglib的wiki可以很容易上手。</p>\n<a id=\"more\"></a>\n<h2 id=\"实现前的准备\"><a href=\"#实现前的准备\" class=\"headerlink\" title=\"实现前的准备\"></a>实现前的准备</h2><p>我们先准备测试用到的类和接口，简单的写一个test,假设是我们平常写的简单的dao<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后写一个实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestDao</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"test dao impl\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>里面就是简单的crud操作，现在如果我们需要对dao开启事务控制，我们当然可以直接在dao实现类中来做这个操作，不过对代码的侵入性很强，需要硬编码到Dao类中，而且重复代码会分布到每个类中。如果用代理来实现，那就会很优雅完美</p>\n<h2 id=\"Java动态代理的实现\"><a href=\"#Java动态代理的实现\" class=\"headerlink\" title=\"Java动态代理的实现\"></a>Java动态代理的实现</h2><p>首先来定义代理要实现的功能<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aop</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    Object target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Aop</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"java dynamic before\"</span>);</span><br><span class=\"line\">        Object re = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"java dynamic after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后写一个生成代理类的工厂：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaDynamicObjectFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxiedObject</span><span class=\"params\">(Class clazz)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Aop aop = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            aop = <span class=\"keyword\">new</span> Aop(clazz.newInstance());</span><br><span class=\"line\">            T proxied = (T) Proxy.newProxyInstance(JavaDynamicObjectFactory.class.getClassLoader(), clazz.getInterfaces(), aop);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> proxied;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestDao testDao = JavaDynamicObjectFactory.getProxiedObject(TestDaoImpl.class);</span><br><span class=\"line\">        testDao.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试后输出：</p>\n<blockquote>\n<p>java dynamic before<br>test dao impl<br>java dynamic after</p>\n</blockquote>\n<h2 id=\"Cglib代理实现\"><a href=\"#Cglib代理实现\" class=\"headerlink\" title=\"Cglib代理实现\"></a>Cglib代理实现</h2><p>cglib也需要实现一个接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aop</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib before\"</span>);</span><br><span class=\"line\">        Object re = methodProxy.invokeSuper(o, objects);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现cglib工厂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibObjectFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TestDao <span class=\"title\">getTestService</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TestDaoImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxiedObject</span><span class=\"params\">(Class clazz)</span></span>&#123;</span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        enhancer.setSuperclass(clazz);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> Aop());</span><br><span class=\"line\">        T proxied = (T) enhancer.create();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxied;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestDao testDao = CglibObjectFactory.getProxiedObject(TestDaoImpl.class);</span><br><span class=\"line\">        testDao.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行后输出：</p>\n<blockquote>\n<p>cglib before<br>test dao impl<br>cglib after</p>\n</blockquote>\n<p>当然cglib不仅仅这点功能，还提供了Bean generator ,Bean copier,Bean map等工具类功能，不过核心还是代码生成的</p>\n<h2 id=\"总结对比\"><a href=\"#总结对比\" class=\"headerlink\" title=\"总结对比\"></a>总结对比</h2><p>cglib是直接操作字节码生成的代理类，底层依赖了ASM，Java的dynamic是在运行期增强，而且速度也一直受人诟病，平常如果有需要的话使用cglib还是很不错的，简单易上手。</p>\n<h2 id=\"废话几句\"><a href=\"#废话几句\" class=\"headerlink\" title=\"废话几句\"></a>废话几句</h2><p>昨天在stackoverflow上看到一个关于代理框架的讨论，发现cglib有很多问题，很长时间没有更新，现在放到了GitHub上，然而更新解决问题依然很慢，不建议使用了。大家可以去尝试一下Javaassist，ASM等框架。ASM以前自己折腾过，不过看到后面全是byte code头晕，就放弃了，后面找机会再入坑</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://github.com/cglib/cglib/wiki/Tutorial\" target=\"_blank\" rel=\"noopener\">github上的cglib tutorial</a><br><a href=\"https://stackoverflow.com/questions/2261947/are-there-alternatives-to-cglib\" target=\"_blank\" rel=\"noopener\">stackoverflow上的讨论Are there alternatives to cglib?</a></p>\n","site":{"data":{}},"excerpt":"<p>最近又继续回来死磕Spring源码，以前看的也忘得差不多了，这次先把Spring使用的动态代理cglib看了一下，打好基础知识。<br>cglib使用上特别简单，而且也不像Java要实现动态代理一样必须有接口，看一下cglib的wiki可以很容易上手。</p>","more":"<h2 id=\"实现前的准备\"><a href=\"#实现前的准备\" class=\"headerlink\" title=\"实现前的准备\"></a>实现前的准备</h2><p>我们先准备测试用到的类和接口，简单的写一个test,假设是我们平常写的简单的dao<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后写一个实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestDao</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"test dao impl\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>里面就是简单的crud操作，现在如果我们需要对dao开启事务控制，我们当然可以直接在dao实现类中来做这个操作，不过对代码的侵入性很强，需要硬编码到Dao类中，而且重复代码会分布到每个类中。如果用代理来实现，那就会很优雅完美</p>\n<h2 id=\"Java动态代理的实现\"><a href=\"#Java动态代理的实现\" class=\"headerlink\" title=\"Java动态代理的实现\"></a>Java动态代理的实现</h2><p>首先来定义代理要实现的功能<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aop</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    Object target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Aop</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"java dynamic before\"</span>);</span><br><span class=\"line\">        Object re = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"java dynamic after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后写一个生成代理类的工厂：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaDynamicObjectFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxiedObject</span><span class=\"params\">(Class clazz)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Aop aop = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            aop = <span class=\"keyword\">new</span> Aop(clazz.newInstance());</span><br><span class=\"line\">            T proxied = (T) Proxy.newProxyInstance(JavaDynamicObjectFactory.class.getClassLoader(), clazz.getInterfaces(), aop);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> proxied;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestDao testDao = JavaDynamicObjectFactory.getProxiedObject(TestDaoImpl.class);</span><br><span class=\"line\">        testDao.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试后输出：</p>\n<blockquote>\n<p>java dynamic before<br>test dao impl<br>java dynamic after</p>\n</blockquote>\n<h2 id=\"Cglib代理实现\"><a href=\"#Cglib代理实现\" class=\"headerlink\" title=\"Cglib代理实现\"></a>Cglib代理实现</h2><p>cglib也需要实现一个接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aop</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib before\"</span>);</span><br><span class=\"line\">        Object re = methodProxy.invokeSuper(o, objects);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现cglib工厂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibObjectFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TestDao <span class=\"title\">getTestService</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TestDaoImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxiedObject</span><span class=\"params\">(Class clazz)</span></span>&#123;</span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        enhancer.setSuperclass(clazz);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> Aop());</span><br><span class=\"line\">        T proxied = (T) enhancer.create();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxied;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestDao testDao = CglibObjectFactory.getProxiedObject(TestDaoImpl.class);</span><br><span class=\"line\">        testDao.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行后输出：</p>\n<blockquote>\n<p>cglib before<br>test dao impl<br>cglib after</p>\n</blockquote>\n<p>当然cglib不仅仅这点功能，还提供了Bean generator ,Bean copier,Bean map等工具类功能，不过核心还是代码生成的</p>\n<h2 id=\"总结对比\"><a href=\"#总结对比\" class=\"headerlink\" title=\"总结对比\"></a>总结对比</h2><p>cglib是直接操作字节码生成的代理类，底层依赖了ASM，Java的dynamic是在运行期增强，而且速度也一直受人诟病，平常如果有需要的话使用cglib还是很不错的，简单易上手。</p>\n<h2 id=\"废话几句\"><a href=\"#废话几句\" class=\"headerlink\" title=\"废话几句\"></a>废话几句</h2><p>昨天在stackoverflow上看到一个关于代理框架的讨论，发现cglib有很多问题，很长时间没有更新，现在放到了GitHub上，然而更新解决问题依然很慢，不建议使用了。大家可以去尝试一下Javaassist，ASM等框架。ASM以前自己折腾过，不过看到后面全是byte code头晕，就放弃了，后面找机会再入坑</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://github.com/cglib/cglib/wiki/Tutorial\" target=\"_blank\" rel=\"noopener\">github上的cglib tutorial</a><br><a href=\"https://stackoverflow.com/questions/2261947/are-there-alternatives-to-cglib\" target=\"_blank\" rel=\"noopener\">stackoverflow上的讨论Are there alternatives to cglib?</a></p>"},{"title":"Ansible简介及思想","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n## ansible是什么\n\n如果我们Google一下ansible，第一条出来的就是ansible的官网，它的title是“Ansible is Simple IT Automation”，从这里我们就能了解了ansible的目标：自动化。什么的自动化呢，其实是部署自动化(infrastructure as code)，将你原先一步一步使用命令转变为通过一系列的`状态检查`来安装一个软件，可以实现批量部署，一键部署。\n\n## 为什么用ansible\n\nansible有很多的优势，我觉得最重要的就是简单。ansible无需你安装客户端，只需要在一台机器上安装好ansible，配置好ssh，就可以使用了。语法也很简单，使用一系列的task来指定要做的任务，yaml格式提供了很好的缩进，一目了然。\n\n<!--more-->\n\n## 如何使用ansible\n\nansible使用只需3步\n- 控制机安装ansible，可以使用pip，yum或源码安装\n- 在目标机上加入控制机的ssh pub key，在控制机上都ssh一下，将目标机加入到known-hosts中去\n- 直接执行ansible命令或编写剧本来执行\n\nansible需要使用Python相关库，如果没有安装的话还需要安装，并且需要libselinux-python库（yum安装即可）。\n\n## 编写剧本需要注意的事项\n\n一定要编写可重复执行的剧本，也就是说playbook要是一系列对状态的定义，而不是一系列动作，在执行完后系统要达到什么样的状态，这样在重复执行剧本不会出什么问题。对应到开发上的定义，我们说编写的剧本执行需要具备幂等性，一次执行与多次执行结果一致。\n\n譬如过说要安装一个rpm包，我们可以在playbook中写一个`shell: rpm -ivh a.rpm`,这是可以执行的，但是不符合ansible的哲学，因为当包已安装过后，再次执行就会报错。我们需要使用ansible提供的yum来定义状态\n> \\- name: Install package.\n> &nbsp;   yum:\n> &nbsp; &nbsp;      name: /tmp/package.rpm\n> &nbsp; &nbsp;      state: present\n\n\n\n## ansible的弊端\n\n上面说了ansible简单、易上手，但同时我们也要了解它存在的问题才能决定是否适合我们。\n\n- 性能，ansible部署速度比chef，puppet要慢一些，在大量机器上就会显现出来\n- 成熟度，ansible界面、可用模块不如puppet成熟\n\n## 替代性技术\n\n- puppet\n- chef\n- saltstack\n- Fabric\n\n网上有很多相关的比较，各有优势，看大家的应用场景。\n\n","source":"_posts/Ansible简介及思想.md","raw":"---\ntitle: Ansible简介及思想\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [Ansible, 设计哲学]\n---\n\n## ansible是什么\n\n如果我们Google一下ansible，第一条出来的就是ansible的官网，它的title是“Ansible is Simple IT Automation”，从这里我们就能了解了ansible的目标：自动化。什么的自动化呢，其实是部署自动化(infrastructure as code)，将你原先一步一步使用命令转变为通过一系列的`状态检查`来安装一个软件，可以实现批量部署，一键部署。\n\n## 为什么用ansible\n\nansible有很多的优势，我觉得最重要的就是简单。ansible无需你安装客户端，只需要在一台机器上安装好ansible，配置好ssh，就可以使用了。语法也很简单，使用一系列的task来指定要做的任务，yaml格式提供了很好的缩进，一目了然。\n\n<!--more-->\n\n## 如何使用ansible\n\nansible使用只需3步\n- 控制机安装ansible，可以使用pip，yum或源码安装\n- 在目标机上加入控制机的ssh pub key，在控制机上都ssh一下，将目标机加入到known-hosts中去\n- 直接执行ansible命令或编写剧本来执行\n\nansible需要使用Python相关库，如果没有安装的话还需要安装，并且需要libselinux-python库（yum安装即可）。\n\n## 编写剧本需要注意的事项\n\n一定要编写可重复执行的剧本，也就是说playbook要是一系列对状态的定义，而不是一系列动作，在执行完后系统要达到什么样的状态，这样在重复执行剧本不会出什么问题。对应到开发上的定义，我们说编写的剧本执行需要具备幂等性，一次执行与多次执行结果一致。\n\n譬如过说要安装一个rpm包，我们可以在playbook中写一个`shell: rpm -ivh a.rpm`,这是可以执行的，但是不符合ansible的哲学，因为当包已安装过后，再次执行就会报错。我们需要使用ansible提供的yum来定义状态\n> \\- name: Install package.\n> &nbsp;   yum:\n> &nbsp; &nbsp;      name: /tmp/package.rpm\n> &nbsp; &nbsp;      state: present\n\n\n\n## ansible的弊端\n\n上面说了ansible简单、易上手，但同时我们也要了解它存在的问题才能决定是否适合我们。\n\n- 性能，ansible部署速度比chef，puppet要慢一些，在大量机器上就会显现出来\n- 成熟度，ansible界面、可用模块不如puppet成熟\n\n## 替代性技术\n\n- puppet\n- chef\n- saltstack\n- Fabric\n\n网上有很多相关的比较，各有优势，看大家的应用场景。\n\n","slug":"Ansible简介及思想","published":1,"updated":"2017-12-22T05:13:19.466Z","comments":1,"photos":[],"link":"","_id":"cjbhgul060009n8hxe6onjsv3","content":"<h2 id=\"ansible是什么\"><a href=\"#ansible是什么\" class=\"headerlink\" title=\"ansible是什么\"></a>ansible是什么</h2><p>如果我们Google一下ansible，第一条出来的就是ansible的官网，它的title是“Ansible is Simple IT Automation”，从这里我们就能了解了ansible的目标：自动化。什么的自动化呢，其实是部署自动化(infrastructure as code)，将你原先一步一步使用命令转变为通过一系列的<code>状态检查</code>来安装一个软件，可以实现批量部署，一键部署。</p>\n<h2 id=\"为什么用ansible\"><a href=\"#为什么用ansible\" class=\"headerlink\" title=\"为什么用ansible\"></a>为什么用ansible</h2><p>ansible有很多的优势，我觉得最重要的就是简单。ansible无需你安装客户端，只需要在一台机器上安装好ansible，配置好ssh，就可以使用了。语法也很简单，使用一系列的task来指定要做的任务，yaml格式提供了很好的缩进，一目了然。</p>\n<a id=\"more\"></a>\n<h2 id=\"如何使用ansible\"><a href=\"#如何使用ansible\" class=\"headerlink\" title=\"如何使用ansible\"></a>如何使用ansible</h2><p>ansible使用只需3步</p>\n<ul>\n<li>控制机安装ansible，可以使用pip，yum或源码安装</li>\n<li>在目标机上加入控制机的ssh pub key，在控制机上都ssh一下，将目标机加入到known-hosts中去</li>\n<li>直接执行ansible命令或编写剧本来执行</li>\n</ul>\n<p>ansible需要使用Python相关库，如果没有安装的话还需要安装，并且需要libselinux-python库（yum安装即可）。</p>\n<h2 id=\"编写剧本需要注意的事项\"><a href=\"#编写剧本需要注意的事项\" class=\"headerlink\" title=\"编写剧本需要注意的事项\"></a>编写剧本需要注意的事项</h2><p>一定要编写可重复执行的剧本，也就是说playbook要是一系列对状态的定义，而不是一系列动作，在执行完后系统要达到什么样的状态，这样在重复执行剧本不会出什么问题。对应到开发上的定义，我们说编写的剧本执行需要具备幂等性，一次执行与多次执行结果一致。</p>\n<p>譬如过说要安装一个rpm包，我们可以在playbook中写一个<code>shell: rpm -ivh a.rpm</code>,这是可以执行的，但是不符合ansible的哲学，因为当包已安装过后，再次执行就会报错。我们需要使用ansible提供的yum来定义状态</p>\n<blockquote>\n<p>- name: Install package.<br>&nbsp;   yum:<br>&nbsp; &nbsp;      name: /tmp/package.rpm<br>&nbsp; &nbsp;      state: present</p>\n</blockquote>\n<h2 id=\"ansible的弊端\"><a href=\"#ansible的弊端\" class=\"headerlink\" title=\"ansible的弊端\"></a>ansible的弊端</h2><p>上面说了ansible简单、易上手，但同时我们也要了解它存在的问题才能决定是否适合我们。</p>\n<ul>\n<li>性能，ansible部署速度比chef，puppet要慢一些，在大量机器上就会显现出来</li>\n<li>成熟度，ansible界面、可用模块不如puppet成熟</li>\n</ul>\n<h2 id=\"替代性技术\"><a href=\"#替代性技术\" class=\"headerlink\" title=\"替代性技术\"></a>替代性技术</h2><ul>\n<li>puppet</li>\n<li>chef</li>\n<li>saltstack</li>\n<li>Fabric</li>\n</ul>\n<p>网上有很多相关的比较，各有优势，看大家的应用场景。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ansible是什么\"><a href=\"#ansible是什么\" class=\"headerlink\" title=\"ansible是什么\"></a>ansible是什么</h2><p>如果我们Google一下ansible，第一条出来的就是ansible的官网，它的title是“Ansible is Simple IT Automation”，从这里我们就能了解了ansible的目标：自动化。什么的自动化呢，其实是部署自动化(infrastructure as code)，将你原先一步一步使用命令转变为通过一系列的<code>状态检查</code>来安装一个软件，可以实现批量部署，一键部署。</p>\n<h2 id=\"为什么用ansible\"><a href=\"#为什么用ansible\" class=\"headerlink\" title=\"为什么用ansible\"></a>为什么用ansible</h2><p>ansible有很多的优势，我觉得最重要的就是简单。ansible无需你安装客户端，只需要在一台机器上安装好ansible，配置好ssh，就可以使用了。语法也很简单，使用一系列的task来指定要做的任务，yaml格式提供了很好的缩进，一目了然。</p>","more":"<h2 id=\"如何使用ansible\"><a href=\"#如何使用ansible\" class=\"headerlink\" title=\"如何使用ansible\"></a>如何使用ansible</h2><p>ansible使用只需3步</p>\n<ul>\n<li>控制机安装ansible，可以使用pip，yum或源码安装</li>\n<li>在目标机上加入控制机的ssh pub key，在控制机上都ssh一下，将目标机加入到known-hosts中去</li>\n<li>直接执行ansible命令或编写剧本来执行</li>\n</ul>\n<p>ansible需要使用Python相关库，如果没有安装的话还需要安装，并且需要libselinux-python库（yum安装即可）。</p>\n<h2 id=\"编写剧本需要注意的事项\"><a href=\"#编写剧本需要注意的事项\" class=\"headerlink\" title=\"编写剧本需要注意的事项\"></a>编写剧本需要注意的事项</h2><p>一定要编写可重复执行的剧本，也就是说playbook要是一系列对状态的定义，而不是一系列动作，在执行完后系统要达到什么样的状态，这样在重复执行剧本不会出什么问题。对应到开发上的定义，我们说编写的剧本执行需要具备幂等性，一次执行与多次执行结果一致。</p>\n<p>譬如过说要安装一个rpm包，我们可以在playbook中写一个<code>shell: rpm -ivh a.rpm</code>,这是可以执行的，但是不符合ansible的哲学，因为当包已安装过后，再次执行就会报错。我们需要使用ansible提供的yum来定义状态</p>\n<blockquote>\n<p>- name: Install package.<br>&nbsp;   yum:<br>&nbsp; &nbsp;      name: /tmp/package.rpm<br>&nbsp; &nbsp;      state: present</p>\n</blockquote>\n<h2 id=\"ansible的弊端\"><a href=\"#ansible的弊端\" class=\"headerlink\" title=\"ansible的弊端\"></a>ansible的弊端</h2><p>上面说了ansible简单、易上手，但同时我们也要了解它存在的问题才能决定是否适合我们。</p>\n<ul>\n<li>性能，ansible部署速度比chef，puppet要慢一些，在大量机器上就会显现出来</li>\n<li>成熟度，ansible界面、可用模块不如puppet成熟</li>\n</ul>\n<h2 id=\"替代性技术\"><a href=\"#替代性技术\" class=\"headerlink\" title=\"替代性技术\"></a>替代性技术</h2><ul>\n<li>puppet</li>\n<li>chef</li>\n<li>saltstack</li>\n<li>Fabric</li>\n</ul>\n<p>网上有很多相关的比较，各有优势，看大家的应用场景。</p>"},{"title":"Liquibase介绍与使用","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n## Liquibase 简介\n\nliquibase在其[官网首页](http://www.liquibase.org/ \"liquibase官网\")中有一个很明确的定位，\n那就是Source Control For Your Database，Liquibase记录你的数据库变更，\n可以在你你迁移时迅速的生成一个与原数据库一致的库出来。还可以与其余数据库做diff，支持多人开发等功能。\n\n<!--more-->\n\n## Liquibase 使用\n\n### Liquibase Maven 配置\n\nLiquibase 支持命令行，maven，ant，spring等方式，我平常使用maven，因此只说一下maven需要的配置。\n\ndependency：\n```maven\n    <dependency>\n        <groupId>org.liquibase</groupId>\n        <artifactId>liquibase-core</artifactId>\n        <version>3.5.3</version>\n    </dependency>\n````\n\n提供了maven plugin，可以使用各种构建来使用Liquibase，非常方便\n\n```maven\n<plugin>\n     <groupId>org.liquibase</groupId>\n     <artifactId>liquibase-maven-plugin</artifactId>\n     <version>3.5.3</version>\n     <dependencies>\n         <dependency>\n             <groupId>javax.validation</groupId>\n             <artifactId>validation-api</artifactId>\n             <version>1.1.0.Final</version>\n         </dependency>\n         <dependency>\n             <groupId>org.javassist</groupId>\n             <artifactId>javassist</artifactId>\n             <version>3.21.0-GA</version>\n         </dependency>\n         <dependency>\n             <groupId>org.liquibase.ext</groupId>\n             <artifactId>liquibase-hibernate5</artifactId>\n             <version>3.6</version>\n         </dependency>\n         <dependency>\n             <groupId>org.springframework.boot</groupId>\n             <artifactId>spring-boot-starter-data-jpa</artifactId>\n             <version>1.5.2.RELEASE</version>\n         </dependency>\n     </dependencies>\n     <configuration>\n         <changeLogFile>src/main/resources/config/liquibase/master.xml</changeLogFile>\n         <diffChangeLogFile>src/main/resources/config/liquibase/changelog/${maven.build.timestamp}_changelog.xml</diffChangeLogFile>\n         <driver>com.mysql.jdbc.Driver</driver>\n         <url>jdbc:mysql://localhost:3306/test1</url>\n         <defaultSchemaName>test1</defaultSchemaName>\n         <username>test</username>\n         <password>test</password>\n         <verbose>true</verbose>\n         <logging>debug</logging>\n     </configuration>\n </plugin>\n```\n\njava代码中需要配置Liquibase的bean，以下是基于Spring boot配置\n```java\npublic SpringLiquibase liquibase(@Qualifier(\"taskExecutor\") TaskExecutor taskExecutor,\n            DataSource dataSource, LiquibaseProperties liquibaseProperties) {\n\n        // Use liquibase.integration.spring.SpringLiquibase if you don't want Liquibase to start asynchronously\n        SpringLiquibase liquibase = new AsyncSpringLiquibase(taskExecutor, env);\n        liquibase.setDataSource(dataSource);\n        liquibase.setChangeLog(\"classpath:config/liquibase/master.xml\");\n        liquibase.setContexts(liquibaseProperties.getContexts());\n        liquibase.setDefaultSchema(liquibaseProperties.getDefaultSchema());\n        liquibase.setDropFirst(liquibaseProperties.isDropFirst());\n        if (env.acceptsProfiles(SPRING_PROFILE_NO_LIQUIBASE)) {\n            liquibase.setShouldRun(false);\n        } else {\n            liquibase.setShouldRun(liquibaseProperties.isEnabled());\n            log.debug(\"Configuring Liquibase\");\n        }\n        return liquibase;\n    }\n```\n这里添加了根据profile决定是否启用Liquibase的判断，也可以在Liquibase的xml配置中使用preCondition来决定Liquibase是否启用\n\n### Liquibase xml配置元素\n\n#### databaseChangeLog\ndatabaseChangeLog 是配置的顶级元素，跟Spring的beans是一样的，里面可以包含其他的元素\n可以有property,preConditions,changeSet,include等元素，这里主要介绍平常使用比较多的这四种元素加loadData元素\n\n#### property\nproperty可以用来声明变量，也可以根据db来决定变量的值是如何绑定的。\n在后面的使用中用`${name}`来使用\n```xml\n<property name=\"now\" value=\"now()\" dbms=\"h2\"></property>\n<property name=\"now\" value=\"now()\" dbms=\"mysql\"></property>\n<property name=\"autoIncrement\" value=\"true\"></property>\n```\n上面声明了与数据库相关的now时间获取方法，还声明了一个平常值。\n\n#### preConditions\n只有满足了preConditions中的先决条件，Liquibase才会运行相应的配置\n譬如我们只想在h2中使用，可以这样配置：\n```xml\n<databaseChangeLog>\n    <preConditions>\n      <dbms type=\"h2\"></dbms>\n    </preConditions>\n</databaseChangeLog>\n```\npreConditions还有其他的很多选项可以使用，如`<runningAs>` `<columnExists>` `<tableExists>`等，\n有兴趣的可以自行查看[官网preconditions介绍](http://www.liquibase.org/documentation/preconditions.html)来获取更全的内容\npreConditions也可以在changeSet中使用，来决定一个changeSet是否运行，会在下面给出一个例子\n\n#### changeSet\nchangeSet意思是更改集，也就是我们数据库变更的主要部分，在这里面可以创建表，添加表行，删除表行，删除某个表，添加索引、主键等等操作,一个xml里面可以包含有多个changeSet，一个changeSet里可以包含多个操作\n\nLiquibase会在数据库中自动创建DATABASECHANGELOG，DATABASECHANGELOGLOCK两个表，其中DATABASECHANGELOG里面每一行代表的就是一个changeSet，里面的元素记录了changeSet的状态，决定后续的执行\n\n创建表：\n```xml\n<changeSet author=\"liufengquan\" id=\"1498016931954-6\">\n    <createTable tableName=\"testTable\">\n        <column autoIncrement=\"true\" name=\"id\" type=\"BIGINT\">\n            <constraints primaryKey=\"true\"/>\n        </column>\n        <column name=\"name\" type=\"VARCHAR(255)\">\n            <constraints nullable=\"false\"/>\n        </column>\n        <column name=\"length\" type=\"INT\"/>\n    </createTable>\n</changeSet>\n```\n添加表列：\n```xml\n<changeSet id=\"11111\" author=\"liufengquan\">\n    <addColumn tableName=\"testTable\">\n        <column name=\"name\" type=\"varchar(100)\"></column>\n    </addColumn>\n</changeSet>\n```\n删除表列\n```xml\n<changeSet id=\"2222\" author=\"liufengquan\">\n    <dropColumn tableName=\"testTable\" columnName=\"name\"></dropColumn>\n</changeSet>\n```\n添加索引，添加主键\n```xml\n<changeSet id=\"3333\" author=\"liufengquan\">\n    <addPrimaryKey columnNames=\" name\" tableName=\"testTable\"/>\n\n    <createIndex indexName=\"idx_testTable_name\"\n                 tableName=\"testTable\"\n                 unique=\"false\">\n        <column name=\"name\" type=\"varchar(100)\"/>\n    </createIndex>\n</changeSet>\n```\nid并没有要求必须是唯一的，在DATABASECHANGELOG表中，id,author,filepath（changeSet所在文件路径）三者决定了一个changeSet，id也未要求必须是数字，只要符合自己的习惯就可以，不过在自己书写changeSet(即author为同一人)时，自己定义的id必须不同，不然会出问题。\n如果changeSet的执行顺序有要求，可以在上面使用`runOrder`来指定\n还有`runAlways` `runOnChange`等决定changeSet的运行时机\n\n在changeSet中使用preConditions决定是否执行\n下面是一个官网上的例子，只有当表中数据为空时才把table drop掉\n```xml\n<changeSet id=\"1\" author=\"bob\">\n    <preConditions onFail=\"WARN\">\n        <sqlCheck expectedResult=\"0\">select count(*) from oldtable</sqlCheck>\n    </preConditions>\n    <comment>Comments should go after preCondition. If they are before then liquibase usually gives error.</comment>\n    <dropTable tableName=\"oldtable\"/>\n</changeSet>\n```\n更加详细的标签说明请参考[官网changeSet说明](http://www.liquibase.org/documentation/changeset.html)\n\n#### include\n所有的变更都写在一个文件里面使得文件后面会不可维护，可以按业务维护不同的database change log file，然后在一个主xml中引用所有的\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<databaseChangeLog\n    xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd\">\n\n    <preConditions>\n        <dbms type=\"h2\"/>\n    </preConditions>\n    <include file=\"classpath:config/liquibase/changelog/20170621.xml\" relativeToChangelogFile=\"false\"/>\n</databaseChangeLog>\n```\n`relativeToChangelogFile`表示引入的文件路径是否是相对于主文件路径，默认为false，可以不写\n\n#### loadData\n将数据写入到表中，文件可以使用csv格式,第一行是列名以分号分割，后续每行代表数据库中的一行数据，也以分号分割即可\n```xml\n<loadData encoding=\"UTF-8\"\n      file=\"config/liquibase/testTable.csv\"\n      separator=\";\"\n      tableName=\"testTable\"/>\n```\n\n# h2数据库\n## h2数据库简介\nh2是一个嵌入式数据库，也就是不用单独安装服务端和客户端，并且h2可以与其他主流的数据库兼容，支持MySQL，Oracle的语法。h2支持内存数据库，特别适合单元测试这种场景，当然h2不限于此，也可以持久化到硬盘上，不过大家在正式上使用的毕竟还是少。\n## h2数据库说明\nh2数据库的语法之类的大家可以自行找网上资料或者去官网学习，此处不再详述。\n配置就是在pom中引入h2的依赖,然后在spring的配置中换成h2的connector就可以了\n```xml\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <scope>test</scope>\n</dependency>\n```\nurl：\n```url\njdbc:h2:mem:Test;DB_CLOSE_DELAY=-1;MODE=MySQL\n```\n# 其他方法\nspring boot在application.yml中的提供了初始化schema和data的配置，可以使用spring.datasource.schema和spring.datasource.data分别指定建表脚本和初始化数据脚本，不过我使用了一下，直接用Navicat MySQL导出数据库脚本，在建表时报错，应该是h2对某些MySQL的语法写法不支持，这样的话去找就比较麻烦，而且后续维护这个脚本也会越来越困难，因此并没有采用这种办法。不过如果项目比较小，又图前期省事的话，这个方案还是值得使用的。\n\n\n# 总结\n使用Liquibase来管理数据库schema，使用h2来随时在内存中创建数据库，以后基本可以不用担心单元测试中的数据问题了，数据库的变更也变得有迹可循，感谢贡献出这些工具的人。","source":"_posts/Liquibase介绍与使用.md","raw":"---\ntitle: Liquibase介绍与使用\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: Liquibase\n---\n\n\n## Liquibase 简介\n\nliquibase在其[官网首页](http://www.liquibase.org/ \"liquibase官网\")中有一个很明确的定位，\n那就是Source Control For Your Database，Liquibase记录你的数据库变更，\n可以在你你迁移时迅速的生成一个与原数据库一致的库出来。还可以与其余数据库做diff，支持多人开发等功能。\n\n<!--more-->\n\n## Liquibase 使用\n\n### Liquibase Maven 配置\n\nLiquibase 支持命令行，maven，ant，spring等方式，我平常使用maven，因此只说一下maven需要的配置。\n\ndependency：\n```maven\n    <dependency>\n        <groupId>org.liquibase</groupId>\n        <artifactId>liquibase-core</artifactId>\n        <version>3.5.3</version>\n    </dependency>\n````\n\n提供了maven plugin，可以使用各种构建来使用Liquibase，非常方便\n\n```maven\n<plugin>\n     <groupId>org.liquibase</groupId>\n     <artifactId>liquibase-maven-plugin</artifactId>\n     <version>3.5.3</version>\n     <dependencies>\n         <dependency>\n             <groupId>javax.validation</groupId>\n             <artifactId>validation-api</artifactId>\n             <version>1.1.0.Final</version>\n         </dependency>\n         <dependency>\n             <groupId>org.javassist</groupId>\n             <artifactId>javassist</artifactId>\n             <version>3.21.0-GA</version>\n         </dependency>\n         <dependency>\n             <groupId>org.liquibase.ext</groupId>\n             <artifactId>liquibase-hibernate5</artifactId>\n             <version>3.6</version>\n         </dependency>\n         <dependency>\n             <groupId>org.springframework.boot</groupId>\n             <artifactId>spring-boot-starter-data-jpa</artifactId>\n             <version>1.5.2.RELEASE</version>\n         </dependency>\n     </dependencies>\n     <configuration>\n         <changeLogFile>src/main/resources/config/liquibase/master.xml</changeLogFile>\n         <diffChangeLogFile>src/main/resources/config/liquibase/changelog/${maven.build.timestamp}_changelog.xml</diffChangeLogFile>\n         <driver>com.mysql.jdbc.Driver</driver>\n         <url>jdbc:mysql://localhost:3306/test1</url>\n         <defaultSchemaName>test1</defaultSchemaName>\n         <username>test</username>\n         <password>test</password>\n         <verbose>true</verbose>\n         <logging>debug</logging>\n     </configuration>\n </plugin>\n```\n\njava代码中需要配置Liquibase的bean，以下是基于Spring boot配置\n```java\npublic SpringLiquibase liquibase(@Qualifier(\"taskExecutor\") TaskExecutor taskExecutor,\n            DataSource dataSource, LiquibaseProperties liquibaseProperties) {\n\n        // Use liquibase.integration.spring.SpringLiquibase if you don't want Liquibase to start asynchronously\n        SpringLiquibase liquibase = new AsyncSpringLiquibase(taskExecutor, env);\n        liquibase.setDataSource(dataSource);\n        liquibase.setChangeLog(\"classpath:config/liquibase/master.xml\");\n        liquibase.setContexts(liquibaseProperties.getContexts());\n        liquibase.setDefaultSchema(liquibaseProperties.getDefaultSchema());\n        liquibase.setDropFirst(liquibaseProperties.isDropFirst());\n        if (env.acceptsProfiles(SPRING_PROFILE_NO_LIQUIBASE)) {\n            liquibase.setShouldRun(false);\n        } else {\n            liquibase.setShouldRun(liquibaseProperties.isEnabled());\n            log.debug(\"Configuring Liquibase\");\n        }\n        return liquibase;\n    }\n```\n这里添加了根据profile决定是否启用Liquibase的判断，也可以在Liquibase的xml配置中使用preCondition来决定Liquibase是否启用\n\n### Liquibase xml配置元素\n\n#### databaseChangeLog\ndatabaseChangeLog 是配置的顶级元素，跟Spring的beans是一样的，里面可以包含其他的元素\n可以有property,preConditions,changeSet,include等元素，这里主要介绍平常使用比较多的这四种元素加loadData元素\n\n#### property\nproperty可以用来声明变量，也可以根据db来决定变量的值是如何绑定的。\n在后面的使用中用`${name}`来使用\n```xml\n<property name=\"now\" value=\"now()\" dbms=\"h2\"></property>\n<property name=\"now\" value=\"now()\" dbms=\"mysql\"></property>\n<property name=\"autoIncrement\" value=\"true\"></property>\n```\n上面声明了与数据库相关的now时间获取方法，还声明了一个平常值。\n\n#### preConditions\n只有满足了preConditions中的先决条件，Liquibase才会运行相应的配置\n譬如我们只想在h2中使用，可以这样配置：\n```xml\n<databaseChangeLog>\n    <preConditions>\n      <dbms type=\"h2\"></dbms>\n    </preConditions>\n</databaseChangeLog>\n```\npreConditions还有其他的很多选项可以使用，如`<runningAs>` `<columnExists>` `<tableExists>`等，\n有兴趣的可以自行查看[官网preconditions介绍](http://www.liquibase.org/documentation/preconditions.html)来获取更全的内容\npreConditions也可以在changeSet中使用，来决定一个changeSet是否运行，会在下面给出一个例子\n\n#### changeSet\nchangeSet意思是更改集，也就是我们数据库变更的主要部分，在这里面可以创建表，添加表行，删除表行，删除某个表，添加索引、主键等等操作,一个xml里面可以包含有多个changeSet，一个changeSet里可以包含多个操作\n\nLiquibase会在数据库中自动创建DATABASECHANGELOG，DATABASECHANGELOGLOCK两个表，其中DATABASECHANGELOG里面每一行代表的就是一个changeSet，里面的元素记录了changeSet的状态，决定后续的执行\n\n创建表：\n```xml\n<changeSet author=\"liufengquan\" id=\"1498016931954-6\">\n    <createTable tableName=\"testTable\">\n        <column autoIncrement=\"true\" name=\"id\" type=\"BIGINT\">\n            <constraints primaryKey=\"true\"/>\n        </column>\n        <column name=\"name\" type=\"VARCHAR(255)\">\n            <constraints nullable=\"false\"/>\n        </column>\n        <column name=\"length\" type=\"INT\"/>\n    </createTable>\n</changeSet>\n```\n添加表列：\n```xml\n<changeSet id=\"11111\" author=\"liufengquan\">\n    <addColumn tableName=\"testTable\">\n        <column name=\"name\" type=\"varchar(100)\"></column>\n    </addColumn>\n</changeSet>\n```\n删除表列\n```xml\n<changeSet id=\"2222\" author=\"liufengquan\">\n    <dropColumn tableName=\"testTable\" columnName=\"name\"></dropColumn>\n</changeSet>\n```\n添加索引，添加主键\n```xml\n<changeSet id=\"3333\" author=\"liufengquan\">\n    <addPrimaryKey columnNames=\" name\" tableName=\"testTable\"/>\n\n    <createIndex indexName=\"idx_testTable_name\"\n                 tableName=\"testTable\"\n                 unique=\"false\">\n        <column name=\"name\" type=\"varchar(100)\"/>\n    </createIndex>\n</changeSet>\n```\nid并没有要求必须是唯一的，在DATABASECHANGELOG表中，id,author,filepath（changeSet所在文件路径）三者决定了一个changeSet，id也未要求必须是数字，只要符合自己的习惯就可以，不过在自己书写changeSet(即author为同一人)时，自己定义的id必须不同，不然会出问题。\n如果changeSet的执行顺序有要求，可以在上面使用`runOrder`来指定\n还有`runAlways` `runOnChange`等决定changeSet的运行时机\n\n在changeSet中使用preConditions决定是否执行\n下面是一个官网上的例子，只有当表中数据为空时才把table drop掉\n```xml\n<changeSet id=\"1\" author=\"bob\">\n    <preConditions onFail=\"WARN\">\n        <sqlCheck expectedResult=\"0\">select count(*) from oldtable</sqlCheck>\n    </preConditions>\n    <comment>Comments should go after preCondition. If they are before then liquibase usually gives error.</comment>\n    <dropTable tableName=\"oldtable\"/>\n</changeSet>\n```\n更加详细的标签说明请参考[官网changeSet说明](http://www.liquibase.org/documentation/changeset.html)\n\n#### include\n所有的变更都写在一个文件里面使得文件后面会不可维护，可以按业务维护不同的database change log file，然后在一个主xml中引用所有的\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<databaseChangeLog\n    xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd\">\n\n    <preConditions>\n        <dbms type=\"h2\"/>\n    </preConditions>\n    <include file=\"classpath:config/liquibase/changelog/20170621.xml\" relativeToChangelogFile=\"false\"/>\n</databaseChangeLog>\n```\n`relativeToChangelogFile`表示引入的文件路径是否是相对于主文件路径，默认为false，可以不写\n\n#### loadData\n将数据写入到表中，文件可以使用csv格式,第一行是列名以分号分割，后续每行代表数据库中的一行数据，也以分号分割即可\n```xml\n<loadData encoding=\"UTF-8\"\n      file=\"config/liquibase/testTable.csv\"\n      separator=\";\"\n      tableName=\"testTable\"/>\n```\n\n# h2数据库\n## h2数据库简介\nh2是一个嵌入式数据库，也就是不用单独安装服务端和客户端，并且h2可以与其他主流的数据库兼容，支持MySQL，Oracle的语法。h2支持内存数据库，特别适合单元测试这种场景，当然h2不限于此，也可以持久化到硬盘上，不过大家在正式上使用的毕竟还是少。\n## h2数据库说明\nh2数据库的语法之类的大家可以自行找网上资料或者去官网学习，此处不再详述。\n配置就是在pom中引入h2的依赖,然后在spring的配置中换成h2的connector就可以了\n```xml\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <scope>test</scope>\n</dependency>\n```\nurl：\n```url\njdbc:h2:mem:Test;DB_CLOSE_DELAY=-1;MODE=MySQL\n```\n# 其他方法\nspring boot在application.yml中的提供了初始化schema和data的配置，可以使用spring.datasource.schema和spring.datasource.data分别指定建表脚本和初始化数据脚本，不过我使用了一下，直接用Navicat MySQL导出数据库脚本，在建表时报错，应该是h2对某些MySQL的语法写法不支持，这样的话去找就比较麻烦，而且后续维护这个脚本也会越来越困难，因此并没有采用这种办法。不过如果项目比较小，又图前期省事的话，这个方案还是值得使用的。\n\n\n# 总结\n使用Liquibase来管理数据库schema，使用h2来随时在内存中创建数据库，以后基本可以不用担心单元测试中的数据问题了，数据库的变更也变得有迹可循，感谢贡献出这些工具的人。","slug":"Liquibase介绍与使用","published":1,"updated":"2017-12-22T05:13:40.830Z","comments":1,"photos":[],"link":"","_id":"cjbhgul0b000an8hx41io2ekg","content":"<h2 id=\"Liquibase-简介\"><a href=\"#Liquibase-简介\" class=\"headerlink\" title=\"Liquibase 简介\"></a>Liquibase 简介</h2><p>liquibase在其<a href=\"http://www.liquibase.org/\" title=\"liquibase官网\" target=\"_blank\" rel=\"noopener\">官网首页</a>中有一个很明确的定位，<br>那就是Source Control For Your Database，Liquibase记录你的数据库变更，<br>可以在你你迁移时迅速的生成一个与原数据库一致的库出来。还可以与其余数据库做diff，支持多人开发等功能。</p>\n<a id=\"more\"></a>\n<h2 id=\"Liquibase-使用\"><a href=\"#Liquibase-使用\" class=\"headerlink\" title=\"Liquibase 使用\"></a>Liquibase 使用</h2><h3 id=\"Liquibase-Maven-配置\"><a href=\"#Liquibase-Maven-配置\" class=\"headerlink\" title=\"Liquibase Maven 配置\"></a>Liquibase Maven 配置</h3><p>Liquibase 支持命令行，maven，ant，spring等方式，我平常使用maven，因此只说一下maven需要的配置。</p>\n<p>dependency：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.liquibase&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.5.3&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>提供了maven plugin，可以使用各种构建来使用Liquibase，非常方便</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">     &lt;groupId&gt;org.liquibase&lt;/groupId&gt;</span><br><span class=\"line\">     &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">     &lt;version&gt;3.5.3&lt;/version&gt;</span><br><span class=\"line\">     &lt;dependencies&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;3.21.0-GA&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;org.liquibase.ext&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;liquibase-hibernate5&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;3.6&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">     &lt;/dependencies&gt;</span><br><span class=\"line\">     &lt;configuration&gt;</span><br><span class=\"line\">         &lt;changeLogFile&gt;src/main/resources/config/liquibase/master.xml&lt;/changeLogFile&gt;</span><br><span class=\"line\">         &lt;diffChangeLogFile&gt;src/main/resources/config/liquibase/changelog/$&#123;maven.build.timestamp&#125;_changelog.xml&lt;/diffChangeLogFile&gt;</span><br><span class=\"line\">         &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;</span><br><span class=\"line\">         &lt;url&gt;jdbc:mysql://localhost:3306/test1&lt;/url&gt;</span><br><span class=\"line\">         &lt;defaultSchemaName&gt;test1&lt;/defaultSchemaName&gt;</span><br><span class=\"line\">         &lt;username&gt;test&lt;/username&gt;</span><br><span class=\"line\">         &lt;password&gt;test&lt;/password&gt;</span><br><span class=\"line\">         &lt;verbose&gt;true&lt;/verbose&gt;</span><br><span class=\"line\">         &lt;logging&gt;debug&lt;/logging&gt;</span><br><span class=\"line\">     &lt;/configuration&gt;</span><br><span class=\"line\"> &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>\n<p>java代码中需要配置Liquibase的bean，以下是基于Spring boot配置<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SpringLiquibase <span class=\"title\">liquibase</span><span class=\"params\">(@Qualifier(<span class=\"string\">\"taskExecutor\"</span>)</span> TaskExecutor taskExecutor,</span></span><br><span class=\"line\"><span class=\"function\">            DataSource dataSource, LiquibaseProperties liquibaseProperties) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Use liquibase.integration.spring.SpringLiquibase if you don't want Liquibase to start asynchronously</span></span><br><span class=\"line\">        SpringLiquibase liquibase = <span class=\"keyword\">new</span> AsyncSpringLiquibase(taskExecutor, env);</span><br><span class=\"line\">        liquibase.setDataSource(dataSource);</span><br><span class=\"line\">        liquibase.setChangeLog(<span class=\"string\">\"classpath:config/liquibase/master.xml\"</span>);</span><br><span class=\"line\">        liquibase.setContexts(liquibaseProperties.getContexts());</span><br><span class=\"line\">        liquibase.setDefaultSchema(liquibaseProperties.getDefaultSchema());</span><br><span class=\"line\">        liquibase.setDropFirst(liquibaseProperties.isDropFirst());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (env.acceptsProfiles(SPRING_PROFILE_NO_LIQUIBASE)) &#123;</span><br><span class=\"line\">            liquibase.setShouldRun(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            liquibase.setShouldRun(liquibaseProperties.isEnabled());</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Configuring Liquibase\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> liquibase;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里添加了根据profile决定是否启用Liquibase的判断，也可以在Liquibase的xml配置中使用preCondition来决定Liquibase是否启用</p>\n<h3 id=\"Liquibase-xml配置元素\"><a href=\"#Liquibase-xml配置元素\" class=\"headerlink\" title=\"Liquibase xml配置元素\"></a>Liquibase xml配置元素</h3><h4 id=\"databaseChangeLog\"><a href=\"#databaseChangeLog\" class=\"headerlink\" title=\"databaseChangeLog\"></a>databaseChangeLog</h4><p>databaseChangeLog 是配置的顶级元素，跟Spring的beans是一样的，里面可以包含其他的元素<br>可以有property,preConditions,changeSet,include等元素，这里主要介绍平常使用比较多的这四种元素加loadData元素</p>\n<h4 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"property\"></a>property</h4><p>property可以用来声明变量，也可以根据db来决定变量的值是如何绑定的。<br>在后面的使用中用<code>${name}</code>来使用<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"now\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"now()\"</span> <span class=\"attr\">dbms</span>=<span class=\"string\">\"h2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"now\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"now()\"</span> <span class=\"attr\">dbms</span>=<span class=\"string\">\"mysql\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"autoIncrement\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>上面声明了与数据库相关的now时间获取方法，还声明了一个平常值。</p>\n<h4 id=\"preConditions\"><a href=\"#preConditions\" class=\"headerlink\" title=\"preConditions\"></a>preConditions</h4><p>只有满足了preConditions中的先决条件，Liquibase才会运行相应的配置<br>譬如我们只想在h2中使用，可以这样配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">databaseChangeLog</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dbms</span> <span class=\"attr\">type</span>=<span class=\"string\">\"h2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dbms</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>preConditions还有其他的很多选项可以使用，如<code>&lt;runningAs&gt;</code> <code>&lt;columnExists&gt;</code> <code>&lt;tableExists&gt;</code>等，<br>有兴趣的可以自行查看<a href=\"http://www.liquibase.org/documentation/preconditions.html\" target=\"_blank\" rel=\"noopener\">官网preconditions介绍</a>来获取更全的内容<br>preConditions也可以在changeSet中使用，来决定一个changeSet是否运行，会在下面给出一个例子</p>\n<h4 id=\"changeSet\"><a href=\"#changeSet\" class=\"headerlink\" title=\"changeSet\"></a>changeSet</h4><p>changeSet意思是更改集，也就是我们数据库变更的主要部分，在这里面可以创建表，添加表行，删除表行，删除某个表，添加索引、主键等等操作,一个xml里面可以包含有多个changeSet，一个changeSet里可以包含多个操作</p>\n<p>Liquibase会在数据库中自动创建DATABASECHANGELOG，DATABASECHANGELOGLOCK两个表，其中DATABASECHANGELOG里面每一行代表的就是一个changeSet，里面的元素记录了changeSet的状态，决定后续的执行</p>\n<p>创建表：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1498016931954-6\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">createTable</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">autoIncrement</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"id\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"BIGINT\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">constraints</span> <span class=\"attr\">primaryKey</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">column</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"VARCHAR(255)\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">constraints</span> <span class=\"attr\">nullable</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">column</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"length\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"INT\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">createTable</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>添加表列：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"11111\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">addColumn</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"varchar(100)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">column</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">addColumn</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>删除表列<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"2222\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dropColumn</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span> <span class=\"attr\">columnName</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dropColumn</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>添加索引，添加主键<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"3333\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">addPrimaryKey</span> <span class=\"attr\">columnNames</span>=<span class=\"string\">\" name\"</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">createIndex</span> <span class=\"attr\">indexName</span>=<span class=\"string\">\"idx_testTable_name\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                 <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                 <span class=\"attr\">unique</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"varchar(100)\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">createIndex</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>id并没有要求必须是唯一的，在DATABASECHANGELOG表中，id,author,filepath（changeSet所在文件路径）三者决定了一个changeSet，id也未要求必须是数字，只要符合自己的习惯就可以，不过在自己书写changeSet(即author为同一人)时，自己定义的id必须不同，不然会出问题。<br>如果changeSet的执行顺序有要求，可以在上面使用<code>runOrder</code>来指定<br>还有<code>runAlways</code> <code>runOnChange</code>等决定changeSet的运行时机</p>\n<p>在changeSet中使用preConditions决定是否执行<br>下面是一个官网上的例子，只有当表中数据为空时才把table drop掉<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"bob\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">preConditions</span> <span class=\"attr\">onFail</span>=<span class=\"string\">\"WARN\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlCheck</span> <span class=\"attr\">expectedResult</span>=<span class=\"string\">\"0\"</span>&gt;</span>select count(*) from oldtable<span class=\"tag\">&lt;/<span class=\"name\">sqlCheck</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">comment</span>&gt;</span>Comments should go after preCondition. If they are before then liquibase usually gives error.<span class=\"tag\">&lt;/<span class=\"name\">comment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dropTable</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"oldtable\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更加详细的标签说明请参考<a href=\"http://www.liquibase.org/documentation/changeset.html\" target=\"_blank\" rel=\"noopener\">官网changeSet说明</a></p>\n<h4 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h4><p>所有的变更都写在一个文件里面使得文件后面会不可维护，可以按业务维护不同的database change log file，然后在一个主xml中引用所有的<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">databaseChangeLog</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.liquibase.org/xml/ns/dbchangelog\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dbms</span> <span class=\"attr\">type</span>=<span class=\"string\">\"h2\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">file</span>=<span class=\"string\">\"classpath:config/liquibase/changelog/20170621.xml\"</span> <span class=\"attr\">relativeToChangelogFile</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>relativeToChangelogFile</code>表示引入的文件路径是否是相对于主文件路径，默认为false，可以不写</p>\n<h4 id=\"loadData\"><a href=\"#loadData\" class=\"headerlink\" title=\"loadData\"></a>loadData</h4><p>将数据写入到表中，文件可以使用csv格式,第一行是列名以分号分割，后续每行代表数据库中的一行数据，也以分号分割即可<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">loadData</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"UTF-8\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">file</span>=<span class=\"string\">\"config/liquibase/testTable.csv\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">separator</span>=<span class=\"string\">\";\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"h2数据库\"><a href=\"#h2数据库\" class=\"headerlink\" title=\"h2数据库\"></a>h2数据库</h1><h2 id=\"h2数据库简介\"><a href=\"#h2数据库简介\" class=\"headerlink\" title=\"h2数据库简介\"></a>h2数据库简介</h2><p>h2是一个嵌入式数据库，也就是不用单独安装服务端和客户端，并且h2可以与其他主流的数据库兼容，支持MySQL，Oracle的语法。h2支持内存数据库，特别适合单元测试这种场景，当然h2不限于此，也可以持久化到硬盘上，不过大家在正式上使用的毕竟还是少。</p>\n<h2 id=\"h2数据库说明\"><a href=\"#h2数据库说明\" class=\"headerlink\" title=\"h2数据库说明\"></a>h2数据库说明</h2><p>h2数据库的语法之类的大家可以自行找网上资料或者去官网学习，此处不再详述。<br>配置就是在pom中引入h2的依赖,然后在spring的配置中换成h2的connector就可以了<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.h2database<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>h2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>url：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:h2:mem:Test;DB_CLOSE_DELAY=-1;MODE=MySQL</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h1><p>spring boot在application.yml中的提供了初始化schema和data的配置，可以使用spring.datasource.schema和spring.datasource.data分别指定建表脚本和初始化数据脚本，不过我使用了一下，直接用Navicat MySQL导出数据库脚本，在建表时报错，应该是h2对某些MySQL的语法写法不支持，这样的话去找就比较麻烦，而且后续维护这个脚本也会越来越困难，因此并没有采用这种办法。不过如果项目比较小，又图前期省事的话，这个方案还是值得使用的。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>使用Liquibase来管理数据库schema，使用h2来随时在内存中创建数据库，以后基本可以不用担心单元测试中的数据问题了，数据库的变更也变得有迹可循，感谢贡献出这些工具的人。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Liquibase-简介\"><a href=\"#Liquibase-简介\" class=\"headerlink\" title=\"Liquibase 简介\"></a>Liquibase 简介</h2><p>liquibase在其<a href=\"http://www.liquibase.org/\" title=\"liquibase官网\" target=\"_blank\" rel=\"noopener\">官网首页</a>中有一个很明确的定位，<br>那就是Source Control For Your Database，Liquibase记录你的数据库变更，<br>可以在你你迁移时迅速的生成一个与原数据库一致的库出来。还可以与其余数据库做diff，支持多人开发等功能。</p>","more":"<h2 id=\"Liquibase-使用\"><a href=\"#Liquibase-使用\" class=\"headerlink\" title=\"Liquibase 使用\"></a>Liquibase 使用</h2><h3 id=\"Liquibase-Maven-配置\"><a href=\"#Liquibase-Maven-配置\" class=\"headerlink\" title=\"Liquibase Maven 配置\"></a>Liquibase Maven 配置</h3><p>Liquibase 支持命令行，maven，ant，spring等方式，我平常使用maven，因此只说一下maven需要的配置。</p>\n<p>dependency：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.liquibase&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.5.3&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>提供了maven plugin，可以使用各种构建来使用Liquibase，非常方便</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">     &lt;groupId&gt;org.liquibase&lt;/groupId&gt;</span><br><span class=\"line\">     &lt;artifactId&gt;liquibase-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">     &lt;version&gt;3.5.3&lt;/version&gt;</span><br><span class=\"line\">     &lt;dependencies&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;3.21.0-GA&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;org.liquibase.ext&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;liquibase-hibernate5&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;3.6&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">         &lt;dependency&gt;</span><br><span class=\"line\">             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class=\"line\">             &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">         &lt;/dependency&gt;</span><br><span class=\"line\">     &lt;/dependencies&gt;</span><br><span class=\"line\">     &lt;configuration&gt;</span><br><span class=\"line\">         &lt;changeLogFile&gt;src/main/resources/config/liquibase/master.xml&lt;/changeLogFile&gt;</span><br><span class=\"line\">         &lt;diffChangeLogFile&gt;src/main/resources/config/liquibase/changelog/$&#123;maven.build.timestamp&#125;_changelog.xml&lt;/diffChangeLogFile&gt;</span><br><span class=\"line\">         &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;</span><br><span class=\"line\">         &lt;url&gt;jdbc:mysql://localhost:3306/test1&lt;/url&gt;</span><br><span class=\"line\">         &lt;defaultSchemaName&gt;test1&lt;/defaultSchemaName&gt;</span><br><span class=\"line\">         &lt;username&gt;test&lt;/username&gt;</span><br><span class=\"line\">         &lt;password&gt;test&lt;/password&gt;</span><br><span class=\"line\">         &lt;verbose&gt;true&lt;/verbose&gt;</span><br><span class=\"line\">         &lt;logging&gt;debug&lt;/logging&gt;</span><br><span class=\"line\">     &lt;/configuration&gt;</span><br><span class=\"line\"> &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>\n<p>java代码中需要配置Liquibase的bean，以下是基于Spring boot配置<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SpringLiquibase <span class=\"title\">liquibase</span><span class=\"params\">(@Qualifier(<span class=\"string\">\"taskExecutor\"</span>)</span> TaskExecutor taskExecutor,</span></span><br><span class=\"line\"><span class=\"function\">            DataSource dataSource, LiquibaseProperties liquibaseProperties) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Use liquibase.integration.spring.SpringLiquibase if you don't want Liquibase to start asynchronously</span></span><br><span class=\"line\">        SpringLiquibase liquibase = <span class=\"keyword\">new</span> AsyncSpringLiquibase(taskExecutor, env);</span><br><span class=\"line\">        liquibase.setDataSource(dataSource);</span><br><span class=\"line\">        liquibase.setChangeLog(<span class=\"string\">\"classpath:config/liquibase/master.xml\"</span>);</span><br><span class=\"line\">        liquibase.setContexts(liquibaseProperties.getContexts());</span><br><span class=\"line\">        liquibase.setDefaultSchema(liquibaseProperties.getDefaultSchema());</span><br><span class=\"line\">        liquibase.setDropFirst(liquibaseProperties.isDropFirst());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (env.acceptsProfiles(SPRING_PROFILE_NO_LIQUIBASE)) &#123;</span><br><span class=\"line\">            liquibase.setShouldRun(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            liquibase.setShouldRun(liquibaseProperties.isEnabled());</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Configuring Liquibase\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> liquibase;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里添加了根据profile决定是否启用Liquibase的判断，也可以在Liquibase的xml配置中使用preCondition来决定Liquibase是否启用</p>\n<h3 id=\"Liquibase-xml配置元素\"><a href=\"#Liquibase-xml配置元素\" class=\"headerlink\" title=\"Liquibase xml配置元素\"></a>Liquibase xml配置元素</h3><h4 id=\"databaseChangeLog\"><a href=\"#databaseChangeLog\" class=\"headerlink\" title=\"databaseChangeLog\"></a>databaseChangeLog</h4><p>databaseChangeLog 是配置的顶级元素，跟Spring的beans是一样的，里面可以包含其他的元素<br>可以有property,preConditions,changeSet,include等元素，这里主要介绍平常使用比较多的这四种元素加loadData元素</p>\n<h4 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"property\"></a>property</h4><p>property可以用来声明变量，也可以根据db来决定变量的值是如何绑定的。<br>在后面的使用中用<code>${name}</code>来使用<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"now\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"now()\"</span> <span class=\"attr\">dbms</span>=<span class=\"string\">\"h2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"now\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"now()\"</span> <span class=\"attr\">dbms</span>=<span class=\"string\">\"mysql\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"autoIncrement\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>上面声明了与数据库相关的now时间获取方法，还声明了一个平常值。</p>\n<h4 id=\"preConditions\"><a href=\"#preConditions\" class=\"headerlink\" title=\"preConditions\"></a>preConditions</h4><p>只有满足了preConditions中的先决条件，Liquibase才会运行相应的配置<br>譬如我们只想在h2中使用，可以这样配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">databaseChangeLog</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dbms</span> <span class=\"attr\">type</span>=<span class=\"string\">\"h2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dbms</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>preConditions还有其他的很多选项可以使用，如<code>&lt;runningAs&gt;</code> <code>&lt;columnExists&gt;</code> <code>&lt;tableExists&gt;</code>等，<br>有兴趣的可以自行查看<a href=\"http://www.liquibase.org/documentation/preconditions.html\" target=\"_blank\" rel=\"noopener\">官网preconditions介绍</a>来获取更全的内容<br>preConditions也可以在changeSet中使用，来决定一个changeSet是否运行，会在下面给出一个例子</p>\n<h4 id=\"changeSet\"><a href=\"#changeSet\" class=\"headerlink\" title=\"changeSet\"></a>changeSet</h4><p>changeSet意思是更改集，也就是我们数据库变更的主要部分，在这里面可以创建表，添加表行，删除表行，删除某个表，添加索引、主键等等操作,一个xml里面可以包含有多个changeSet，一个changeSet里可以包含多个操作</p>\n<p>Liquibase会在数据库中自动创建DATABASECHANGELOG，DATABASECHANGELOGLOCK两个表，其中DATABASECHANGELOG里面每一行代表的就是一个changeSet，里面的元素记录了changeSet的状态，决定后续的执行</p>\n<p>创建表：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1498016931954-6\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">createTable</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">autoIncrement</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"id\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"BIGINT\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">constraints</span> <span class=\"attr\">primaryKey</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">column</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"VARCHAR(255)\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">constraints</span> <span class=\"attr\">nullable</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">column</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"length\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"INT\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">createTable</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>添加表列：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"11111\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">addColumn</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"varchar(100)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">column</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">addColumn</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>删除表列<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"2222\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dropColumn</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span> <span class=\"attr\">columnName</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dropColumn</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>添加索引，添加主键<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"3333\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"liufengquan\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">addPrimaryKey</span> <span class=\"attr\">columnNames</span>=<span class=\"string\">\" name\"</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">createIndex</span> <span class=\"attr\">indexName</span>=<span class=\"string\">\"idx_testTable_name\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                 <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                 <span class=\"attr\">unique</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">column</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"varchar(100)\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">createIndex</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>id并没有要求必须是唯一的，在DATABASECHANGELOG表中，id,author,filepath（changeSet所在文件路径）三者决定了一个changeSet，id也未要求必须是数字，只要符合自己的习惯就可以，不过在自己书写changeSet(即author为同一人)时，自己定义的id必须不同，不然会出问题。<br>如果changeSet的执行顺序有要求，可以在上面使用<code>runOrder</code>来指定<br>还有<code>runAlways</code> <code>runOnChange</code>等决定changeSet的运行时机</p>\n<p>在changeSet中使用preConditions决定是否执行<br>下面是一个官网上的例子，只有当表中数据为空时才把table drop掉<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">changeSet</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">author</span>=<span class=\"string\">\"bob\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">preConditions</span> <span class=\"attr\">onFail</span>=<span class=\"string\">\"WARN\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlCheck</span> <span class=\"attr\">expectedResult</span>=<span class=\"string\">\"0\"</span>&gt;</span>select count(*) from oldtable<span class=\"tag\">&lt;/<span class=\"name\">sqlCheck</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">comment</span>&gt;</span>Comments should go after preCondition. If they are before then liquibase usually gives error.<span class=\"tag\">&lt;/<span class=\"name\">comment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dropTable</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"oldtable\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更加详细的标签说明请参考<a href=\"http://www.liquibase.org/documentation/changeset.html\" target=\"_blank\" rel=\"noopener\">官网changeSet说明</a></p>\n<h4 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h4><p>所有的变更都写在一个文件里面使得文件后面会不可维护，可以按业务维护不同的database change log file，然后在一个主xml中引用所有的<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">databaseChangeLog</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.liquibase.org/xml/ns/dbchangelog\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dbms</span> <span class=\"attr\">type</span>=<span class=\"string\">\"h2\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">preConditions</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">file</span>=<span class=\"string\">\"classpath:config/liquibase/changelog/20170621.xml\"</span> <span class=\"attr\">relativeToChangelogFile</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>relativeToChangelogFile</code>表示引入的文件路径是否是相对于主文件路径，默认为false，可以不写</p>\n<h4 id=\"loadData\"><a href=\"#loadData\" class=\"headerlink\" title=\"loadData\"></a>loadData</h4><p>将数据写入到表中，文件可以使用csv格式,第一行是列名以分号分割，后续每行代表数据库中的一行数据，也以分号分割即可<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">loadData</span> <span class=\"attr\">encoding</span>=<span class=\"string\">\"UTF-8\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">file</span>=<span class=\"string\">\"config/liquibase/testTable.csv\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">separator</span>=<span class=\"string\">\";\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">tableName</span>=<span class=\"string\">\"testTable\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"h2数据库\"><a href=\"#h2数据库\" class=\"headerlink\" title=\"h2数据库\"></a>h2数据库</h1><h2 id=\"h2数据库简介\"><a href=\"#h2数据库简介\" class=\"headerlink\" title=\"h2数据库简介\"></a>h2数据库简介</h2><p>h2是一个嵌入式数据库，也就是不用单独安装服务端和客户端，并且h2可以与其他主流的数据库兼容，支持MySQL，Oracle的语法。h2支持内存数据库，特别适合单元测试这种场景，当然h2不限于此，也可以持久化到硬盘上，不过大家在正式上使用的毕竟还是少。</p>\n<h2 id=\"h2数据库说明\"><a href=\"#h2数据库说明\" class=\"headerlink\" title=\"h2数据库说明\"></a>h2数据库说明</h2><p>h2数据库的语法之类的大家可以自行找网上资料或者去官网学习，此处不再详述。<br>配置就是在pom中引入h2的依赖,然后在spring的配置中换成h2的connector就可以了<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.h2database<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>h2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>url：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:h2:mem:Test;DB_CLOSE_DELAY=-1;MODE=MySQL</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h1><p>spring boot在application.yml中的提供了初始化schema和data的配置，可以使用spring.datasource.schema和spring.datasource.data分别指定建表脚本和初始化数据脚本，不过我使用了一下，直接用Navicat MySQL导出数据库脚本，在建表时报错，应该是h2对某些MySQL的语法写法不支持，这样的话去找就比较麻烦，而且后续维护这个脚本也会越来越困难，因此并没有采用这种办法。不过如果项目比较小，又图前期省事的话，这个方案还是值得使用的。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>使用Liquibase来管理数据库schema，使用h2来随时在内存中创建数据库，以后基本可以不用担心单元测试中的数据问题了，数据库的变更也变得有迹可循，感谢贡献出这些工具的人。</p>"},{"title":"spring boot 配置https","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n1：使用keytool生成 keystore\n  keytool -keystore mykey.jks -genkey -alias tomcat -keyalg RSA\n  \n  记住密钥库口令和密钥口令，后面配置需要使用，这里我直接使用Tomcat\n  \n2:在application.properties 或 application.yml中配置属性\n```yaml\nserver:\n  port: 8443\n  ssl:\n    key-store: classpath:mykeys.jks\n    key-store-password: Tomcat\n    key-password: Tomcat\n```\n\n3:启动即可看到访问地址变成了https://localhost:8443","source":"_posts/Spring Boot开启https.md","raw":"---\ntitle: spring boot 配置https\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [spring boot, 模块]\n---\n\n\n1：使用keytool生成 keystore\n  keytool -keystore mykey.jks -genkey -alias tomcat -keyalg RSA\n  \n  记住密钥库口令和密钥口令，后面配置需要使用，这里我直接使用Tomcat\n  \n2:在application.properties 或 application.yml中配置属性\n```yaml\nserver:\n  port: 8443\n  ssl:\n    key-store: classpath:mykeys.jks\n    key-store-password: Tomcat\n    key-password: Tomcat\n```\n\n3:启动即可看到访问地址变成了https://localhost:8443","slug":"Spring Boot开启https","published":1,"updated":"2017-12-22T05:13:37.936Z","comments":1,"photos":[],"link":"","_id":"cjbhgul0f000cn8hx2pa28ixa","content":"<p>1：使用keytool生成 keystore<br>  keytool -keystore mykey.jks -genkey -alias tomcat -keyalg RSA</p>\n<p>  记住密钥库口令和密钥口令，后面配置需要使用，这里我直接使用Tomcat</p>\n<p>2:在application.properties 或 application.yml中配置属性<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8443</span></span><br><span class=\"line\"><span class=\"attr\">  ssl:</span></span><br><span class=\"line\"><span class=\"attr\">    key-store:</span> <span class=\"attr\">classpath:mykeys.jks</span></span><br><span class=\"line\"><span class=\"attr\">    key-store-password:</span> <span class=\"string\">Tomcat</span></span><br><span class=\"line\"><span class=\"attr\">    key-password:</span> <span class=\"string\">Tomcat</span></span><br></pre></td></tr></table></figure></p>\n<p>3:启动即可看到访问地址变成了<a href=\"https://localhost:8443\" target=\"_blank\" rel=\"noopener\">https://localhost:8443</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1：使用keytool生成 keystore<br>  keytool -keystore mykey.jks -genkey -alias tomcat -keyalg RSA</p>\n<p>  记住密钥库口令和密钥口令，后面配置需要使用，这里我直接使用Tomcat</p>\n<p>2:在application.properties 或 application.yml中配置属性<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8443</span></span><br><span class=\"line\"><span class=\"attr\">  ssl:</span></span><br><span class=\"line\"><span class=\"attr\">    key-store:</span> <span class=\"attr\">classpath:mykeys.jks</span></span><br><span class=\"line\"><span class=\"attr\">    key-store-password:</span> <span class=\"string\">Tomcat</span></span><br><span class=\"line\"><span class=\"attr\">    key-password:</span> <span class=\"string\">Tomcat</span></span><br></pre></td></tr></table></figure></p>\n<p>3:启动即可看到访问地址变成了<a href=\"https://localhost:8443\" target=\"_blank\" rel=\"noopener\">https://localhost:8443</a></p>\n"},{"title":"使用Optional来减少null检查","date":"2017-12-21T09:57:44.000Z","layout":"tag","_content":"\n\n## 由来\n\n平常我们使用null检查在项目中简直太常见了，从数据库中查询到的数据可能不存在返回null，service中处理中发现不存在返回一个null，在互相调用的时候每次都需要做`(if obj != null)`的判断，散落在程序中很难看。更难看的是当你遗漏了一个空指针判断，程序就会无情的给你抛出一个NPE让你知道谁才是老大。\n\n假设我们有一个用户类User，用户可以有收货地址类Addr，收货地址中肯定会有省province属性啦，如果我们要获取用户的收货省，简单的来一个链式操作`user.getAddr().getProvince()`,这样操作可以么?\n\n<!--more-->\n\n## 以往的null检查方式\n\n用户在新注册之后可能是没有收货地址的，因此`user.getAddr()`返回null，再调用就会给你点颜色看看。因此我们必须要先判断null，然后才能决定是否可以调用`getProvince`方法\n```java\npublic String getUserConsigneeProvince(User user){\n  if (user != null){\n     Addr addr = user.getAddr();\n     if (addr != null){\n       return addr.getProvince();\n     }\n  }\n  return null;  \n}\n```\n\n或者使用防御式编程方式(以前我喜欢的编程方式),在检查到null后直接处理\n\n```java\npublic String getUserConsigneeProvince(User user){\n  if (user == null){\n    return null;\n  }\n  Addr addr = user.getAddr();\n  if (addr == null){\n    return null;\n  }\n  return addr.getProvince();\n}\n```\n\n\n在这里我们也很鸡贼的返回了一个null来表示用户的收货省不存在,给以后的使用这个方法的人(当然也包括自己)挖了一个坑，如果直接返回给前端，那页面上就会有一个大大的null等着QA给你提bug吧。\n\n\n## 1.8中对Null的处理\n\n在Haskell中有一个Maybe类来处理可能的null，Scala中也提供了Option[T]来表示，Kotlin中使用在调用后加?来安全的处理返回值为null的情况。Java1.8借鉴了Haskell和Scala中方式，提供了一个Optional类来帮助程序员避免null检查。\n\n\n### 设计哲学\n\n我们看到在获取收货省的api中返回值直接是一个String，我们是不可能从这个返回值上面看出用户的收货省是否存在的，因此在设计时，对于可能不存在的值，我们选择返回一个Optional来表示你需要处理不存在的情况。\n\n因此我们把返回值改写成`Optional<String>`\n```java\npublic Optional<String> getUserConsigneeProvince(User user){\n  if (user == null){\n    return Optional.empty();\n  }\n  Addr addr = user.getAddr();\n  if (addr == null){\n    return Optional.empty();\n  }\n  return Optional.of(addr.getProvince());\n}\n```\n\n不过这并没有改善我们的内部处理，还是判断了null，因此我们先来看一下Optional的API，来来看一下用Optional如何简化我们的书写方式。\n\n### 处理方式\n\n#### API\n\nOptional<T> Api:\n\n| 名称 | 返回值 | 参数 | 说明|\n| ------- | ------- | ------: | :------: |\n|isPresent | boolean | void | 如果不存在值则false，存在为true|\n|ifPresent | void | Consumer| 如果存在则调用Consumer消费值 |\n|map | Function | Optional<U> | 对值做映射 |\n|flatMap | Function | Optional<U> | 对值做扁平映射 | \n|orElse | T | T | 存在返回包含的值，不存在就返回这里面的值 |\n|orElseGet | T | Supplier<T> | 返回用supplier 生成的一个值 |\n|filter | Predicate | Optional<T> | 过滤值 |\n| get| T| void | 获取包装的值,不存在会抛出异常|\n\n\n可以看到API设计中使用到了函数式相关的东西，使得我们调用的时候可以使用lambda或者行为参数化的方式更方便的使用\n在map和flatMap等API中隐含了null的判断，使得我们不用在应用中显式的去做null判断了。\n\n#### 一个参数的实践\n\n接下来就是见证奇迹的时刻：\n```java\npublic Optional<String> getUserConsigneeProvince(User user){\n  return Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince);\n}\n```\n我们使用1行代码代替了6行，而且表达的更加清晰\n\n当然如果这个API很多人使用，很难改变返回值的话我们可以使用orElse做值处理，如下：\n```java\npublic String getUserConsigneeProvince(User user){\n  return Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince).orElse(\"\");\n}\n```\nget方法只有我们在确定值一定存在的情况下才能使用。\n\n可以看到我们并未改变接口参数和返回值，但在内部处理上经过重写我们已经简化了非常多的代码，逻辑也变得清晰，更具有可读性。\n\n为何可以如此写呢？Optional类其实是将null判断内化了，将null判断从用户手中接过来变成自己API的一部分，把用户从null判断的深渊中解放出来，只用关注自己的业务处理逻辑。\n\n#### 两个参数的处理\n上面是一个参数的处理，如果我们有两个参数该怎么办呢。\n\n假设有两个用户，我们需要判断一下他们是否是同一个省的，就使用上面已经提供的获取省的方法\n```java\npublic static boolean isSameProvince(User user1, User user2) {\n    String user1Province = getUserConsigneeProvince(user1);\n    String user2Province = getUserConsigneeProvince(user2);\n    if (user1Province == null || user2Province == null) {\n        return false;\n    }\n    if (user2Province.equals(user2Province)) {\n        return true;\n    }\n    return false;\n}\n```\n还好还好，只有一个if判断了null的情况，可是我们也用了9行才完成了这个简单的功能，我们其实最需要的equals这个判断，上面的三行null相关应该是需要避免的。\n我们用Optional来改写一下，来感受下威力。\n\n```java\n*public static boolean isSameProvince2(User user1, User user2) {\n        return Optional.ofNullable(getUserConsigneeProvince(user1))\n            .map(p -> Optional.ofNullable(getUserConsigneeProvince(user2))\n                .filter(p2 -> p.equals(p2)))  \n            .isPresent();\n}\n```\n为了可读性我们写了4行，就算如此我们也减少了一半的代码，而且逻辑上更连贯，没有打断我们的可恶的null了。\n\n## 总结\n\n如上可以看出Optional在使用上带给我们的变化，让我们可以摆脱以往的null，用更加健康的调用方式来编写。也增加代码的可读性，逻辑上一气呵成。希望大家在平常多多使用。尽快远离恼人的null。\n","source":"_posts/使用Optional来减少null检查.md","raw":"---\ntitle: 使用Optional来减少null检查\ndate: 2017-12-21 17:57:44\nlayout: tag\ntags: [Java, Optional]\n---\n\n\n## 由来\n\n平常我们使用null检查在项目中简直太常见了，从数据库中查询到的数据可能不存在返回null，service中处理中发现不存在返回一个null，在互相调用的时候每次都需要做`(if obj != null)`的判断，散落在程序中很难看。更难看的是当你遗漏了一个空指针判断，程序就会无情的给你抛出一个NPE让你知道谁才是老大。\n\n假设我们有一个用户类User，用户可以有收货地址类Addr，收货地址中肯定会有省province属性啦，如果我们要获取用户的收货省，简单的来一个链式操作`user.getAddr().getProvince()`,这样操作可以么?\n\n<!--more-->\n\n## 以往的null检查方式\n\n用户在新注册之后可能是没有收货地址的，因此`user.getAddr()`返回null，再调用就会给你点颜色看看。因此我们必须要先判断null，然后才能决定是否可以调用`getProvince`方法\n```java\npublic String getUserConsigneeProvince(User user){\n  if (user != null){\n     Addr addr = user.getAddr();\n     if (addr != null){\n       return addr.getProvince();\n     }\n  }\n  return null;  \n}\n```\n\n或者使用防御式编程方式(以前我喜欢的编程方式),在检查到null后直接处理\n\n```java\npublic String getUserConsigneeProvince(User user){\n  if (user == null){\n    return null;\n  }\n  Addr addr = user.getAddr();\n  if (addr == null){\n    return null;\n  }\n  return addr.getProvince();\n}\n```\n\n\n在这里我们也很鸡贼的返回了一个null来表示用户的收货省不存在,给以后的使用这个方法的人(当然也包括自己)挖了一个坑，如果直接返回给前端，那页面上就会有一个大大的null等着QA给你提bug吧。\n\n\n## 1.8中对Null的处理\n\n在Haskell中有一个Maybe类来处理可能的null，Scala中也提供了Option[T]来表示，Kotlin中使用在调用后加?来安全的处理返回值为null的情况。Java1.8借鉴了Haskell和Scala中方式，提供了一个Optional类来帮助程序员避免null检查。\n\n\n### 设计哲学\n\n我们看到在获取收货省的api中返回值直接是一个String，我们是不可能从这个返回值上面看出用户的收货省是否存在的，因此在设计时，对于可能不存在的值，我们选择返回一个Optional来表示你需要处理不存在的情况。\n\n因此我们把返回值改写成`Optional<String>`\n```java\npublic Optional<String> getUserConsigneeProvince(User user){\n  if (user == null){\n    return Optional.empty();\n  }\n  Addr addr = user.getAddr();\n  if (addr == null){\n    return Optional.empty();\n  }\n  return Optional.of(addr.getProvince());\n}\n```\n\n不过这并没有改善我们的内部处理，还是判断了null，因此我们先来看一下Optional的API，来来看一下用Optional如何简化我们的书写方式。\n\n### 处理方式\n\n#### API\n\nOptional<T> Api:\n\n| 名称 | 返回值 | 参数 | 说明|\n| ------- | ------- | ------: | :------: |\n|isPresent | boolean | void | 如果不存在值则false，存在为true|\n|ifPresent | void | Consumer| 如果存在则调用Consumer消费值 |\n|map | Function | Optional<U> | 对值做映射 |\n|flatMap | Function | Optional<U> | 对值做扁平映射 | \n|orElse | T | T | 存在返回包含的值，不存在就返回这里面的值 |\n|orElseGet | T | Supplier<T> | 返回用supplier 生成的一个值 |\n|filter | Predicate | Optional<T> | 过滤值 |\n| get| T| void | 获取包装的值,不存在会抛出异常|\n\n\n可以看到API设计中使用到了函数式相关的东西，使得我们调用的时候可以使用lambda或者行为参数化的方式更方便的使用\n在map和flatMap等API中隐含了null的判断，使得我们不用在应用中显式的去做null判断了。\n\n#### 一个参数的实践\n\n接下来就是见证奇迹的时刻：\n```java\npublic Optional<String> getUserConsigneeProvince(User user){\n  return Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince);\n}\n```\n我们使用1行代码代替了6行，而且表达的更加清晰\n\n当然如果这个API很多人使用，很难改变返回值的话我们可以使用orElse做值处理，如下：\n```java\npublic String getUserConsigneeProvince(User user){\n  return Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince).orElse(\"\");\n}\n```\nget方法只有我们在确定值一定存在的情况下才能使用。\n\n可以看到我们并未改变接口参数和返回值，但在内部处理上经过重写我们已经简化了非常多的代码，逻辑也变得清晰，更具有可读性。\n\n为何可以如此写呢？Optional类其实是将null判断内化了，将null判断从用户手中接过来变成自己API的一部分，把用户从null判断的深渊中解放出来，只用关注自己的业务处理逻辑。\n\n#### 两个参数的处理\n上面是一个参数的处理，如果我们有两个参数该怎么办呢。\n\n假设有两个用户，我们需要判断一下他们是否是同一个省的，就使用上面已经提供的获取省的方法\n```java\npublic static boolean isSameProvince(User user1, User user2) {\n    String user1Province = getUserConsigneeProvince(user1);\n    String user2Province = getUserConsigneeProvince(user2);\n    if (user1Province == null || user2Province == null) {\n        return false;\n    }\n    if (user2Province.equals(user2Province)) {\n        return true;\n    }\n    return false;\n}\n```\n还好还好，只有一个if判断了null的情况，可是我们也用了9行才完成了这个简单的功能，我们其实最需要的equals这个判断，上面的三行null相关应该是需要避免的。\n我们用Optional来改写一下，来感受下威力。\n\n```java\n*public static boolean isSameProvince2(User user1, User user2) {\n        return Optional.ofNullable(getUserConsigneeProvince(user1))\n            .map(p -> Optional.ofNullable(getUserConsigneeProvince(user2))\n                .filter(p2 -> p.equals(p2)))  \n            .isPresent();\n}\n```\n为了可读性我们写了4行，就算如此我们也减少了一半的代码，而且逻辑上更连贯，没有打断我们的可恶的null了。\n\n## 总结\n\n如上可以看出Optional在使用上带给我们的变化，让我们可以摆脱以往的null，用更加健康的调用方式来编写。也增加代码的可读性，逻辑上一气呵成。希望大家在平常多多使用。尽快远离恼人的null。\n","slug":"使用Optional来减少null检查","published":1,"updated":"2017-12-22T05:13:30.709Z","comments":1,"photos":[],"link":"","_id":"cjbhgul0h000en8hx0usdojb8","content":"<h2 id=\"由来\"><a href=\"#由来\" class=\"headerlink\" title=\"由来\"></a>由来</h2><p>平常我们使用null检查在项目中简直太常见了，从数据库中查询到的数据可能不存在返回null，service中处理中发现不存在返回一个null，在互相调用的时候每次都需要做<code>(if obj != null)</code>的判断，散落在程序中很难看。更难看的是当你遗漏了一个空指针判断，程序就会无情的给你抛出一个NPE让你知道谁才是老大。</p>\n<p>假设我们有一个用户类User，用户可以有收货地址类Addr，收货地址中肯定会有省province属性啦，如果我们要获取用户的收货省，简单的来一个链式操作<code>user.getAddr().getProvince()</code>,这样操作可以么?</p>\n<a id=\"more\"></a>\n<h2 id=\"以往的null检查方式\"><a href=\"#以往的null检查方式\" class=\"headerlink\" title=\"以往的null检查方式\"></a>以往的null检查方式</h2><p>用户在新注册之后可能是没有收货地址的，因此<code>user.getAddr()</code>返回null，再调用就会给你点颜色看看。因此我们必须要先判断null，然后才能决定是否可以调用<code>getProvince</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">     Addr addr = user.getAddr();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (addr != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> addr.getProvince();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者使用防御式编程方式(以前我喜欢的编程方式),在检查到null后直接处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Addr addr = user.getAddr();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (addr == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr.getProvince();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里我们也很鸡贼的返回了一个null来表示用户的收货省不存在,给以后的使用这个方法的人(当然也包括自己)挖了一个坑，如果直接返回给前端，那页面上就会有一个大大的null等着QA给你提bug吧。</p>\n<h2 id=\"1-8中对Null的处理\"><a href=\"#1-8中对Null的处理\" class=\"headerlink\" title=\"1.8中对Null的处理\"></a>1.8中对Null的处理</h2><p>在Haskell中有一个Maybe类来处理可能的null，Scala中也提供了Option[T]来表示，Kotlin中使用在调用后加?来安全的处理返回值为null的情况。Java1.8借鉴了Haskell和Scala中方式，提供了一个Optional类来帮助程序员避免null检查。</p>\n<h3 id=\"设计哲学\"><a href=\"#设计哲学\" class=\"headerlink\" title=\"设计哲学\"></a>设计哲学</h3><p>我们看到在获取收货省的api中返回值直接是一个String，我们是不可能从这个返回值上面看出用户的收货省是否存在的，因此在设计时，对于可能不存在的值，我们选择返回一个Optional来表示你需要处理不存在的情况。</p>\n<p>因此我们把返回值改写成<code>Optional&lt;String&gt;</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Optional&lt;String&gt; <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Addr addr = user.getAddr();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (addr == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Optional.of(addr.getProvince());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过这并没有改善我们的内部处理，还是判断了null，因此我们先来看一下Optional的API，来来看一下用Optional如何简化我们的书写方式。</p>\n<h3 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h3><h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>Optional<t> Api:</t></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>返回值</th>\n<th style=\"text-align:right\">参数</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isPresent</td>\n<td>boolean</td>\n<td style=\"text-align:right\">void</td>\n<td style=\"text-align:center\">如果不存在值则false，存在为true</td>\n</tr>\n<tr>\n<td>ifPresent</td>\n<td>void</td>\n<td style=\"text-align:right\">Consumer</td>\n<td style=\"text-align:center\">如果存在则调用Consumer消费值</td>\n</tr>\n<tr>\n<td>map</td>\n<td>Function</td>\n<td style=\"text-align:right\">Optional<u></u></td>\n<td style=\"text-align:center\">对值做映射</td>\n</tr>\n<tr>\n<td>flatMap</td>\n<td>Function</td>\n<td style=\"text-align:right\">Optional<u></u></td>\n<td style=\"text-align:center\">对值做扁平映射</td>\n</tr>\n<tr>\n<td>orElse</td>\n<td>T</td>\n<td style=\"text-align:right\">T</td>\n<td style=\"text-align:center\">存在返回包含的值，不存在就返回这里面的值</td>\n</tr>\n<tr>\n<td>orElseGet</td>\n<td>T</td>\n<td style=\"text-align:right\">Supplier<t></t></td>\n<td style=\"text-align:center\">返回用supplier 生成的一个值</td>\n</tr>\n<tr>\n<td>filter</td>\n<td>Predicate</td>\n<td style=\"text-align:right\">Optional<t></t></td>\n<td style=\"text-align:center\">过滤值</td>\n</tr>\n<tr>\n<td>get</td>\n<td>T</td>\n<td style=\"text-align:right\">void</td>\n<td style=\"text-align:center\">获取包装的值,不存在会抛出异常</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到API设计中使用到了函数式相关的东西，使得我们调用的时候可以使用lambda或者行为参数化的方式更方便的使用<br>在map和flatMap等API中隐含了null的判断，使得我们不用在应用中显式的去做null判断了。</p>\n<h4 id=\"一个参数的实践\"><a href=\"#一个参数的实践\" class=\"headerlink\" title=\"一个参数的实践\"></a>一个参数的实践</h4><p>接下来就是见证奇迹的时刻：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Optional&lt;String&gt; <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们使用1行代码代替了6行，而且表达的更加清晰</p>\n<p>当然如果这个API很多人使用，很难改变返回值的话我们可以使用orElse做值处理，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince).orElse(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>get方法只有我们在确定值一定存在的情况下才能使用。</p>\n<p>可以看到我们并未改变接口参数和返回值，但在内部处理上经过重写我们已经简化了非常多的代码，逻辑也变得清晰，更具有可读性。</p>\n<p>为何可以如此写呢？Optional类其实是将null判断内化了，将null判断从用户手中接过来变成自己API的一部分，把用户从null判断的深渊中解放出来，只用关注自己的业务处理逻辑。</p>\n<h4 id=\"两个参数的处理\"><a href=\"#两个参数的处理\" class=\"headerlink\" title=\"两个参数的处理\"></a>两个参数的处理</h4><p>上面是一个参数的处理，如果我们有两个参数该怎么办呢。</p>\n<p>假设有两个用户，我们需要判断一下他们是否是同一个省的，就使用上面已经提供的获取省的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameProvince</span><span class=\"params\">(User user1, User user2)</span> </span>&#123;</span><br><span class=\"line\">    String user1Province = getUserConsigneeProvince(user1);</span><br><span class=\"line\">    String user2Province = getUserConsigneeProvince(user2);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user1Province == <span class=\"keyword\">null</span> || user2Province == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user2Province.equals(user2Province)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还好还好，只有一个if判断了null的情况，可是我们也用了9行才完成了这个简单的功能，我们其实最需要的equals这个判断，上面的三行null相关应该是需要避免的。<br>我们用Optional来改写一下，来感受下威力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameProvince2</span><span class=\"params\">(User user1, User user2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.ofNullable(getUserConsigneeProvince(user1))</span><br><span class=\"line\">            .map(p -&gt; Optional.ofNullable(getUserConsigneeProvince(user2))</span><br><span class=\"line\">                .filter(p2 -&gt; p.equals(p2)))  </span><br><span class=\"line\">            .isPresent();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了可读性我们写了4行，就算如此我们也减少了一半的代码，而且逻辑上更连贯，没有打断我们的可恶的null了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如上可以看出Optional在使用上带给我们的变化，让我们可以摆脱以往的null，用更加健康的调用方式来编写。也增加代码的可读性，逻辑上一气呵成。希望大家在平常多多使用。尽快远离恼人的null。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"由来\"><a href=\"#由来\" class=\"headerlink\" title=\"由来\"></a>由来</h2><p>平常我们使用null检查在项目中简直太常见了，从数据库中查询到的数据可能不存在返回null，service中处理中发现不存在返回一个null，在互相调用的时候每次都需要做<code>(if obj != null)</code>的判断，散落在程序中很难看。更难看的是当你遗漏了一个空指针判断，程序就会无情的给你抛出一个NPE让你知道谁才是老大。</p>\n<p>假设我们有一个用户类User，用户可以有收货地址类Addr，收货地址中肯定会有省province属性啦，如果我们要获取用户的收货省，简单的来一个链式操作<code>user.getAddr().getProvince()</code>,这样操作可以么?</p>","more":"<h2 id=\"以往的null检查方式\"><a href=\"#以往的null检查方式\" class=\"headerlink\" title=\"以往的null检查方式\"></a>以往的null检查方式</h2><p>用户在新注册之后可能是没有收货地址的，因此<code>user.getAddr()</code>返回null，再调用就会给你点颜色看看。因此我们必须要先判断null，然后才能决定是否可以调用<code>getProvince</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">     Addr addr = user.getAddr();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (addr != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> addr.getProvince();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者使用防御式编程方式(以前我喜欢的编程方式),在检查到null后直接处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Addr addr = user.getAddr();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (addr == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr.getProvince();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里我们也很鸡贼的返回了一个null来表示用户的收货省不存在,给以后的使用这个方法的人(当然也包括自己)挖了一个坑，如果直接返回给前端，那页面上就会有一个大大的null等着QA给你提bug吧。</p>\n<h2 id=\"1-8中对Null的处理\"><a href=\"#1-8中对Null的处理\" class=\"headerlink\" title=\"1.8中对Null的处理\"></a>1.8中对Null的处理</h2><p>在Haskell中有一个Maybe类来处理可能的null，Scala中也提供了Option[T]来表示，Kotlin中使用在调用后加?来安全的处理返回值为null的情况。Java1.8借鉴了Haskell和Scala中方式，提供了一个Optional类来帮助程序员避免null检查。</p>\n<h3 id=\"设计哲学\"><a href=\"#设计哲学\" class=\"headerlink\" title=\"设计哲学\"></a>设计哲学</h3><p>我们看到在获取收货省的api中返回值直接是一个String，我们是不可能从这个返回值上面看出用户的收货省是否存在的，因此在设计时，对于可能不存在的值，我们选择返回一个Optional来表示你需要处理不存在的情况。</p>\n<p>因此我们把返回值改写成<code>Optional&lt;String&gt;</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Optional&lt;String&gt; <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Addr addr = user.getAddr();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (addr == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Optional.of(addr.getProvince());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过这并没有改善我们的内部处理，还是判断了null，因此我们先来看一下Optional的API，来来看一下用Optional如何简化我们的书写方式。</p>\n<h3 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h3><h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>Optional<t> Api:</t></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>返回值</th>\n<th style=\"text-align:right\">参数</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isPresent</td>\n<td>boolean</td>\n<td style=\"text-align:right\">void</td>\n<td style=\"text-align:center\">如果不存在值则false，存在为true</td>\n</tr>\n<tr>\n<td>ifPresent</td>\n<td>void</td>\n<td style=\"text-align:right\">Consumer</td>\n<td style=\"text-align:center\">如果存在则调用Consumer消费值</td>\n</tr>\n<tr>\n<td>map</td>\n<td>Function</td>\n<td style=\"text-align:right\">Optional<u></u></td>\n<td style=\"text-align:center\">对值做映射</td>\n</tr>\n<tr>\n<td>flatMap</td>\n<td>Function</td>\n<td style=\"text-align:right\">Optional<u></u></td>\n<td style=\"text-align:center\">对值做扁平映射</td>\n</tr>\n<tr>\n<td>orElse</td>\n<td>T</td>\n<td style=\"text-align:right\">T</td>\n<td style=\"text-align:center\">存在返回包含的值，不存在就返回这里面的值</td>\n</tr>\n<tr>\n<td>orElseGet</td>\n<td>T</td>\n<td style=\"text-align:right\">Supplier<t></t></td>\n<td style=\"text-align:center\">返回用supplier 生成的一个值</td>\n</tr>\n<tr>\n<td>filter</td>\n<td>Predicate</td>\n<td style=\"text-align:right\">Optional<t></t></td>\n<td style=\"text-align:center\">过滤值</td>\n</tr>\n<tr>\n<td>get</td>\n<td>T</td>\n<td style=\"text-align:right\">void</td>\n<td style=\"text-align:center\">获取包装的值,不存在会抛出异常</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到API设计中使用到了函数式相关的东西，使得我们调用的时候可以使用lambda或者行为参数化的方式更方便的使用<br>在map和flatMap等API中隐含了null的判断，使得我们不用在应用中显式的去做null判断了。</p>\n<h4 id=\"一个参数的实践\"><a href=\"#一个参数的实践\" class=\"headerlink\" title=\"一个参数的实践\"></a>一个参数的实践</h4><p>接下来就是见证奇迹的时刻：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Optional&lt;String&gt; <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们使用1行代码代替了6行，而且表达的更加清晰</p>\n<p>当然如果这个API很多人使用，很难改变返回值的话我们可以使用orElse做值处理，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserConsigneeProvince</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Optional.ofNullable(user).map(User::getAddr).map(Addr::getProvince).orElse(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>get方法只有我们在确定值一定存在的情况下才能使用。</p>\n<p>可以看到我们并未改变接口参数和返回值，但在内部处理上经过重写我们已经简化了非常多的代码，逻辑也变得清晰，更具有可读性。</p>\n<p>为何可以如此写呢？Optional类其实是将null判断内化了，将null判断从用户手中接过来变成自己API的一部分，把用户从null判断的深渊中解放出来，只用关注自己的业务处理逻辑。</p>\n<h4 id=\"两个参数的处理\"><a href=\"#两个参数的处理\" class=\"headerlink\" title=\"两个参数的处理\"></a>两个参数的处理</h4><p>上面是一个参数的处理，如果我们有两个参数该怎么办呢。</p>\n<p>假设有两个用户，我们需要判断一下他们是否是同一个省的，就使用上面已经提供的获取省的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameProvince</span><span class=\"params\">(User user1, User user2)</span> </span>&#123;</span><br><span class=\"line\">    String user1Province = getUserConsigneeProvince(user1);</span><br><span class=\"line\">    String user2Province = getUserConsigneeProvince(user2);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user1Province == <span class=\"keyword\">null</span> || user2Province == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user2Province.equals(user2Province)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还好还好，只有一个if判断了null的情况，可是我们也用了9行才完成了这个简单的功能，我们其实最需要的equals这个判断，上面的三行null相关应该是需要避免的。<br>我们用Optional来改写一下，来感受下威力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameProvince2</span><span class=\"params\">(User user1, User user2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.ofNullable(getUserConsigneeProvince(user1))</span><br><span class=\"line\">            .map(p -&gt; Optional.ofNullable(getUserConsigneeProvince(user2))</span><br><span class=\"line\">                .filter(p2 -&gt; p.equals(p2)))  </span><br><span class=\"line\">            .isPresent();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了可读性我们写了4行，就算如此我们也减少了一半的代码，而且逻辑上更连贯，没有打断我们的可恶的null了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如上可以看出Optional在使用上带给我们的变化，让我们可以摆脱以往的null，用更加健康的调用方式来编写。也增加代码的可读性，逻辑上一气呵成。希望大家在平常多多使用。尽快远离恼人的null。</p>"},{"title":"关于防御式编程的一点思考","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n    上周看了代码大全里面的防御式编程那一章，颇有感触，结合平日里的编程实践，\n\t对自己的一些编程方式与想法记录一下，也探讨一下如何写出更安全、更有可读性的代码。\n\n## 防御式编程\n\n### 定义\n\n  防御式编程这一概念来自防御式驾驶，即要建立起这样一种思维：你永远也不知道另一位司机将要做什么，时刻提高警惕，这样才能在其他司机做出危险动作时不受伤害。防御式编程的主要思想是子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误。以怀疑的眼光看待任何外部数据，建立自己的准入机制，这样才能使自己的程序更加健壮。\n  \n### 保护数据免遭非法数据的破坏\n  \n  - 检查所有外部输入的数据，包括外部文件，读取的用户输入等\n  - 检查子程序的输入参数\n  - 决定如何处理错误的输入数据\n  \n  防御式编程的理念就是在一开始就不要引入错误。\n  \n<!--more-->\n\n### 错误处理\n  \n  在我看来使用`assert`关键字来判断数据的合法性是不合适的，这样的语句数量多了散落在程序的各处，会导致线上与线下环境的不一致。而且`assert`在断言失败后抛出error，使程序终止运行，这在企业编码实践中是不可行的，因此直接来看书中的错误处理一节。\n  \n  在碰到错误后，如何处理呢?\n  \n  - 返回中立的值。在某些场景下是很有用的，在Java中可以直接用 `Optional`类的API来做相关处理\n  - 换用下一个正确的数据。书中给出的例子是体温计，但在我们平常开发中，这种情况不怎么常见。\n  - 返回与前次相同的数据。\n  - 换用最近的合法值\n  - 记录到日志文件中。这个是必须的，需要跟其他的手段结合起来一起用。\n  - 返回一个错误码。\n  - 返回一个错误信息。 这两个通常我们结合起来使用，在rpc调用或与前端交互时，我们需要定义通用的格式来表示请求是否成功。\n  - 用妥当的方式在局部处理错误。这个要看具体的设计，具体产品的容错性。\n\n  既然有这么多的错误处理选择，我们需要在高层对错误处理进行一定的设计和规范，保证整个程序采用一致的错误处理方式。比如在遇到非法数据时，按照统一格式返回错误码和错误信息，并记录到日志中；遇到某些不可知原因抛出异常，就要约到在哪个层次来处理这些异常，并确保异常得到了处理。\n  \n### 异常\n\n  异常也是我们工具箱中一个有力的工具，但是不能滥用异常，需要审慎明智的使用。\n  \n  - 用异常通知程序的其他部分，发生了不可忽略的错误。\n  - 只有在真正例外情况下才抛出异常。\n  - 不能用异常来推卸责任。\n  - 避免在构造函数和析构函数中抛出异常，除非在同一地方将其捕获。\n  - 在恰当的抽象层次抛出异常。意为抛出本身同一层次的异常，譬如在从文件中读取员工id时，不要抛出FileNotExistedException等异常，可以封装成EmployeeNotAvailableException再向上抛出\n  - 在异常消息中加入关于导致异常发生的全部消息。也就是在构造异常时，一定要把cause带上。\n  - 避免使用空的catch。捕获异常不做任何处理是最无耻的行为，会导致后续的维护异常艰难。\n  - 创建一个集中的异常报告机制\n  - 把异常的使用标准化。创建项目异常类，规定什么时候局部处理异常，什么时候向上抛出，定义全局的异常报告机制。\n  - 考虑异常的替换方案。尽可能不使用异常，而使用错误处理机制来处理常见的错误。\n\n  异常在有些时候可以简化很多需要处理的流程，但我们还是需要根据上面的这些原则来谨慎的使用异常。\n  \n### 对防御式编程保持防御姿态\n\n  不要过度防御，过多的检查会使得项目变得臃肿，主线处理逻辑不清晰。\n  \n## 对防御式编程的一点实践\n\n  - 对所有的输入参数进行合法性校验\n  - 对所有函数的返回值进行非空、错误码等校验\n  - 对函数的处理流程就行校验，比如说必须满足同一任务不能重复处理等等。\n\n  好处：能写出很健壮的程序，如果能在编码阶段把所有的异常情况都考虑进去，那么程序的崩溃可能性是很小的，bug减少到最小。\n  坏处：破坏了程序的主线处理逻辑，错误处理代码散落在函数的各处，让代码可读性下降。\n  \n  举个例子，用户在线支付，我们可能的处理逻辑：\n```java\npublic String pay(Long money, Long userId) {\n\n    if (money == null || money < 0) {\n        return \"无效金额\";\n    }\n    if (userId == null) {\n        return \"无效用户\";\n    }\n\n    User user = userService.getUserById(userId);\n    if (!user.isValid()) {\n        return \"无效用户\";\n    }\n\n    Account account = accountService.getAccount(user);\n    if (account == null) {\n        return \"用户还未开通账户\";\n    }\n    if (account.getBalance() < money) {\n        return \"账户余额不足\";\n    }\n    boolean result = account.reduceBalance(money);\n    if (!result) {\n        logger.info(\"账户扣款失败\");\n        throw new AccountBalanceReduceFailException();\n    }\n    return \"success\";\n}\n```\n\n  这里面其实我们的主线逻辑就是获取用户->获取用户账户->扣减余额，但是由于充斥了过多的错误处理代码，使得各个部分割裂开了。\n\n  Java8中的`Optional`可以让我们很好的处理NULL值，但是对这种情况似乎也没有太多办法，因为我们需要的不仅仅是处理结果，对问题产生的失败原因也是我们所关心的。\n  \n  有一个与Exception结合的办法，可以约略的来使流程清晰一点点，异常可以由顶层来处理，也可以在内部处理\n  \n```java\npublic String pay(Long money, Long userId) {\n\n    if (money == null || money < 0) {\n        return \"无效金额\";\n    }\n    if (userId == null) {\n        return \"无效用户\";\n    }\n    try {\n        User user = Optional.ofNullable(userService.getUserById(userId))\n                .filter(User::isValid)\n                .orElseThrow(() -> new RuntimeException(\"无效用户\"));\n\n        Account account = Optional.ofNullable(accountService.getAccount(user))\n                .orElseThrow(() -> new RuntimeException(\"用户还未开通线上账户\"));\n        \n        if (account.getBalance() < money) {\n            return \"账户余额不足\";\n        }\n        boolean result = account.reduceBalance(money);\n        if (!result) {\n            logger.info(\"账户扣款失败\");\n            throw new AccountBalanceReduceFailException();\n        }\n    } catch (Exception e) {\n        logger.info(\"Something's wrong\", e);\n        return e.getMessage();\n    }\n    return \"success\";\n}\n```\n\n  当然可以看出，为了这么一点点的可读性，处理的方式并不优雅，甚至引入了异常，在判断账户余额处也无法优雅处理。而且处理的过程也并不连贯，由于需要在很多地方返回错误信息，而Optional类并没有提供更好的处理方式，我们不得不在每个获取外部信息的地方都`orElseThrow`一下。那我们是不是可以扩充一下Optional类来适应我们的情况呢？很可惜Optional是final类，我们只能自己新建一个`OptionalAdvance`类了，我们在`Optional`的基础上添加一点功能\n  \n```java\n//新增函数，为空抛出异常\npublic OptionalAdvance<T> ifNotPresentThrow(RuntimeException r) {\n    Objects.requireNonNull(r);\n    if (value == null) {\n        throw  r;\n    }\n    return this;\n}\n```\n\n  我们再来重写一下上面的例子：\n  \n```java\npublic String pay(Long money, Long userId) {\n    if (money == null || money < 0) {\n        return \"无效金额\";\n    }\n    if (userId == null) {\n        return \"无效用户\";\n    }\n    try {\n        return OptionalAdvance.ofNullable(userService.getUserById(userId))\n                .filter(User::isValid)\n                .ifNotPresentThrow(new RuntimeException(\"无效用户\"))\n                .map(user -> accountService.getAccount(user))\n                .ifNotPresentThrow(new RuntimeException(\"用户还未开通线上账户\"))\n                .filter(account -> account.getBalance() > money)\n                .ifNotPresentThrow(new RuntimeException(\"用户余额不足\"))\n                .filter(account -> account.reduceBalance(money))\n                .ifNotPresentThrow(new AccountBalanceReduceFailException())\n                .map(account -> \"success\")\n                .get();\n    } catch (Exception e) {\n        logger.info(\"Something's wrong\", e);\n        return e.getMessage();\n    }\n}\n```\n  这样我们将判断不符合条件的if内化为类操作，结合了异常和Optional相关的类实现了链式操作，无需那么多分支判断。\n  这只是一个小栗子，可能使用方式也并不太合适，日常编程过程中会有更多的情况需要处理，这就需要我们根据实际情况来做出合适的判断，到底是需要使用异常，还是使用分支，或者使用语言提供的一些工具来使一些操作变得更加连贯。\n  ","source":"_posts/关于防御式编程的思考.md","raw":"---\ntitle: 关于防御式编程的一点思考\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: 防御式编程\n---\n\n\n    上周看了代码大全里面的防御式编程那一章，颇有感触，结合平日里的编程实践，\n\t对自己的一些编程方式与想法记录一下，也探讨一下如何写出更安全、更有可读性的代码。\n\n## 防御式编程\n\n### 定义\n\n  防御式编程这一概念来自防御式驾驶，即要建立起这样一种思维：你永远也不知道另一位司机将要做什么，时刻提高警惕，这样才能在其他司机做出危险动作时不受伤害。防御式编程的主要思想是子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误。以怀疑的眼光看待任何外部数据，建立自己的准入机制，这样才能使自己的程序更加健壮。\n  \n### 保护数据免遭非法数据的破坏\n  \n  - 检查所有外部输入的数据，包括外部文件，读取的用户输入等\n  - 检查子程序的输入参数\n  - 决定如何处理错误的输入数据\n  \n  防御式编程的理念就是在一开始就不要引入错误。\n  \n<!--more-->\n\n### 错误处理\n  \n  在我看来使用`assert`关键字来判断数据的合法性是不合适的，这样的语句数量多了散落在程序的各处，会导致线上与线下环境的不一致。而且`assert`在断言失败后抛出error，使程序终止运行，这在企业编码实践中是不可行的，因此直接来看书中的错误处理一节。\n  \n  在碰到错误后，如何处理呢?\n  \n  - 返回中立的值。在某些场景下是很有用的，在Java中可以直接用 `Optional`类的API来做相关处理\n  - 换用下一个正确的数据。书中给出的例子是体温计，但在我们平常开发中，这种情况不怎么常见。\n  - 返回与前次相同的数据。\n  - 换用最近的合法值\n  - 记录到日志文件中。这个是必须的，需要跟其他的手段结合起来一起用。\n  - 返回一个错误码。\n  - 返回一个错误信息。 这两个通常我们结合起来使用，在rpc调用或与前端交互时，我们需要定义通用的格式来表示请求是否成功。\n  - 用妥当的方式在局部处理错误。这个要看具体的设计，具体产品的容错性。\n\n  既然有这么多的错误处理选择，我们需要在高层对错误处理进行一定的设计和规范，保证整个程序采用一致的错误处理方式。比如在遇到非法数据时，按照统一格式返回错误码和错误信息，并记录到日志中；遇到某些不可知原因抛出异常，就要约到在哪个层次来处理这些异常，并确保异常得到了处理。\n  \n### 异常\n\n  异常也是我们工具箱中一个有力的工具，但是不能滥用异常，需要审慎明智的使用。\n  \n  - 用异常通知程序的其他部分，发生了不可忽略的错误。\n  - 只有在真正例外情况下才抛出异常。\n  - 不能用异常来推卸责任。\n  - 避免在构造函数和析构函数中抛出异常，除非在同一地方将其捕获。\n  - 在恰当的抽象层次抛出异常。意为抛出本身同一层次的异常，譬如在从文件中读取员工id时，不要抛出FileNotExistedException等异常，可以封装成EmployeeNotAvailableException再向上抛出\n  - 在异常消息中加入关于导致异常发生的全部消息。也就是在构造异常时，一定要把cause带上。\n  - 避免使用空的catch。捕获异常不做任何处理是最无耻的行为，会导致后续的维护异常艰难。\n  - 创建一个集中的异常报告机制\n  - 把异常的使用标准化。创建项目异常类，规定什么时候局部处理异常，什么时候向上抛出，定义全局的异常报告机制。\n  - 考虑异常的替换方案。尽可能不使用异常，而使用错误处理机制来处理常见的错误。\n\n  异常在有些时候可以简化很多需要处理的流程，但我们还是需要根据上面的这些原则来谨慎的使用异常。\n  \n### 对防御式编程保持防御姿态\n\n  不要过度防御，过多的检查会使得项目变得臃肿，主线处理逻辑不清晰。\n  \n## 对防御式编程的一点实践\n\n  - 对所有的输入参数进行合法性校验\n  - 对所有函数的返回值进行非空、错误码等校验\n  - 对函数的处理流程就行校验，比如说必须满足同一任务不能重复处理等等。\n\n  好处：能写出很健壮的程序，如果能在编码阶段把所有的异常情况都考虑进去，那么程序的崩溃可能性是很小的，bug减少到最小。\n  坏处：破坏了程序的主线处理逻辑，错误处理代码散落在函数的各处，让代码可读性下降。\n  \n  举个例子，用户在线支付，我们可能的处理逻辑：\n```java\npublic String pay(Long money, Long userId) {\n\n    if (money == null || money < 0) {\n        return \"无效金额\";\n    }\n    if (userId == null) {\n        return \"无效用户\";\n    }\n\n    User user = userService.getUserById(userId);\n    if (!user.isValid()) {\n        return \"无效用户\";\n    }\n\n    Account account = accountService.getAccount(user);\n    if (account == null) {\n        return \"用户还未开通账户\";\n    }\n    if (account.getBalance() < money) {\n        return \"账户余额不足\";\n    }\n    boolean result = account.reduceBalance(money);\n    if (!result) {\n        logger.info(\"账户扣款失败\");\n        throw new AccountBalanceReduceFailException();\n    }\n    return \"success\";\n}\n```\n\n  这里面其实我们的主线逻辑就是获取用户->获取用户账户->扣减余额，但是由于充斥了过多的错误处理代码，使得各个部分割裂开了。\n\n  Java8中的`Optional`可以让我们很好的处理NULL值，但是对这种情况似乎也没有太多办法，因为我们需要的不仅仅是处理结果，对问题产生的失败原因也是我们所关心的。\n  \n  有一个与Exception结合的办法，可以约略的来使流程清晰一点点，异常可以由顶层来处理，也可以在内部处理\n  \n```java\npublic String pay(Long money, Long userId) {\n\n    if (money == null || money < 0) {\n        return \"无效金额\";\n    }\n    if (userId == null) {\n        return \"无效用户\";\n    }\n    try {\n        User user = Optional.ofNullable(userService.getUserById(userId))\n                .filter(User::isValid)\n                .orElseThrow(() -> new RuntimeException(\"无效用户\"));\n\n        Account account = Optional.ofNullable(accountService.getAccount(user))\n                .orElseThrow(() -> new RuntimeException(\"用户还未开通线上账户\"));\n        \n        if (account.getBalance() < money) {\n            return \"账户余额不足\";\n        }\n        boolean result = account.reduceBalance(money);\n        if (!result) {\n            logger.info(\"账户扣款失败\");\n            throw new AccountBalanceReduceFailException();\n        }\n    } catch (Exception e) {\n        logger.info(\"Something's wrong\", e);\n        return e.getMessage();\n    }\n    return \"success\";\n}\n```\n\n  当然可以看出，为了这么一点点的可读性，处理的方式并不优雅，甚至引入了异常，在判断账户余额处也无法优雅处理。而且处理的过程也并不连贯，由于需要在很多地方返回错误信息，而Optional类并没有提供更好的处理方式，我们不得不在每个获取外部信息的地方都`orElseThrow`一下。那我们是不是可以扩充一下Optional类来适应我们的情况呢？很可惜Optional是final类，我们只能自己新建一个`OptionalAdvance`类了，我们在`Optional`的基础上添加一点功能\n  \n```java\n//新增函数，为空抛出异常\npublic OptionalAdvance<T> ifNotPresentThrow(RuntimeException r) {\n    Objects.requireNonNull(r);\n    if (value == null) {\n        throw  r;\n    }\n    return this;\n}\n```\n\n  我们再来重写一下上面的例子：\n  \n```java\npublic String pay(Long money, Long userId) {\n    if (money == null || money < 0) {\n        return \"无效金额\";\n    }\n    if (userId == null) {\n        return \"无效用户\";\n    }\n    try {\n        return OptionalAdvance.ofNullable(userService.getUserById(userId))\n                .filter(User::isValid)\n                .ifNotPresentThrow(new RuntimeException(\"无效用户\"))\n                .map(user -> accountService.getAccount(user))\n                .ifNotPresentThrow(new RuntimeException(\"用户还未开通线上账户\"))\n                .filter(account -> account.getBalance() > money)\n                .ifNotPresentThrow(new RuntimeException(\"用户余额不足\"))\n                .filter(account -> account.reduceBalance(money))\n                .ifNotPresentThrow(new AccountBalanceReduceFailException())\n                .map(account -> \"success\")\n                .get();\n    } catch (Exception e) {\n        logger.info(\"Something's wrong\", e);\n        return e.getMessage();\n    }\n}\n```\n  这样我们将判断不符合条件的if内化为类操作，结合了异常和Optional相关的类实现了链式操作，无需那么多分支判断。\n  这只是一个小栗子，可能使用方式也并不太合适，日常编程过程中会有更多的情况需要处理，这就需要我们根据实际情况来做出合适的判断，到底是需要使用异常，还是使用分支，或者使用语言提供的一些工具来使一些操作变得更加连贯。\n  ","slug":"关于防御式编程的思考","published":1,"updated":"2017-12-22T05:13:33.322Z","comments":1,"photos":[],"link":"","_id":"cjbhgul0l000hn8hx3ejjgvs9","content":"<pre><code>上周看了代码大全里面的防御式编程那一章，颇有感触，结合平日里的编程实践，\n对自己的一些编程方式与想法记录一下，也探讨一下如何写出更安全、更有可读性的代码。\n</code></pre><h2 id=\"防御式编程\"><a href=\"#防御式编程\" class=\"headerlink\" title=\"防御式编程\"></a>防御式编程</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>  防御式编程这一概念来自防御式驾驶，即要建立起这样一种思维：你永远也不知道另一位司机将要做什么，时刻提高警惕，这样才能在其他司机做出危险动作时不受伤害。防御式编程的主要思想是子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误。以怀疑的眼光看待任何外部数据，建立自己的准入机制，这样才能使自己的程序更加健壮。</p>\n<h3 id=\"保护数据免遭非法数据的破坏\"><a href=\"#保护数据免遭非法数据的破坏\" class=\"headerlink\" title=\"保护数据免遭非法数据的破坏\"></a>保护数据免遭非法数据的破坏</h3><ul>\n<li>检查所有外部输入的数据，包括外部文件，读取的用户输入等</li>\n<li>检查子程序的输入参数</li>\n<li><p>决定如何处理错误的输入数据</p>\n<p>防御式编程的理念就是在一开始就不要引入错误。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>  在我看来使用<code>assert</code>关键字来判断数据的合法性是不合适的，这样的语句数量多了散落在程序的各处，会导致线上与线下环境的不一致。而且<code>assert</code>在断言失败后抛出error，使程序终止运行，这在企业编码实践中是不可行的，因此直接来看书中的错误处理一节。</p>\n<p>  在碰到错误后，如何处理呢?</p>\n<ul>\n<li>返回中立的值。在某些场景下是很有用的，在Java中可以直接用 <code>Optional</code>类的API来做相关处理</li>\n<li>换用下一个正确的数据。书中给出的例子是体温计，但在我们平常开发中，这种情况不怎么常见。</li>\n<li>返回与前次相同的数据。</li>\n<li>换用最近的合法值</li>\n<li>记录到日志文件中。这个是必须的，需要跟其他的手段结合起来一起用。</li>\n<li>返回一个错误码。</li>\n<li>返回一个错误信息。 这两个通常我们结合起来使用，在rpc调用或与前端交互时，我们需要定义通用的格式来表示请求是否成功。</li>\n<li><p>用妥当的方式在局部处理错误。这个要看具体的设计，具体产品的容错性。</p>\n<p>既然有这么多的错误处理选择，我们需要在高层对错误处理进行一定的设计和规范，保证整个程序采用一致的错误处理方式。比如在遇到非法数据时，按照统一格式返回错误码和错误信息，并记录到日志中；遇到某些不可知原因抛出异常，就要约到在哪个层次来处理这些异常，并确保异常得到了处理。</p>\n</li>\n</ul>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>  异常也是我们工具箱中一个有力的工具，但是不能滥用异常，需要审慎明智的使用。</p>\n<ul>\n<li>用异常通知程序的其他部分，发生了不可忽略的错误。</li>\n<li>只有在真正例外情况下才抛出异常。</li>\n<li>不能用异常来推卸责任。</li>\n<li>避免在构造函数和析构函数中抛出异常，除非在同一地方将其捕获。</li>\n<li>在恰当的抽象层次抛出异常。意为抛出本身同一层次的异常，譬如在从文件中读取员工id时，不要抛出FileNotExistedException等异常，可以封装成EmployeeNotAvailableException再向上抛出</li>\n<li>在异常消息中加入关于导致异常发生的全部消息。也就是在构造异常时，一定要把cause带上。</li>\n<li>避免使用空的catch。捕获异常不做任何处理是最无耻的行为，会导致后续的维护异常艰难。</li>\n<li>创建一个集中的异常报告机制</li>\n<li>把异常的使用标准化。创建项目异常类，规定什么时候局部处理异常，什么时候向上抛出，定义全局的异常报告机制。</li>\n<li><p>考虑异常的替换方案。尽可能不使用异常，而使用错误处理机制来处理常见的错误。</p>\n<p>异常在有些时候可以简化很多需要处理的流程，但我们还是需要根据上面的这些原则来谨慎的使用异常。</p>\n</li>\n</ul>\n<h3 id=\"对防御式编程保持防御姿态\"><a href=\"#对防御式编程保持防御姿态\" class=\"headerlink\" title=\"对防御式编程保持防御姿态\"></a>对防御式编程保持防御姿态</h3><p>  不要过度防御，过多的检查会使得项目变得臃肿，主线处理逻辑不清晰。</p>\n<h2 id=\"对防御式编程的一点实践\"><a href=\"#对防御式编程的一点实践\" class=\"headerlink\" title=\"对防御式编程的一点实践\"></a>对防御式编程的一点实践</h2><ul>\n<li>对所有的输入参数进行合法性校验</li>\n<li>对所有函数的返回值进行非空、错误码等校验</li>\n<li><p>对函数的处理流程就行校验，比如说必须满足同一任务不能重复处理等等。</p>\n<p>好处：能写出很健壮的程序，如果能在编码阶段把所有的异常情况都考虑进去，那么程序的崩溃可能性是很小的，bug减少到最小。<br>坏处：破坏了程序的主线处理逻辑，错误处理代码散落在函数的各处，让代码可读性下降。</p>\n<p>举个例子，用户在线支付，我们可能的处理逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pay</span><span class=\"params\">(Long money, Long userId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money == <span class=\"keyword\">null</span> || money &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效金额\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userId == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = userService.getUserById(userId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!user.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Account account = accountService.getAccount(user);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (account == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"用户还未开通账户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (account.getBalance() &lt; money) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"账户余额不足\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = account.reduceBalance(money);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"账户扣款失败\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AccountBalanceReduceFailException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面其实我们的主线逻辑就是获取用户-&gt;获取用户账户-&gt;扣减余额，但是由于充斥了过多的错误处理代码，使得各个部分割裂开了。</p>\n<p>Java8中的<code>Optional</code>可以让我们很好的处理NULL值，但是对这种情况似乎也没有太多办法，因为我们需要的不仅仅是处理结果，对问题产生的失败原因也是我们所关心的。</p>\n<p>有一个与Exception结合的办法，可以约略的来使流程清晰一点点，异常可以由顶层来处理，也可以在内部处理</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pay</span><span class=\"params\">(Long money, Long userId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money == <span class=\"keyword\">null</span> || money &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效金额\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userId == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        User user = Optional.ofNullable(userService.getUserById(userId))</span><br><span class=\"line\">                .filter(User::isValid)</span><br><span class=\"line\">                .orElseThrow(() -&gt; <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"无效用户\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        Account account = Optional.ofNullable(accountService.getAccount(user))</span><br><span class=\"line\">                .orElseThrow(() -&gt; <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"用户还未开通线上账户\"</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (account.getBalance() &lt; money) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"账户余额不足\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = account.reduceBalance(money);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"账户扣款失败\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AccountBalanceReduceFailException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Something's wrong\"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  当然可以看出，为了这么一点点的可读性，处理的方式并不优雅，甚至引入了异常，在判断账户余额处也无法优雅处理。而且处理的过程也并不连贯，由于需要在很多地方返回错误信息，而Optional类并没有提供更好的处理方式，我们不得不在每个获取外部信息的地方都<code>orElseThrow</code>一下。那我们是不是可以扩充一下Optional类来适应我们的情况呢？很可惜Optional是final类，我们只能自己新建一个<code>OptionalAdvance</code>类了，我们在<code>Optional</code>的基础上添加一点功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新增函数，为空抛出异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> OptionalAdvance&lt;T&gt; <span class=\"title\">ifNotPresentThrow</span><span class=\"params\">(RuntimeException r)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span>  r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  我们再来重写一下上面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pay</span><span class=\"params\">(Long money, Long userId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money == <span class=\"keyword\">null</span> || money &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效金额\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userId == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> OptionalAdvance.ofNullable(userService.getUserById(userId))</span><br><span class=\"line\">                .filter(User::isValid)</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"无效用户\"</span>))</span><br><span class=\"line\">                .map(user -&gt; accountService.getAccount(user))</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"用户还未开通线上账户\"</span>))</span><br><span class=\"line\">                .filter(account -&gt; account.getBalance() &gt; money)</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"用户余额不足\"</span>))</span><br><span class=\"line\">                .filter(account -&gt; account.reduceBalance(money))</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> AccountBalanceReduceFailException())</span><br><span class=\"line\">                .map(account -&gt; <span class=\"string\">\"success\"</span>)</span><br><span class=\"line\">                .get();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Something's wrong\"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  这样我们将判断不符合条件的if内化为类操作，结合了异常和Optional相关的类实现了链式操作，无需那么多分支判断。<br>  这只是一个小栗子，可能使用方式也并不太合适，日常编程过程中会有更多的情况需要处理，这就需要我们根据实际情况来做出合适的判断，到底是需要使用异常，还是使用分支，或者使用语言提供的一些工具来使一些操作变得更加连贯。</p>\n","site":{"data":{}},"excerpt":"<pre><code>上周看了代码大全里面的防御式编程那一章，颇有感触，结合平日里的编程实践，\n对自己的一些编程方式与想法记录一下，也探讨一下如何写出更安全、更有可读性的代码。\n</code></pre><h2 id=\"防御式编程\"><a href=\"#防御式编程\" class=\"headerlink\" title=\"防御式编程\"></a>防御式编程</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>  防御式编程这一概念来自防御式驾驶，即要建立起这样一种思维：你永远也不知道另一位司机将要做什么，时刻提高警惕，这样才能在其他司机做出危险动作时不受伤害。防御式编程的主要思想是子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误。以怀疑的眼光看待任何外部数据，建立自己的准入机制，这样才能使自己的程序更加健壮。</p>\n<h3 id=\"保护数据免遭非法数据的破坏\"><a href=\"#保护数据免遭非法数据的破坏\" class=\"headerlink\" title=\"保护数据免遭非法数据的破坏\"></a>保护数据免遭非法数据的破坏</h3><ul>\n<li>检查所有外部输入的数据，包括外部文件，读取的用户输入等</li>\n<li>检查子程序的输入参数</li>\n<li><p>决定如何处理错误的输入数据</p>\n<p>防御式编程的理念就是在一开始就不要引入错误。</p>\n</li>\n</ul>","more":"<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>  在我看来使用<code>assert</code>关键字来判断数据的合法性是不合适的，这样的语句数量多了散落在程序的各处，会导致线上与线下环境的不一致。而且<code>assert</code>在断言失败后抛出error，使程序终止运行，这在企业编码实践中是不可行的，因此直接来看书中的错误处理一节。</p>\n<p>  在碰到错误后，如何处理呢?</p>\n<ul>\n<li>返回中立的值。在某些场景下是很有用的，在Java中可以直接用 <code>Optional</code>类的API来做相关处理</li>\n<li>换用下一个正确的数据。书中给出的例子是体温计，但在我们平常开发中，这种情况不怎么常见。</li>\n<li>返回与前次相同的数据。</li>\n<li>换用最近的合法值</li>\n<li>记录到日志文件中。这个是必须的，需要跟其他的手段结合起来一起用。</li>\n<li>返回一个错误码。</li>\n<li>返回一个错误信息。 这两个通常我们结合起来使用，在rpc调用或与前端交互时，我们需要定义通用的格式来表示请求是否成功。</li>\n<li><p>用妥当的方式在局部处理错误。这个要看具体的设计，具体产品的容错性。</p>\n<p>既然有这么多的错误处理选择，我们需要在高层对错误处理进行一定的设计和规范，保证整个程序采用一致的错误处理方式。比如在遇到非法数据时，按照统一格式返回错误码和错误信息，并记录到日志中；遇到某些不可知原因抛出异常，就要约到在哪个层次来处理这些异常，并确保异常得到了处理。</p>\n</li>\n</ul>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>  异常也是我们工具箱中一个有力的工具，但是不能滥用异常，需要审慎明智的使用。</p>\n<ul>\n<li>用异常通知程序的其他部分，发生了不可忽略的错误。</li>\n<li>只有在真正例外情况下才抛出异常。</li>\n<li>不能用异常来推卸责任。</li>\n<li>避免在构造函数和析构函数中抛出异常，除非在同一地方将其捕获。</li>\n<li>在恰当的抽象层次抛出异常。意为抛出本身同一层次的异常，譬如在从文件中读取员工id时，不要抛出FileNotExistedException等异常，可以封装成EmployeeNotAvailableException再向上抛出</li>\n<li>在异常消息中加入关于导致异常发生的全部消息。也就是在构造异常时，一定要把cause带上。</li>\n<li>避免使用空的catch。捕获异常不做任何处理是最无耻的行为，会导致后续的维护异常艰难。</li>\n<li>创建一个集中的异常报告机制</li>\n<li>把异常的使用标准化。创建项目异常类，规定什么时候局部处理异常，什么时候向上抛出，定义全局的异常报告机制。</li>\n<li><p>考虑异常的替换方案。尽可能不使用异常，而使用错误处理机制来处理常见的错误。</p>\n<p>异常在有些时候可以简化很多需要处理的流程，但我们还是需要根据上面的这些原则来谨慎的使用异常。</p>\n</li>\n</ul>\n<h3 id=\"对防御式编程保持防御姿态\"><a href=\"#对防御式编程保持防御姿态\" class=\"headerlink\" title=\"对防御式编程保持防御姿态\"></a>对防御式编程保持防御姿态</h3><p>  不要过度防御，过多的检查会使得项目变得臃肿，主线处理逻辑不清晰。</p>\n<h2 id=\"对防御式编程的一点实践\"><a href=\"#对防御式编程的一点实践\" class=\"headerlink\" title=\"对防御式编程的一点实践\"></a>对防御式编程的一点实践</h2><ul>\n<li>对所有的输入参数进行合法性校验</li>\n<li>对所有函数的返回值进行非空、错误码等校验</li>\n<li><p>对函数的处理流程就行校验，比如说必须满足同一任务不能重复处理等等。</p>\n<p>好处：能写出很健壮的程序，如果能在编码阶段把所有的异常情况都考虑进去，那么程序的崩溃可能性是很小的，bug减少到最小。<br>坏处：破坏了程序的主线处理逻辑，错误处理代码散落在函数的各处，让代码可读性下降。</p>\n<p>举个例子，用户在线支付，我们可能的处理逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pay</span><span class=\"params\">(Long money, Long userId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money == <span class=\"keyword\">null</span> || money &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效金额\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userId == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = userService.getUserById(userId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!user.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Account account = accountService.getAccount(user);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (account == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"用户还未开通账户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (account.getBalance() &lt; money) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"账户余额不足\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = account.reduceBalance(money);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"账户扣款失败\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AccountBalanceReduceFailException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面其实我们的主线逻辑就是获取用户-&gt;获取用户账户-&gt;扣减余额，但是由于充斥了过多的错误处理代码，使得各个部分割裂开了。</p>\n<p>Java8中的<code>Optional</code>可以让我们很好的处理NULL值，但是对这种情况似乎也没有太多办法，因为我们需要的不仅仅是处理结果，对问题产生的失败原因也是我们所关心的。</p>\n<p>有一个与Exception结合的办法，可以约略的来使流程清晰一点点，异常可以由顶层来处理，也可以在内部处理</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pay</span><span class=\"params\">(Long money, Long userId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money == <span class=\"keyword\">null</span> || money &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效金额\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userId == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        User user = Optional.ofNullable(userService.getUserById(userId))</span><br><span class=\"line\">                .filter(User::isValid)</span><br><span class=\"line\">                .orElseThrow(() -&gt; <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"无效用户\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        Account account = Optional.ofNullable(accountService.getAccount(user))</span><br><span class=\"line\">                .orElseThrow(() -&gt; <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"用户还未开通线上账户\"</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (account.getBalance() &lt; money) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"账户余额不足\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = account.reduceBalance(money);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"账户扣款失败\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AccountBalanceReduceFailException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Something's wrong\"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  当然可以看出，为了这么一点点的可读性，处理的方式并不优雅，甚至引入了异常，在判断账户余额处也无法优雅处理。而且处理的过程也并不连贯，由于需要在很多地方返回错误信息，而Optional类并没有提供更好的处理方式，我们不得不在每个获取外部信息的地方都<code>orElseThrow</code>一下。那我们是不是可以扩充一下Optional类来适应我们的情况呢？很可惜Optional是final类，我们只能自己新建一个<code>OptionalAdvance</code>类了，我们在<code>Optional</code>的基础上添加一点功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新增函数，为空抛出异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> OptionalAdvance&lt;T&gt; <span class=\"title\">ifNotPresentThrow</span><span class=\"params\">(RuntimeException r)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span>  r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  我们再来重写一下上面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pay</span><span class=\"params\">(Long money, Long userId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money == <span class=\"keyword\">null</span> || money &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效金额\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userId == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"无效用户\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> OptionalAdvance.ofNullable(userService.getUserById(userId))</span><br><span class=\"line\">                .filter(User::isValid)</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"无效用户\"</span>))</span><br><span class=\"line\">                .map(user -&gt; accountService.getAccount(user))</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"用户还未开通线上账户\"</span>))</span><br><span class=\"line\">                .filter(account -&gt; account.getBalance() &gt; money)</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"用户余额不足\"</span>))</span><br><span class=\"line\">                .filter(account -&gt; account.reduceBalance(money))</span><br><span class=\"line\">                .ifNotPresentThrow(<span class=\"keyword\">new</span> AccountBalanceReduceFailException())</span><br><span class=\"line\">                .map(account -&gt; <span class=\"string\">\"success\"</span>)</span><br><span class=\"line\">                .get();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Something's wrong\"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  这样我们将判断不符合条件的if内化为类操作，结合了异常和Optional相关的类实现了链式操作，无需那么多分支判断。<br>  这只是一个小栗子，可能使用方式也并不太合适，日常编程过程中会有更多的情况需要处理，这就需要我们根据实际情况来做出合适的判断，到底是需要使用异常，还是使用分支，或者使用语言提供的一些工具来使一些操作变得更加连贯。</p>"},{"title":"卓有成效的管理者","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\nQ:\n\t1:何为有效性？\n\t2：如何做到有效性？\n\t3：何为管理者，如何做一个有效的管理者？\n\t4：经过何种训练，一个人才能具备有效性\n\t\n作为一个有效的管理者，必须在思想上养成如下的习惯：\n\t1：知道如何利用自己的时间\n\t2：注意使自己的努力产生必要的成果，而不是工作本身，重视对外界的贡献\n\t3：把工作建立在优势上，自己的，上下级的优势\n\t4：精力集中于少数领域\n\t5：善于做出有效决策\n\n才华本身并不等于成就。\n\n<!--more-->\n\n管理者能否管理好别人从来没有被真正验证过，但管理者却完全可以管理好自己。管理工作在很大程度上是需要身体力行的。\n卓有成效是可以学会的。\n一个人的才能，只有通过有条理有系统的工作，才有可能产生效益\n\n为什么要研究成效？\n\t以前是体力工作者居多，研究的是如何提高工作效率，\n\t现在知识工作者变多，需要研究如何做“对”的事情，才能使工作有效\n\n知识工作者不能用数量来衡量，也不能用成本来衡量，唯一标准就是结果。\n\n四类非其本人控制的难题\n\t1：管理者的时间往往只属于别人，而不属于自己\n\t2：管理者往往被迫忙于“日常工作”，除非他们敢于采取行动来改变周围的一切\n\t3：管理者本身处于一个组织之中，只有当别人能够利用管理者的贡献时，管理者才算有效\n\t\t别人：其他部门的人，上司，下属\n\t4：管理者身处组织内部，受到组织的局限\n\t\t人数越少，规模越小，内部的工作越轻，组织就越趋近于完美（效率）\n\t\t对于外部的情况，真正重要的不是趋势，而是趋势的转变\n\t\t当越来越依赖电脑分析的事实时，就失去了觉察力，对外部世界的感知\n\t\t\n所谓有效性，就是使能力和知识资源能够产生更多更好成果的一种手段。\n\n记录时间-》改变习惯\n\n授权：把可由别人做的事交付给别人，这样才能做自己真正要做的事\n\n\n\n有效的人际关系，有以下四个基本要求：\n1.互相沟通\n2.团队合作\n3.自我发展\n4.培养他人","source":"_posts/卓有成效的管理者.md","raw":"---\ntitle: 卓有成效的管理者\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [卓有成效, 读书笔记]\n---\n\nQ:\n\t1:何为有效性？\n\t2：如何做到有效性？\n\t3：何为管理者，如何做一个有效的管理者？\n\t4：经过何种训练，一个人才能具备有效性\n\t\n作为一个有效的管理者，必须在思想上养成如下的习惯：\n\t1：知道如何利用自己的时间\n\t2：注意使自己的努力产生必要的成果，而不是工作本身，重视对外界的贡献\n\t3：把工作建立在优势上，自己的，上下级的优势\n\t4：精力集中于少数领域\n\t5：善于做出有效决策\n\n才华本身并不等于成就。\n\n<!--more-->\n\n管理者能否管理好别人从来没有被真正验证过，但管理者却完全可以管理好自己。管理工作在很大程度上是需要身体力行的。\n卓有成效是可以学会的。\n一个人的才能，只有通过有条理有系统的工作，才有可能产生效益\n\n为什么要研究成效？\n\t以前是体力工作者居多，研究的是如何提高工作效率，\n\t现在知识工作者变多，需要研究如何做“对”的事情，才能使工作有效\n\n知识工作者不能用数量来衡量，也不能用成本来衡量，唯一标准就是结果。\n\n四类非其本人控制的难题\n\t1：管理者的时间往往只属于别人，而不属于自己\n\t2：管理者往往被迫忙于“日常工作”，除非他们敢于采取行动来改变周围的一切\n\t3：管理者本身处于一个组织之中，只有当别人能够利用管理者的贡献时，管理者才算有效\n\t\t别人：其他部门的人，上司，下属\n\t4：管理者身处组织内部，受到组织的局限\n\t\t人数越少，规模越小，内部的工作越轻，组织就越趋近于完美（效率）\n\t\t对于外部的情况，真正重要的不是趋势，而是趋势的转变\n\t\t当越来越依赖电脑分析的事实时，就失去了觉察力，对外部世界的感知\n\t\t\n所谓有效性，就是使能力和知识资源能够产生更多更好成果的一种手段。\n\n记录时间-》改变习惯\n\n授权：把可由别人做的事交付给别人，这样才能做自己真正要做的事\n\n\n\n有效的人际关系，有以下四个基本要求：\n1.互相沟通\n2.团队合作\n3.自我发展\n4.培养他人","slug":"卓有成效的管理者","published":1,"updated":"2017-12-22T05:13:28.474Z","comments":1,"photos":[],"link":"","_id":"cjbhgul0p000jn8hxbgg6uauf","content":"<p>Q:<br>    1:何为有效性？<br>    2：如何做到有效性？<br>    3：何为管理者，如何做一个有效的管理者？<br>    4：经过何种训练，一个人才能具备有效性</p>\n<p>作为一个有效的管理者，必须在思想上养成如下的习惯：<br>    1：知道如何利用自己的时间<br>    2：注意使自己的努力产生必要的成果，而不是工作本身，重视对外界的贡献<br>    3：把工作建立在优势上，自己的，上下级的优势<br>    4：精力集中于少数领域<br>    5：善于做出有效决策</p>\n<p>才华本身并不等于成就。</p>\n<a id=\"more\"></a>\n<p>管理者能否管理好别人从来没有被真正验证过，但管理者却完全可以管理好自己。管理工作在很大程度上是需要身体力行的。<br>卓有成效是可以学会的。<br>一个人的才能，只有通过有条理有系统的工作，才有可能产生效益</p>\n<p>为什么要研究成效？<br>    以前是体力工作者居多，研究的是如何提高工作效率，<br>    现在知识工作者变多，需要研究如何做“对”的事情，才能使工作有效</p>\n<p>知识工作者不能用数量来衡量，也不能用成本来衡量，唯一标准就是结果。</p>\n<p>四类非其本人控制的难题<br>    1：管理者的时间往往只属于别人，而不属于自己<br>    2：管理者往往被迫忙于“日常工作”，除非他们敢于采取行动来改变周围的一切<br>    3：管理者本身处于一个组织之中，只有当别人能够利用管理者的贡献时，管理者才算有效<br>        别人：其他部门的人，上司，下属<br>    4：管理者身处组织内部，受到组织的局限<br>        人数越少，规模越小，内部的工作越轻，组织就越趋近于完美（效率）<br>        对于外部的情况，真正重要的不是趋势，而是趋势的转变<br>        当越来越依赖电脑分析的事实时，就失去了觉察力，对外部世界的感知</p>\n<p>所谓有效性，就是使能力和知识资源能够产生更多更好成果的一种手段。</p>\n<p>记录时间-》改变习惯</p>\n<p>授权：把可由别人做的事交付给别人，这样才能做自己真正要做的事</p>\n<p>有效的人际关系，有以下四个基本要求：<br>1.互相沟通<br>2.团队合作<br>3.自我发展<br>4.培养他人</p>\n","site":{"data":{}},"excerpt":"<p>Q:<br>    1:何为有效性？<br>    2：如何做到有效性？<br>    3：何为管理者，如何做一个有效的管理者？<br>    4：经过何种训练，一个人才能具备有效性</p>\n<p>作为一个有效的管理者，必须在思想上养成如下的习惯：<br>    1：知道如何利用自己的时间<br>    2：注意使自己的努力产生必要的成果，而不是工作本身，重视对外界的贡献<br>    3：把工作建立在优势上，自己的，上下级的优势<br>    4：精力集中于少数领域<br>    5：善于做出有效决策</p>\n<p>才华本身并不等于成就。</p>","more":"<p>管理者能否管理好别人从来没有被真正验证过，但管理者却完全可以管理好自己。管理工作在很大程度上是需要身体力行的。<br>卓有成效是可以学会的。<br>一个人的才能，只有通过有条理有系统的工作，才有可能产生效益</p>\n<p>为什么要研究成效？<br>    以前是体力工作者居多，研究的是如何提高工作效率，<br>    现在知识工作者变多，需要研究如何做“对”的事情，才能使工作有效</p>\n<p>知识工作者不能用数量来衡量，也不能用成本来衡量，唯一标准就是结果。</p>\n<p>四类非其本人控制的难题<br>    1：管理者的时间往往只属于别人，而不属于自己<br>    2：管理者往往被迫忙于“日常工作”，除非他们敢于采取行动来改变周围的一切<br>    3：管理者本身处于一个组织之中，只有当别人能够利用管理者的贡献时，管理者才算有效<br>        别人：其他部门的人，上司，下属<br>    4：管理者身处组织内部，受到组织的局限<br>        人数越少，规模越小，内部的工作越轻，组织就越趋近于完美（效率）<br>        对于外部的情况，真正重要的不是趋势，而是趋势的转变<br>        当越来越依赖电脑分析的事实时，就失去了觉察力，对外部世界的感知</p>\n<p>所谓有效性，就是使能力和知识资源能够产生更多更好成果的一种手段。</p>\n<p>记录时间-》改变习惯</p>\n<p>授权：把可由别人做的事交付给别人，这样才能做自己真正要做的事</p>\n<p>有效的人际关系，有以下四个基本要求：<br>1.互相沟通<br>2.团队合作<br>3.自我发展<br>4.培养他人</p>"},{"title":"单元测试思考","date":"2017-12-21T10:27:44.000Z","layout":"tag","_content":"\n\n刚开始工作的时候对单元测试是一种神秘主义，觉得测试很好，但不知道如何开始。团队里也没人去写单元测试，偶尔有个也是写的集成测试，用Spring的test，将所有依赖注入进来，然后`System.out.println`输出肉眼观测数据是否符合要求，这让我对测试有向往，但是又嫌麻烦，毕竟这样测试写了很多的代码，但是速度上、准确性上都达不到要求。\n\n就这样一直手动测试了很长时间，也听多了单元测试，自动化测试等等名词，却一直不得其门而入。买过一本单元测试相关的书，看完了，但就是没有开窍。去开发者头条上搜相关测试主题，讲的都是一些思想上的，对我目前的疑惑却没有什么帮助，毕竟我还没有入门。\n\n后来忘了在哪又看到了单元测试的定义：是对一个模块，一个类或一个函数的正确性做检测的测试工作。突然有点明白了如何来写单元测试，以往一直迷惑这么多依赖该怎么办，覆盖不到全部执行路径怎么办，看到`一个函数`这四个字我找到了答案：一个函数依赖不会很多，可以使用mock来解决；一个函数的全部执行路径也就那么多，每种情况都考虑到也不会很多；前面说的使用`System.out.println`肉眼测试，也因为函数只有一个返回值而可以使用`Assert`类来断言来判断正确性。关键就在于单元，一开始把目光着眼在一个服务类上，依赖十几个服务，几十个外部函数调用，使我望而却步，而把焦点放到函数上，一来可以避免自己写超大的函数，二来依赖少，写单元测试的阻力变小了。\n\n<!--more-->\n\n## 单元测试的目的\n\n很多人会说测试的目的当然是保证程序的正确性，恰恰相反，作为开发和测试，我们测试的目的是为了找出程序中包含的错误，也就是测试是为了弄垮软件，测试没有发现错误说明测试用例是无效的或不完整的(Code complete).\n\n你必须期望代码里有错误，期望发现错误的那个人是你而不是其他人。\n\n## 单元测试的完整性\n\n在这Code Complete中给了我们一个测试中用例的最少数量计算方法：\n\n1. 通过子程序的直路，开始时记1\n2. 遇到关键字if, while, for, do, and, or及其等价物时加1\n3. 遇到每一个case就加1，如果没有缺省情况，再加1\n\n按照这种方法，基础的代码路径覆盖已经达到了，但在复杂程序里譬如for中包含多个if的情况需要添加更多的测试用例，CC中给出了数据流测试，这里不再赘述，因为我觉得如果你的函数连基础测试用例都十几个的话，你该考虑的不是添加更多的测试，而是如何拆分这个函数了。\n\n## 单元测试中的典型错误\n\n1. off-by-one错误\n2. 边界值(刚好等于max，比max小1，比max大1)\n3. 变量初始化(特别是循环中\n4. 测试本身的错误\n\n\n## 结语\n\n单元测试是开发保证自己工作质量的一个有力工具，在我看来，写单元测试要比靠手工去测试花费的时间少，效率高，修改方便。甚至在数据构造上，单元测试也比手工测试要方便快捷，毕竟页面上每次你都要把需要的数据都准备一遍，在代码里你需要修改的可能也就是两三处地方。","source":"_posts/单元测试思考.md","raw":"---\ntitle: 单元测试思考\ndate: 2017-12-21 18:27:44\nlayout: tag\ntags: [单元测试, 测试]\n---\n\n\n刚开始工作的时候对单元测试是一种神秘主义，觉得测试很好，但不知道如何开始。团队里也没人去写单元测试，偶尔有个也是写的集成测试，用Spring的test，将所有依赖注入进来，然后`System.out.println`输出肉眼观测数据是否符合要求，这让我对测试有向往，但是又嫌麻烦，毕竟这样测试写了很多的代码，但是速度上、准确性上都达不到要求。\n\n就这样一直手动测试了很长时间，也听多了单元测试，自动化测试等等名词，却一直不得其门而入。买过一本单元测试相关的书，看完了，但就是没有开窍。去开发者头条上搜相关测试主题，讲的都是一些思想上的，对我目前的疑惑却没有什么帮助，毕竟我还没有入门。\n\n后来忘了在哪又看到了单元测试的定义：是对一个模块，一个类或一个函数的正确性做检测的测试工作。突然有点明白了如何来写单元测试，以往一直迷惑这么多依赖该怎么办，覆盖不到全部执行路径怎么办，看到`一个函数`这四个字我找到了答案：一个函数依赖不会很多，可以使用mock来解决；一个函数的全部执行路径也就那么多，每种情况都考虑到也不会很多；前面说的使用`System.out.println`肉眼测试，也因为函数只有一个返回值而可以使用`Assert`类来断言来判断正确性。关键就在于单元，一开始把目光着眼在一个服务类上，依赖十几个服务，几十个外部函数调用，使我望而却步，而把焦点放到函数上，一来可以避免自己写超大的函数，二来依赖少，写单元测试的阻力变小了。\n\n<!--more-->\n\n## 单元测试的目的\n\n很多人会说测试的目的当然是保证程序的正确性，恰恰相反，作为开发和测试，我们测试的目的是为了找出程序中包含的错误，也就是测试是为了弄垮软件，测试没有发现错误说明测试用例是无效的或不完整的(Code complete).\n\n你必须期望代码里有错误，期望发现错误的那个人是你而不是其他人。\n\n## 单元测试的完整性\n\n在这Code Complete中给了我们一个测试中用例的最少数量计算方法：\n\n1. 通过子程序的直路，开始时记1\n2. 遇到关键字if, while, for, do, and, or及其等价物时加1\n3. 遇到每一个case就加1，如果没有缺省情况，再加1\n\n按照这种方法，基础的代码路径覆盖已经达到了，但在复杂程序里譬如for中包含多个if的情况需要添加更多的测试用例，CC中给出了数据流测试，这里不再赘述，因为我觉得如果你的函数连基础测试用例都十几个的话，你该考虑的不是添加更多的测试，而是如何拆分这个函数了。\n\n## 单元测试中的典型错误\n\n1. off-by-one错误\n2. 边界值(刚好等于max，比max小1，比max大1)\n3. 变量初始化(特别是循环中\n4. 测试本身的错误\n\n\n## 结语\n\n单元测试是开发保证自己工作质量的一个有力工具，在我看来，写单元测试要比靠手工去测试花费的时间少，效率高，修改方便。甚至在数据构造上，单元测试也比手工测试要方便快捷，毕竟页面上每次你都要把需要的数据都准备一遍，在代码里你需要修改的可能也就是两三处地方。","slug":"单元测试思考","published":1,"updated":"2017-12-22T05:13:35.632Z","comments":1,"photos":[],"link":"","_id":"cjbhgul0t000ln8hx6e7rpf6m","content":"<p>刚开始工作的时候对单元测试是一种神秘主义，觉得测试很好，但不知道如何开始。团队里也没人去写单元测试，偶尔有个也是写的集成测试，用Spring的test，将所有依赖注入进来，然后<code>System.out.println</code>输出肉眼观测数据是否符合要求，这让我对测试有向往，但是又嫌麻烦，毕竟这样测试写了很多的代码，但是速度上、准确性上都达不到要求。</p>\n<p>就这样一直手动测试了很长时间，也听多了单元测试，自动化测试等等名词，却一直不得其门而入。买过一本单元测试相关的书，看完了，但就是没有开窍。去开发者头条上搜相关测试主题，讲的都是一些思想上的，对我目前的疑惑却没有什么帮助，毕竟我还没有入门。</p>\n<p>后来忘了在哪又看到了单元测试的定义：是对一个模块，一个类或一个函数的正确性做检测的测试工作。突然有点明白了如何来写单元测试，以往一直迷惑这么多依赖该怎么办，覆盖不到全部执行路径怎么办，看到<code>一个函数</code>这四个字我找到了答案：一个函数依赖不会很多，可以使用mock来解决；一个函数的全部执行路径也就那么多，每种情况都考虑到也不会很多；前面说的使用<code>System.out.println</code>肉眼测试，也因为函数只有一个返回值而可以使用<code>Assert</code>类来断言来判断正确性。关键就在于单元，一开始把目光着眼在一个服务类上，依赖十几个服务，几十个外部函数调用，使我望而却步，而把焦点放到函数上，一来可以避免自己写超大的函数，二来依赖少，写单元测试的阻力变小了。</p>\n<a id=\"more\"></a>\n<h2 id=\"单元测试的目的\"><a href=\"#单元测试的目的\" class=\"headerlink\" title=\"单元测试的目的\"></a>单元测试的目的</h2><p>很多人会说测试的目的当然是保证程序的正确性，恰恰相反，作为开发和测试，我们测试的目的是为了找出程序中包含的错误，也就是测试是为了弄垮软件，测试没有发现错误说明测试用例是无效的或不完整的(Code complete).</p>\n<p>你必须期望代码里有错误，期望发现错误的那个人是你而不是其他人。</p>\n<h2 id=\"单元测试的完整性\"><a href=\"#单元测试的完整性\" class=\"headerlink\" title=\"单元测试的完整性\"></a>单元测试的完整性</h2><p>在这Code Complete中给了我们一个测试中用例的最少数量计算方法：</p>\n<ol>\n<li>通过子程序的直路，开始时记1</li>\n<li>遇到关键字if, while, for, do, and, or及其等价物时加1</li>\n<li>遇到每一个case就加1，如果没有缺省情况，再加1</li>\n</ol>\n<p>按照这种方法，基础的代码路径覆盖已经达到了，但在复杂程序里譬如for中包含多个if的情况需要添加更多的测试用例，CC中给出了数据流测试，这里不再赘述，因为我觉得如果你的函数连基础测试用例都十几个的话，你该考虑的不是添加更多的测试，而是如何拆分这个函数了。</p>\n<h2 id=\"单元测试中的典型错误\"><a href=\"#单元测试中的典型错误\" class=\"headerlink\" title=\"单元测试中的典型错误\"></a>单元测试中的典型错误</h2><ol>\n<li>off-by-one错误</li>\n<li>边界值(刚好等于max，比max小1，比max大1)</li>\n<li>变量初始化(特别是循环中</li>\n<li>测试本身的错误</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>单元测试是开发保证自己工作质量的一个有力工具，在我看来，写单元测试要比靠手工去测试花费的时间少，效率高，修改方便。甚至在数据构造上，单元测试也比手工测试要方便快捷，毕竟页面上每次你都要把需要的数据都准备一遍，在代码里你需要修改的可能也就是两三处地方。</p>\n","site":{"data":{}},"excerpt":"<p>刚开始工作的时候对单元测试是一种神秘主义，觉得测试很好，但不知道如何开始。团队里也没人去写单元测试，偶尔有个也是写的集成测试，用Spring的test，将所有依赖注入进来，然后<code>System.out.println</code>输出肉眼观测数据是否符合要求，这让我对测试有向往，但是又嫌麻烦，毕竟这样测试写了很多的代码，但是速度上、准确性上都达不到要求。</p>\n<p>就这样一直手动测试了很长时间，也听多了单元测试，自动化测试等等名词，却一直不得其门而入。买过一本单元测试相关的书，看完了，但就是没有开窍。去开发者头条上搜相关测试主题，讲的都是一些思想上的，对我目前的疑惑却没有什么帮助，毕竟我还没有入门。</p>\n<p>后来忘了在哪又看到了单元测试的定义：是对一个模块，一个类或一个函数的正确性做检测的测试工作。突然有点明白了如何来写单元测试，以往一直迷惑这么多依赖该怎么办，覆盖不到全部执行路径怎么办，看到<code>一个函数</code>这四个字我找到了答案：一个函数依赖不会很多，可以使用mock来解决；一个函数的全部执行路径也就那么多，每种情况都考虑到也不会很多；前面说的使用<code>System.out.println</code>肉眼测试，也因为函数只有一个返回值而可以使用<code>Assert</code>类来断言来判断正确性。关键就在于单元，一开始把目光着眼在一个服务类上，依赖十几个服务，几十个外部函数调用，使我望而却步，而把焦点放到函数上，一来可以避免自己写超大的函数，二来依赖少，写单元测试的阻力变小了。</p>","more":"<h2 id=\"单元测试的目的\"><a href=\"#单元测试的目的\" class=\"headerlink\" title=\"单元测试的目的\"></a>单元测试的目的</h2><p>很多人会说测试的目的当然是保证程序的正确性，恰恰相反，作为开发和测试，我们测试的目的是为了找出程序中包含的错误，也就是测试是为了弄垮软件，测试没有发现错误说明测试用例是无效的或不完整的(Code complete).</p>\n<p>你必须期望代码里有错误，期望发现错误的那个人是你而不是其他人。</p>\n<h2 id=\"单元测试的完整性\"><a href=\"#单元测试的完整性\" class=\"headerlink\" title=\"单元测试的完整性\"></a>单元测试的完整性</h2><p>在这Code Complete中给了我们一个测试中用例的最少数量计算方法：</p>\n<ol>\n<li>通过子程序的直路，开始时记1</li>\n<li>遇到关键字if, while, for, do, and, or及其等价物时加1</li>\n<li>遇到每一个case就加1，如果没有缺省情况，再加1</li>\n</ol>\n<p>按照这种方法，基础的代码路径覆盖已经达到了，但在复杂程序里譬如for中包含多个if的情况需要添加更多的测试用例，CC中给出了数据流测试，这里不再赘述，因为我觉得如果你的函数连基础测试用例都十几个的话，你该考虑的不是添加更多的测试，而是如何拆分这个函数了。</p>\n<h2 id=\"单元测试中的典型错误\"><a href=\"#单元测试中的典型错误\" class=\"headerlink\" title=\"单元测试中的典型错误\"></a>单元测试中的典型错误</h2><ol>\n<li>off-by-one错误</li>\n<li>边界值(刚好等于max，比max小1，比max大1)</li>\n<li>变量初始化(特别是循环中</li>\n<li>测试本身的错误</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>单元测试是开发保证自己工作质量的一个有力工具，在我看来，写单元测试要比靠手工去测试花费的时间少，效率高，修改方便。甚至在数据构造上，单元测试也比手工测试要方便快捷，毕竟页面上每次你都要把需要的数据都准备一遍，在代码里你需要修改的可能也就是两三处地方。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjbhgukz40000n8hxoookptif","tag_id":"cjbhgukzo0004n8hxa1oiz1tw","_id":"cjbhgul0g000dn8hxvm1a8b62"},{"post_id":"cjbhgukz40000n8hxoookptif","tag_id":"cjbhgul040008n8hxamvzdkgf","_id":"cjbhgul0i000fn8hx4w9mv52s"},{"post_id":"cjbhgukzi0002n8hxvva12syz","tag_id":"cjbhgul0e000bn8hxh0kr1gnw","_id":"cjbhgul0n000in8hxv0s31m0y"},{"post_id":"cjbhgukzv0005n8hx29rx6yn8","tag_id":"cjbhgul0e000bn8hxh0kr1gnw","_id":"cjbhgul0w000mn8hxnvephr40"},{"post_id":"cjbhgukzz0006n8hxpf67s2mk","tag_id":"cjbhgul0s000kn8hxjpmr3s9v","_id":"cjbhgul0z000pn8hxmxjcids5"},{"post_id":"cjbhgukzz0006n8hxpf67s2mk","tag_id":"cjbhgul0x000nn8hxg1gbs55w","_id":"cjbhgul0z000qn8hxpi1rf7bf"},{"post_id":"cjbhgul020007n8hxt84h4dnw","tag_id":"cjbhgukzo0004n8hxa1oiz1tw","_id":"cjbhgul11000tn8hxw3s7kau5"},{"post_id":"cjbhgul020007n8hxt84h4dnw","tag_id":"cjbhgul0y000on8hx9kao1txm","_id":"cjbhgul12000un8hxfbzc7ghs"},{"post_id":"cjbhgul020007n8hxt84h4dnw","tag_id":"cjbhgul0z000rn8hx7w0wn60a","_id":"cjbhgul15000wn8hx2jds51ag"},{"post_id":"cjbhgul060009n8hxe6onjsv3","tag_id":"cjbhgukzo0004n8hxa1oiz1tw","_id":"cjbhgul15000xn8hxsc7dns04"},{"post_id":"cjbhgul060009n8hxe6onjsv3","tag_id":"cjbhgul11000sn8hx60z3ks67","_id":"cjbhgul1a000zn8hxogjdc70f"},{"post_id":"cjbhgul0b000an8hx41io2ekg","tag_id":"cjbhgul14000vn8hxe1otq131","_id":"cjbhgul1c0010n8hx9jcuh608"},{"post_id":"cjbhgul0f000cn8hx2pa28ixa","tag_id":"cjbhgul17000yn8hx8r8ch5h1","_id":"cjbhgul1f0012n8hxya9elj03"},{"post_id":"cjbhgul0f000cn8hx2pa28ixa","tag_id":"cjbhgul040008n8hxamvzdkgf","_id":"cjbhgul1f0013n8hxkol8cmwa"},{"post_id":"cjbhgul0h000en8hx0usdojb8","tag_id":"cjbhgul0s000kn8hxjpmr3s9v","_id":"cjbhgul1h0016n8hxy6l904wf"},{"post_id":"cjbhgul0h000en8hx0usdojb8","tag_id":"cjbhgul1g0014n8hx1qy8ww26","_id":"cjbhgul1i0017n8hxtxu9f5z4"},{"post_id":"cjbhgul0l000hn8hx3ejjgvs9","tag_id":"cjbhgul1h0015n8hxbtpddseo","_id":"cjbhgul1j0019n8hx45ri78jx"},{"post_id":"cjbhgul0p000jn8hxbgg6uauf","tag_id":"cjbhgul1i0018n8hx5rvccssv","_id":"cjbhgul1p001cn8hx3f3esnrp"},{"post_id":"cjbhgul0p000jn8hxbgg6uauf","tag_id":"cjbhgul1m001an8hx8dxrs59f","_id":"cjbhgul1q001dn8hx5wgti0i3"},{"post_id":"cjbhgul0t000ln8hx6e7rpf6m","tag_id":"cjbhgul1o001bn8hxl6p1f7pt","_id":"cjbhgul1s001fn8hxs6zznhg0"},{"post_id":"cjbhgul0t000ln8hx6e7rpf6m","tag_id":"cjbhgul1q001en8hx2o4cfwxb","_id":"cjbhgul1s001gn8hxkj6m51va"}],"Tag":[{"name":"Ansible","_id":"cjbhgukzo0004n8hxa1oiz1tw"},{"name":"模块","_id":"cjbhgul040008n8hxamvzdkgf"},{"name":"思考","_id":"cjbhgul0e000bn8hxh0kr1gnw"},{"name":"Java","_id":"cjbhgul0s000kn8hxjpmr3s9v"},{"name":"CompeletableFuture","_id":"cjbhgul0x000nn8hxg1gbs55w"},{"name":"Cglib","_id":"cjbhgul0y000on8hx9kao1txm"},{"name":"代理","_id":"cjbhgul0z000rn8hx7w0wn60a"},{"name":"设计哲学","_id":"cjbhgul11000sn8hx60z3ks67"},{"name":"Liquibase","_id":"cjbhgul14000vn8hxe1otq131"},{"name":"spring boot","_id":"cjbhgul17000yn8hx8r8ch5h1"},{"name":"Optional","_id":"cjbhgul1g0014n8hx1qy8ww26"},{"name":"防御式编程","_id":"cjbhgul1h0015n8hxbtpddseo"},{"name":"卓有成效","_id":"cjbhgul1i0018n8hx5rvccssv"},{"name":"读书笔记","_id":"cjbhgul1m001an8hx8dxrs59f"},{"name":"单元测试","_id":"cjbhgul1o001bn8hxl6p1f7pt"},{"name":"测试","_id":"cjbhgul1q001en8hx2o4cfwxb"}]}}